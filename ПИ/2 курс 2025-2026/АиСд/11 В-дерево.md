## В-дерево - это 

➢B-дерево - структура данных, представляющая из себя сильноветвящееся сбалансированное дерево поиска.

➢Высота при n узлах порядка logn.

➢Количество детей узлов может быть от нескольких до тысяч(степень ветвления)

➢Идеально сбалансированное дерево - все листья на одном уровне.

## Свойства В-дерева

➢Ключи в каждом узле обычно упорядочены для быстрого доступа к ним.
➢Корень содержит от 1 до 2t-1 ключей.
➢Любой другой узел содержит от t-1 до 2t-1 ключей.
➢Любой узел, содержащий n ключей(K1, …, Kn), содержит n+1 потомков.
	○ Первый потомок и все его потомки содержат ключи ∈ (−∞,K1)
	○ Последний и все его потомки содержат ключи ∈ (Kn,∞)
	○ Все остальные потомки и их потомки содержат ключи ∈ (Ki-1,Ki)
![[Pasted image 20260113101856.png]]

## Поиск ключа

Поиск ключа начинается с корня:
➢Ключ содержится в текущем узле.
	○ Все хорошо, ключ найден.
➢Ключа нет в текущем узле:
	○ Определяем интервал, в котором должен содержаться ключ.
	○ Переходим к потомку, который соответствует данному интервалу.
	○ Повторяем все шаги.

## Добавление ключа

➢Ищем лист, в который можно добавить ключ, совершая проход от корня к листьям.
➢Если найденный узел незаполнен, добавляем в него ключ.
➢Иначе разбиваем узел на два узла, в первый добавляем первые t−1 ключей, во второй — последние t−1 ключей. Добавляем ключ в один из этих узлов.
➢Оставшийся средний элемент добавляется в родительский узел, где становится разделительной точкой для двух новых поддеревьев.
➢Если и родительский узел заполнен — повторяем пока не встретим незаполненный узел или не дойдем до корня. В последнем случае корень разбивается на два узла и высота дерева увеличивается.

## Удаление ключа
Операция удаления ключа сложнее операции вставки. Для менее запутанного объяснения разобьем данную операцию на два случая:
➢Удаление из листа
➢Удаление из внутреннего узла

Если количество ключей станет меньше t-1, то необходимо будет сделать дополнительные действия:
➢Перемещение ключа
➢Слияние

## Удаление из листа
Если ключей больше t−1, то просто удаляем ключ. Иначе:
➢Если существует соседний лист с тем же родителем, с больше чем t−1 ключами, выберем ключ-разделитель(k1) из соседа, разделяющий оставшиеся ключи соседа и ключи исходного узла.
➢Выберем другой ключ(k2) из родительского узла, разделяющий исходный узел и его соседа, который был выбран ранее.
➢Удалим из исходного узла ключ, который нужно было удалить, спустим в этот узел k2, а вместо k2 в родительском узле поставим k1.

➢Если все соседи содержат по t−1 ключу, то объединяем узел с каким-либо из соседей, удаляем ключ, и ключ из родительского узла, который был разделителем соседей, перемещаем в новый узел.![[Pasted image 20260113102914.png]]

## Удаление из внутреннего узла
Имеется внутренний узел и ключ, который нужно удалить(k). Если дочерний узел, предшествующий ключу k, содержит больше t−1 ключа:

➢Находим k1 – предшественника k в поддереве этого узла.
➢Удаляем его. Заменяем k в исходном узле на k1.
➢Проделываем аналогичную работу, если дочерний узел, следующий за ключом k, имеет больше t−1 ключа.

Если оба (следующий и предшествующий дочерние узлы) имеют по t−1 ключу:

➢Объединяем этих детей, переносим в них k.
➢Удаляем k из нового узла.
➢Если сливаются 2 последних потомка корня – то они становятся корнем, а предыдущий корень освобождается.

## Удаление из листа
![[Pasted image 20260113103307.png]]

## Перемещение и слияние ключей
![[Pasted image 20260113103338.png]]![[Pasted image 20260113103342.png]]

## Практическое применение
B-деревья разработаны для использования на дисках (в файловых системах) или иных энергонезависимых носителях информации с прямым доступом, а также в базах данных. B-деревья похожи на красно-чёрные деревья (например, в том, что все В-деревья с n узлами имеют высоту O(logn)), но они лучше минимизируют количество операций чтения-записи с диском.

## Вариации И-деревьев

Существуют 3 основновные дополнительные вариации B-дерева:
➢B+-дерево - ключи и данные хранятся только в листьях. Внутренние узлы содержат дублирующие ключи для навигации.
➢B*-дерево - узлы заполнены не менее чем на ⅔, вместо ½. Узел не разбивается на 2 узла, если полностью заполнен. Вместо этого ищется место в уже существующем соседнем узле, и только после того, как оба узла будут заполнены, они разделяются на три узла.
➢2-3 дерево - узлы содержат 2-3 потомка.