## Красно-чёрное дерево - это

➢Красно-черное дерево - это бинарное дерево поиска с одним дополнительным битом цвета в каждом узле. Цвет узла может быть либо красным (red), либо черным (black).
➢Красно-черные деревья являются приближенно сбалансированными: ни один путь от корня до листа (являющимся его потомком) в красно-черном дереве не отличается от другого по длине более чем в два раза.

## Обязательные свойства
➢Каждый узел является либо красным, либо черным.
➢Корень дерева является черным узлом.
➢Каждый лист дерева (NIL) является черным узлом.
➢Если узел красный, то оба его дочерних узла черные.
➢Для каждого узла все пути от него до листьев, являющихся потомками данного узла, содержат одно и то же количество черных узлов.![[Pasted image 20260113092812.png]]

## Поиск ключа
➢Поиск в красно-черном дереве ничем не отличается от поиска в бинарном дереве поиска.
➢Спускаемся вниз по текущему красно-черному дереву, выбирая направление спуска, как результат сравнения искомого ключа со значением ключа текущего узла (Если совпал ключ с искомым, то поиск завершен, если искомый меньше текущего, то идем в левую ветку, иначе в правую).
## Вставка ключа
➢Вставляемый узел всегда сначала имеет красный цвет.

➢Пусть буквой N будем обозначать текущий узел. P будем обозначать предка N, через G обозначим дедушку N, а U будем обозначать дядю (узел, имеющий общего родителя с узлом P).

➢Структура отношений узлов (цвета в данном случае не имеют значения):![[Pasted image 20260113093132.png]]
➢Случай 1: Текущий узел N вставляется в корень дерева. В этом случае он просто перекрашивается в чёрный цвет и вставка завершена.
➢Случай 2: Предок P текущего узла чёрный. В данном случае просто вставляем узел N и свойства не будут нарушены.
➢Случай 3: Если родитель P и дядя U — красные, то они оба могут быть перекрашены в чёрный, а дедушка G станет красным (для сохранения числа черных узлов). Однако, дедушка G теперь может нарушить свойства 2 или 4. Чтобы это исправить, вся процедура вставки рекурсивно выполняется для G (Т.е. считаем G новым ключом и заново проверяем все случаи).
![[Pasted image 20260113093539.png]]
➢Случай 4: P - красный, но U — чёрный, N — левый потомок P и P — левый потомок G. В этом случае выполняется малый правый поворот дерева относительно P. Известно, что G — чёрный, так как его бывший потомок P не мог бы в противном случае быть красным. Тогда цвета P и G меняются и в результате дерево удовлетворяет Свойствам 4 и 5.![[Pasted image 20260113093747.png]]

➢Случай 5: P - красный, но U — чёрный. Также, N — правый потомок P, а P — левый потомок G. В этом случае может быть произведен малый левый поворот дерева относительно N. Тогда, для бывшего родительского узла P в обновленной структуре все сводится к случаю 4, его и используем.![[Pasted image 20260113094143.png]]

##  Удаление ключа
*➢Случай 1*: Удаление узла с двумя нелистовыми потомками. При подобной операции в обычном двоичном дереве поиска мы ищем наименьший элемент в его правом поддереве и перемещаем его значение в удаляемый узел. Затем мы удаляем узел, из которого копировали значение. Копирование значения из одного узла в другой не нарушает свойств красно-чёрного дерева.
➢Стоит заметить, что новый удаляемый узел не может иметь сразу два дочерних нелистовых узла, так как в противном случае он не будет являться наименьшим элементом.
➢Таким образом, получается, что случай удаления узла, имеющего два нелистовых потомка, сводится к случаю удаления узла, содержащего как максимум один дочерний нелистовой узел.
➢Поэтому дальнейшее описание будет исходить из предположения существования у удаляемого узла не более одного нелистового потомка.
➢Будем использовать обозначение M для удаляемого узла; через C обозначим потомка M.

*➢Случай 2*: M является красным узлом. В таком случае заменим его своим потомком C, который по определению должен быть чёрным.

*➢Случай 3*: M — чёрный и C — красный. Простое удаление чёрного узла нарушит свойства 4 и 5, но если мы перекрасим С в чёрный, оба эти свойства сохранятся.

*➢Случай 4*: M — чёрный и C — чёрный. В таком случае M имеет 2 листа и C - один из листов, иначе нарушается свойство 5. Данный случай сложен, так как идет удаление чёрной вершины, а значит меняется чёрная высота ветки. Мы начнём с замены узла M своим потомком C.


➢Рассмотрим случаи балансировки КЧ дерева при таком удалении.
➢Переобозначим за N вершину C (которая является листом или NIL другими словами),  P - родитель удаленной вершины M, S - “брат” удаленной вершины M, S_l - левый потомок S, S_r - правый потомок S.
➢Белым обозначаются вершины
       цвет которых может быть любым.
![[Pasted image 20260113094329.png]]

➢Случай 4.1: N — новый корень. В этом случае дерево стало пустым.
➢Случай 4.2: S — красный. В этом случае мы меняем цвета P и S, и затем делаем вращение влево вокруг P, ставя S дедушкой N. Теперь N имеет чёрного брата и красного отца, поэтому мы свели к случаю 4.4, 4.5 или 4.6.
![[Pasted image 20260113094718.png]]➢Случай 4.3: P, S, и дети S — чёрные. В этом случае мы просто перекрашиваем S в красный. Тем не менее, все проходящие через P пути теперь содержат на один чёрный узел меньше, чем пути, которые через P не проходят, поэтому свойство 5 все ещё нарушено. Чтобы это исправить, мы применяем процедуру перебалансировки к P, начиная со случая 4.1.
![[Pasted image 20260113094919.png]]➢Случай 4.4: S и его дети — чёрные, но P — красный. В этом случае мы просто меняем цвета S и P.![[Pasted image 20260113094928.png]]
➢Случай 4.5: S — чёрный, S_l — красный, S_r — чёрный, и N является левым потомков своего отца. В этом случае мы вращаем дерево вправо вокруг S. Таким образом S_l становится его отцом и новым братом N. После этого мы меняем цвета у S и S_l. Теперь у N есть чёрный брат с красным правым потомком, и мы свели к случаю 4.6.
![[Pasted image 20260113094942.png]]

➢Случай 4.6: S — чёрный, S_l — чёрный, S_r — красный, и N является левым потомков своего отца. В этом случае мы вращаем дерево влево вокруг P, после чего S становится отцом P и своего правого потомка. Далее мы меняем местами цвета у P и S (P принимает цвет S, S принимает цвет P), и делаем правого потомка S чёрным.
![[Pasted image 20260113095039.png]]

➢Примечание: В случаях 4.2, 4.5, и 4.6 мы предполагаем, что N является левым потомком своего предка P. Если он — правый потомок, left и right нужно поменять местами во всех трех случаях.