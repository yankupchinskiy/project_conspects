## Тимсорт - это
гибридный алгоритм сортировки, сочетающий различные подходы.
На массивах данных, которые содержат упорядоченные подмассивы, данный алгоритм показывает себя намного лучше других сортировок.
## Идея алгоритма
➢Шаг 1. Входной массив разделяется на подмассивы фиксированной длины, вычисляемой определенным образом.
➢Шаг 2. Каждый подмассив сортируется сортировкой вставками, сортировкой пузырьком или любой другой устойчивой сортировкой.
➢Шаг 3. Отсортированные подмассивы объединяются в один массив с помощью модифицированной сортировки слиянием.


## Обозначения:
Введем следующие обозначения:

n — размер входного массива.
run — подмассив во входном массиве, который обязан быть упорядоченным одним из двух способов:
1.строго по убыванию ai>ai+1>…
2.нестрого по возрастанию ai⩽ai+1⩽…
minrun — минимальный размер подмассива, описанного в предыдущем пункте.
### Шаг 1: minrun
Число minrun определяется на основе n.

Оно не должно быть слишком большим, т.к. сортировка вставками неэффективна на больших данных.

Не должно быть слишком маленьким, т.к. иначе придется производить много итерация слияния.

Оптимальная величина для n/minrun — степень двойки. Это требование обусловлено тем, что алгоритм слияния подмассивов наиболее эффективно работает на подмассивах примерно равного размера.

Автором алгоритма было выбрано оптимальное значение, которое принадлежит диапазону [32;65)

Исключение: если n<64, тогда n=minrun и Timsort превращается в сортировку вставками.

Берем старшие 6 бит числа n и добавляем единицу, если в оставшихся младших битах есть хотя бы один ненулевой.
![[Pasted image 20260112163714.png]]

### Шаг 2: Разбиение на подмассивы
Начиная с первого элемента, во входном массиве идет поиск упорядоченного подмассива run. Если получившийся подмассив упорядочен по убыванию, то после вычисления run для текущего массива элементы переставляются так, чтобы они шли по возрастанию.

Если размер текущего run меньше minrun, тогда выбираются следующие за найденным подмассивом run элементы в количестве minrun−size(run). На выходе будет получен подмассив размером большим или равным minrun, часть которого (в лучшем случае — он весь) упорядочена.

К данному подмассиву применяем сортировку вставками. Так как размер подмассива невелик и часть его уже упорядочена — сортировка работает эффективно.
Переходим на следующий за подмассивом элемент.
Если конец входного массива не достигнут выполняем процедуру еще раз, но уже начиная с нового элемента.

### Шаг 3: Слияние подмассивов
Для оптимизации слияния алгоритм сортировки TimSort использует определенный порядок слияния блоков. Его основная идея заключается в слиянии блоков схожего размера.

Сам алгоритм можно описать следующим образом:
1. Создается стек блоков
2. В стек добавляется следующий блок
3. Если в стеке есть хотя бы 2 блока, то проверяются следующие инварианты:
Z > X + Y (проверяется, если в стеке есть хотя бы 3 блока)
Y > X,
где X, Y и Z - размеры 1-го, 2-го и 3-го блока в стеке соответственно.
Если хотя бы одно условие не выполняется, то блок Y сливается с наименьшим из X и Z (либо с X, если блока всего 2).
Данный шаг выполняется, пока не будут выполнены инварианты (либо станет меньше 2-х блоков)
4. Переход к шагу 2
Если после выполнения алгоритма в стеке остались блоки, то рассматриваются блоки X, Y и Z и блок Y сливается с наименьшим из X и Z, и так до опустошения стека.

#### Оптимзация алгоритма Галопом
В данном примере после слияния 7 из блока A слияние переходит в режим галопа, который ищет элементы после 7 меньше текущего элемента из блока B (200). Заметим, что блоки отсортированы, поэтому вместо обычного линейного поиска можно применить модификацию бинарного поиска - неточный поиск. Таким образом галоп будет искать в подмассиве [8, ..., 100] элемент больше 200, потратив на это максимум log2(93) + 1 операцию сравнения, то есть всего 7 сравнений. В итоге на слияние двух блоков понадобится не 100 сравнений, а 14.

|                |          |        |            |
| -------------- | -------- | ------ | ---------- |
|                | Время    | Память | Устойчивая |
| Худший случай  | n*log(n) | О(n)   | Да         |
| Средний случай | n*log(n) |        |            |
| Лучший случай  | n        |        |            |
Пусть k — число кусков, на которые разбился наш исходный массив, очевидно k = ⌈n / minrun⌉.

Главный факт, который нам понадобится для доказательства нужной оценки времени работы в O(nlog(n)) — это то, что сливаемые массивы всегда имеют примерно одинаковую длину. Можно сказать больше: пока k>3 сливаемые подмассивы будут именно одинаковой длины. Безусловно, после разбиения массива на блоки длиной minrun последний блок может быть отличен от данного значения, но число элементов в нём не превосходит константы minrun.При слиянии, длина образовавшегося слитого массива увеличивается в ≈2 раза. Таким образом получаем, что каждый подмассив может участвовать в не более O(log(n)) операций слияния, а значит и каждый элемент будет задействован в сравнениях не более O(log(n)) раз. Элементов n, откуда получаем оценку в O(nlog(n)).