## Двойная макс-куча (Binary heap)

Двоичная макс-куча - это двоичное дерево, в котором значение в каждой вершине не меньше значения в ее детях.  
Примечание: Дерево должно быть полностью заполнено на всех уровнях, кроме последнего, который заполняется слева направо
![[Pasted image 20260113104433.png]]

## Операции в куче

➢Найти максимальное (или минимальное, в зависимости от реализации) значение: это корень
➢Вставка: подвесить к листу новую вершину, а затем просеять ее вверх
➢Извлечь максимум: обмен корня и листа, просеивание вниз
➢Удалить элемент: изменить приоритет на бесконечность, просеять вверх, извлечь максимум

### Просеивание 
Для просеивания конкретного узла происходит за счет рекурсии и сравнения узла с детьми.
![[Pasted image 20260113104656.png]]

### Вставка
Для вставки новый узел после создания цепляется в самом конце кучи, после чего происходит просеивание.
![[Pasted image 20260113104719.png]]

### Удаление
Для удаления узла его необходимо поменять местами с последним узлом кучи, потом удалить и убедиться, что куча сохранила свои свойства![[Pasted image 20260113104850.png]]

## Биномиальное дерево
Биномиальное дерево - дерево, определяемое для каждого k=0,1,2,… следующим образом:

➢$_B0$ — дерево, состоящее из одного узла;
➢$B_k$ состоит из двух биномиальных деревьев $B_{k-1}$, связанных вместе таким образом, что корень одного из них является дочерним узлом корня второго дерева.
![[Pasted image 20260113105256.png]]
## Свойства биномиального дерева
Биномиальное дерево Bk с n вершинами:

➢Имеет 2k узлов.
➢Имеет высоту k.
➢Имеет ровно       узлов на высоте i, где
➢имеет корень степени k; степень всех остальных вершин меньше степени корня биномиального дерева(Степень - количество потомков)
➢максимальная степень произвольного узла равна logn

## Биномиальная куча
Биномиальная куча представляет собой множество биномиальных деревьев, которые удовлетворяют следующим свойствам:

➢каждое биномиальное дерево в куче подчиняется свойству мин-кучи.
➢для любого неотрицательного целого k найдется не более одного биномиального дерева, чей корень имеет степень k.

### Представление
Количество детей у узлов варьируется в широких пределах, поэтому ссылка на детей осуществляется через левого ребенка, а остальные дети образуют односвязный список с головой в виде левого ребенка. Каждый узел в биномиальной куче представляется набором полей:

●key — ключ (вес) элемента,
●parent — указатель на родителя узла,
●child — указатель на левого ребенка узла,
●sibling — указатель на правого брата узла,
●degree— степень узла.

Корни деревьев, из которых состоит куча, содержатся в списке корней, при проходе по которому степени соответствующих корней находятся в возрастающем порядке. Доступ к куче осуществляется ссылкой на первый корень в списке корней.
![[Pasted image 20260113105730.png]]

### Получение минимума
Для нахождения минимального элемента надо найти элемент в списке корней с минимальным значением. Для кучи, изображенной на картинке, будет возвращен указатель на вершину с ключом 1.
![[Pasted image 20260113105821.png]]Сложность - O(log n)

Обоснование:
Корней в списке не более ⌊logn⌋+1 => необходимо просмотреть не более ⌊logn⌋+1 элементов => сложность O(log n)
### Слияние
Сложность - O(log n)

Обоснование:

Корней в списке не более ⌊logn⌋+1 => необходимо просмотреть не более ⌊logn⌋+1 элементов => сложность O(log n)
![[Pasted image 20260113110011.png]]![[Pasted image 20260113110037.png]]

Сложность - O(log n)
Обоснование:
В получившемся списке могут встречаться пары соседних вершин одинаковой степени. Соединяем деревья равной степени и делаем это до тех пор, пока деревьев одинаковой степени не останется. Этот процесс соответствует сложению двоичных чисел столбиком, и время его работы пропорционально числу корневых вершин.

### Вставка
➢Создаем биномиальную кучу с одним элементом.
➢Объединить ее с нашей биномиальной кучей.

Сложность - O(logn)
Обоснование: Одна из сливаемых куч имеет всего одно дерево => “перенос разряда” необходимо будет сделать не более logn раз

### Извлечение минимума
![[Pasted image 20260113110606.png]]

![[Pasted image 20260113110641.png]]
### Уменьшение ключа узла
➢Изменяем значение ключа в этом узле
➢Просеиваем ключ вверх, как в обычной куче
Сложность - Θ(logn)

Обоснование: глубина узла, ключ которого нам необходимо изменить в худшем случае ⌊logn⌋+1. На каждом шаге движемся вверх по дереву.

### Удаление ключа
➢Изменяем значение ключа в этом узле на минимально возможное
➢Просеиваем ключ вверх
➢Извлекаем минимум из кучи
➢Сливаем нашу кучу с кучей детей удаленного ключа
Более простым языком: уменьшение ключа и удаление минимального элемента.

## Очередь с приоритетом

Очереди с приоритетом - это абстрактным тип данных, поддерживащий следующие операции:

➢добавление нового элемента в очередь с заданным приоритетом
➢извлечение элемента с максимальным приоритетом
➢удаление заданного элемента
➢нахождение максимального приоритета
➢изменение приоритета заданного элемента

Варианты реализации очереди можно разделить на:

➢Простейшие реализации:
	○ Связный список/массив
	○ Упорядоченный массив/список
➢Эффективная реализация:
	○ Двоичная куча
	○ Биномиальная куча
	![[Pasted image 20260113111221.png]]
	![[Pasted image 20260113111225.png]]