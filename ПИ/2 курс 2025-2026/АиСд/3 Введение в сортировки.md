# *count sort (сортировка подсчётом)* 
➢Основная идея алгоритма: произвести сопоставление:
число – количество вхождений этого числа.
выписать по возрастанию все вхождения чисел.
||Время|Память|Устойчивая|
|Худший случай|O(n+k)|O(n+k)|Нет|
|Средний случай|O(n+k)|
|Лучший случай|O(n+k)|

---
# *insert sort(Сортировка вставками)*
1. Массив разбивается на отсортированную и неотсортированную части
2. Берем элемент в неотсортированной части массива
3. Находим место элемента в отсортиованной части массива и вставляем
||Время|Память|Устойчивая|
|Худший случай|n^2|in-place|Да|
|Средний случай|n^2|
|Лучший случай|n|

*Сортировка Шелла*
Усовершенствованный вариант сортировки вставками, основанный на идее предварительной сортировки элементов, отстоящих друг от друга на некотором расстоянии hi.

1.Выбирается последовательность смещений ht, ht-1,...,h0, где h0=1.
2.Разбиваем массив на hi подмассивов, состоящих из элементов на расстоянии hi.
3.Объединяем подмассивы в массив.
4.Повторяем до h0.

Сложность зависит от выбранной последовательности. Существуют следующие последовательности:
1.По Шеллу:  N/2, N/4,…, 1.
2.По Хиббарду: все 2i - 1 ≤ N по убыванию
3.По Пратту: все 2i * 3j ≤ N/2 по убыванию

|   |   |   |   |
|---|---|---|---|
|Последовательность|Время|Память|Устойчивая|
|По Шеллу|O(n2)|in-place|Нет|
|По Хиббарду|O(n3/2)|
|По Пратту|O(n log2(n))|

---
# *Merge sort(сортировка слиянием)*
1.Рекурсивно массив разбивается надвое
2.Если в массиве 1 элемент => массив отсортирован
3.Отсортированные подмассивы объединяются

||Время|Память|Устойчивая|
|Худший случай|n * log(n)|O(n)|Да|
|Средний случай|n * log(n)|
|Лучший случай|n * log(n)|

---
# *Quick sort(быстрая сортировка)*
Выбирается опорный элемент. Все значения меньшие его перемещаются влево от него, а все ключи большие либо равные - вправо.
Далее алгоритм рекурсивно применяется к каждой из частей.

||Время|Память|Устойчивая|
|Худший случай|n^2|О(n)
В оптимизации O(log(n))|Нет|
|Средний случай|nlog(n)|
|Лучший случай|nlog(n)|

Время:
В худшем случаем опорный элемент k приведет к сдвигу (k-1) элементов. O(k*(k-1)) == O(k^2) или же O(n^2).
В случае выбора (или почти хорошего) опорного элемента рекурсия даст логарифмическую сложность О(nlog(n))
Память:
Необходимо сохранить каждый элемент (n).

---
# *Radix sort(цифровая сортировка)*
Сортировка чисел(строк) по разрядам:
### ●*LSD*-сортировка: от младших разрядов к старшим.
●Итерация по разрядом: от младшего к старшему.
●Устойчивая сортировка на каждом шаге(обычно используется сортировка подсчетом).![[Pasted image 20260112162751.png]]

|Время|Память|Устойчивая|
|O(mT(n))<br><br>O(m*(n+k)) - CountSort|O(T(n))<br><br>О(n + k) - CountSort|Да|
### ●*MSD*-сортировка: от старших к младшим.

![[Pasted image 20260112162809.png]]
●Итерация по разрядом: от старшего к младшему.
●Разделение по старшему неотсортированному разряду на k подмассивов.
●Повторение для всех непустых подмассивов. 
||Время|Память|Устойчивая|
|Худший случай|O(nk)|О(n + k)|Нет|
|Лучший случай|Ω(n logb(n))|
