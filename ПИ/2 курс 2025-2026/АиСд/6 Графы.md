## Граф - это

➢Граф - математическая абстракция любой реальной системы, объекты которой обладают парными связями.
➢Граф состоит из вершин(самих объектов) и рёбер(парных связей).

## Классификация графов

➢*Ненаправленный* - граф, в котором ребра не имеют определенного направления, т.е. по всем ребрам можно передвигаться в обе стороны.
➢*Ориентированный* - граф, в котором ребра имеют направление от одной вершины к другой, т.е. по ребрам можно передвигаться только в определенном направлении.
➢*Связный* - граф, в котором из любой вершины есть путь в любую другую вершину.
➢*Несвязный* - граф, в котором существует хотя бы одна вершина, из которой нельзя добраться до хотя бы одной другой вершины.
➢*Ацикличный* - граф, в котором нет циклов.
➢*Полный* - граф, в котором любые две различные вершины соединены ребром.
➢*Взвешенный* - граф, в котором каждое ребро имеет вес.

## Сопутствующие определения
➢*Вершина* - один из основных элементов графа, представляющий отдельный объект.
➢*Ребро* - связь между двумя вершинами графа.
➢Элементами графа называются его вершины.
➢*Соседние вершины* - вершины, между которыми есть прямая связь(ребро).
➢*Изолированная вершина* - вершина, которая не соединена ни с одной другой вершиной.
➢*Маршрут* - конечная последовательность вершин, в которой каждая вершина (кроме последней) соединена со следующей в последовательности вершиной ребром.
➢*Цепь* - маршрут без повторяющихся ребер.
➢*Простая цепь* - маршрут без повторяющихся вершин.
➢*Цикл* - цепь, в которой первая и последняя вершины совпадают.

## Визуализация
Для работы с графом в программе удобно представлять его в виде матрицы смежности. Матрица смежности - таблица, где как столбцы, так и строки соответствуют вершинам графа. В каждой ячейке этой матрицы записывается число, определяющее наличие связи(или длину пути) от вершины-строки к вершине-столбцу.
![[Pasted image 20260112171858.png]]

## Обход графов
➢Обход графа - просмотр всех вершин графа в определенном порядке. Существует два вида обхода графа:
○ Обход в глубину - рекурсивный алгоритм.
○ Обход в ширину - использует очередь для определения порядка просмотра вершин.

## В глубину 
➢Общая идея обхода состоит в том, чтобы найти для текущей вершины все непосещенные соседние вершины и повторить поиск для них:
○ Выбираем любую непосещенную вершину
○ Запускаем алгоритм для выбранной вершины:
	■Помечаем вершину как посещенную.
	■Для каждой соседней непосещенной вершины запускаем алгоритм.
○Повторяем шаги 1 и 2, пока все вершины не будут просмотрены.
![[Pasted image 20260112172122.png]]
## В ширину
➢Общая идея обхода заключается в последовательном просмотре отдельных уровней графа, начиная со стартовой вершины графа:
○ Устанавливаем для всех вершин уровень равный -1.
○ Устанавливаем для стартовой вершины уровень 0.
○ Добавляем в пустую очередь стартовую вершину.
○ Достаем из очереди текущую вершину.
○ Находим все соседние вершины для текущей вершины.
	■Если вершина не посещена(т.е. уровень равен -1):
	■Устанавливаем уровень вершины равный уровню текущей вершины + 1 и добавляем вершину в очередь.
○ Возвращаемся к шагу 4, пока очередь не опустеет.
![[Pasted image 20260112172255.png]]
## Алгоритм Дейкстры
Алгоритм Дейкстры — это классический алгоритм поиска пути. Этот алгоритм используется для поиска кратчайшего пути в взвешенном графе от одной вершины (обозначим ее как начальную) до всех остальных вершин.
Алгоритм применяется к взвешенному графу, ребра которого не имеют отрицательного веса.

### Принцип работы
Заводим массив, в котором будем хранить кратчайшее расстояние от начальной вершины до всех вершин. Заполняем массив значениями (inf), а для стартовой точки устанавливаем значение 0. Посещая непосещенные вершины, обновляем значения массива, находя более оптимальные пути к вершинам и уменьшая расстояние до них.

*Пошагово*: 
➢Инициализируем массив расстояний.
➢Помечаем все вершины графа как непосещенные.
➢Повторяем, пока все вершины не будут посещены:
	○ Выбираем из списка непосещенных вершин вершину с наименьшим расстоянием до нее.
	○ Рассчитываем и при необходимости обновляем расстояние для каждого непосещенного соседа текущей вершины.
	○ Отмечаем текущую вершину как посещенную.
	![[Pasted image 20260112172509.png]]
### Сложность алгоритма Дейкстры
Сложность алгоритма Дейкстры зависит от способа выбора текущей вершины, а также способа хранения множества непосещённых вершин и способа обновления меток. Обозначим через n количество вершин, а через m — количество рёбер в графе.
В простейшем случае, когда для поиска вершины с минимальным путем до нее просматривается всё множество вершин, а для хранения величин путей используется массив, время работы алгоритма есть O(n2). Основной цикл выполняется порядка n раз, в каждом из них на нахождение минимума тратится порядка n операций. На циклы по соседям каждой посещаемой вершины тратится количество операций, пропорциональное количеству рёбер m (поскольку каждое ребро встречается в этих циклах ровно дважды и требует константное число операций). Таким образом, общее время работы алгоритма O(n2+m), но, так как m≤n(n−1), оно составляет O(n2).
Также непосещенные вершины можно хранить в двоичной куче, а в качестве ключа использовать расстояние до вершины, тогда время удаления вершины из списка посещенных вершин станет O(log(n)) при том, что время модификации значений расстояния возрастает до O(log(n)). Так как цикл выполняется порядка n раз, а количество смен меток не больше m, время работы такой реализации — O(nlog(n) +mlog(n)).