
## Парадигма программирования - это

 фундаментальный подход или стиль написания кода, набор концепций и правил, определяющих, как структурировать программу и организовывать вычисления, например, через инструкции (императивная) или описание результата (декларативная). Основные парадигмы включают императивную (процедурное, ООП), декларативную (функциональное, логическое) и другие, которые влияют на выбор инструментов и подходы к решению задач, не привязываясь к одному языку.

---
### Императивная:

Первая появившаяся из парадигм сформировалась, когда программы записывались на машинном языке. Написанный в соответствии с этой парадигмой код будет отвечать на вопрос: «Как именно должна работать программа и что она должна делать?»

Для императивного программирования характерны следующие черты:

- Компьютер выполняет последовательно записанные команды.
- Инструкции могут использовать результаты, полученные после выполнения предыдущих команд.
- Данные могут сохраняться в памяти.
- Состояние программы может изменяться после каждой инструкции.
- Основа императивного программирования — операторы присваивания, которые управляют состоянием переменных.

Эти признаки довольно абстрактны, и сразу видно, что они могут использоваться почти в любом коде.

Чистый императивный код — машинный язык. Писать на нём программы неудобно: код сложно воспринимать, приходится дублировать отдельные фрагменты скриптов и часто пользоваться операторами присваивания.

---
###  Декларативная

Если императивное программирование подразумевает максимально подробные инструкции для машины, то декларативная парадигма работает по-другому: описывает не способ решения, а желаемый результат. Она отвечает на вопрос: «Что делает программа и что должно получиться в итоге?»

Как это выглядит:

- Компьютер сам выбирает действия для достижения результата.
- Состояние программы не меняется и не отслеживается в процессе работы.
- Декларативное программирование не использует переменные и операторы присваивания.

Звучит проще императивной парадигмы, и декларативный подход действительно серьёзно облегчает работу. Преимущества декларативной парадигмы можно свести к двум основным:

1. **Точная адаптация под конкретные задачи.** Декларативное программирование создаёт высокоуровневый слой функциональности, который выполняет заранее продуманные инструкции.
2. **Защита от ошибок.** Скрытая реализация не даёт что-то поломать в системе. Например, мы можем неправильно использовать запросы SQL, но не можем испортить сами запросы.

Пример декларативного языка программирования — язык запросов SQL. Он точно адаптирован к разным аспектам работы с базами данных, это простой и удобный интерфейс для взаимодействия с ними. Мы не знаем, как именно работают конкретные запросы, мы просто задаём конечную цель и ограничения. Например: «Возьми базу клиентов и выбери оттуда всех покупателей за последний месяц, при этом они должны быть мужского пола, не женаты, но иметь детей».
#### Процедурная
почти как Декларативная, но с более подробным дроблением функция

---
## ООП
Объектно-ориентированный код собирает функции в классы и их экземпляры — объекты. Можно создать класс и уже внутри него прописать функции, которые смогут использовать все объекты класса. Такие функции будут называться методами.

ООП — это императивное программирование с тремя дополнительными абстракциями: инкапсуляцией, наследованием и полиморфизмом.

[Объектно-ориентированное программирование: на пальцах](https://thecode.media/objective/)

- Наследование - Это механизм, который позволяет создавать новый класс (**производный класс, дочерний класс, подкласс**) на основе уже существующего (**базового класса, родительского класса, суперкласса**). Производный класс автоматически получает (наследует) поля и методы базового класса и может добавлять свои собственные или изменять унаследованные.


- Абстракция - Это принцип, который позволяет выделять **существенные характеристики** объекта, игнорируя несущественные детали его реализации. Мы работаем с объектом через его упрощенный интерфейс (публичные методы), не зная, _как именно_ он выполняет свои функции внутри.

- **Пример:** Водитель автомобиля использует руль, педали и рычаг коробки передач (интерфейс), не зная деталей работы двигателя, системы впрыска топлива и т.д. (скрытая реализация).

- Полиморфизм — Это принцип, позволяющий **одному и тому же коду работать с объектами разных типов**. Иными словами, один интерфейс — множество реализаций. Полиморфизм позволяет производным классам иметь свои собственные реализации методов, уже существующих в базовом классе.

- **Пример:** У базового класса `Фигура` есть метод `нарисовать()`. У классов-наследников `Круг`, `Квадрат` и `Треугольник` есть свои реализации этого метода. Код, работающий с объектом типа `Фигура`, может вызвать `нарисовать()`, и будет выполнена правильная версия метода в зависимости от того, объект какого конкретного класса (Круг, Квадрат) ему передан.



- Инкапсуляция - Это принцип, объединяющий **данные (поля)** и **методы**, которые работают с этими данными, в одной единице (классе), и **скрывающий внутреннее состояние объекта от прямого доступа извне**. Доступ к данным осуществляется только через публичные методы класса (геттеры/сеттеры). Это защищает данные от несанкционированного изменения и обеспечивает целостность объекта.

- **Пример:** Поле `баланс` в классе `БанковскийСчет` объявлено как приватное (`private`). Изменить его напрямую нельзя. Для этого есть публичные методы `положитьДеньги(сумма)` и `снятьДеньги(сумма)`, которые содержат логику проверки (например, нельзя снять больше, чем есть на счете).


