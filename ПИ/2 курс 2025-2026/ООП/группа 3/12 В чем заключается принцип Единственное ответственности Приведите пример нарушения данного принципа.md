# Принцип единственной ответственности (Single Responsibility Principle - SRP)

## Что такое SRP?

**SRP** — первый принцип SOLID, который гласит: *"Класс должен иметь одну и только одну причину для изменения"*. Это означает, что каждый класс должен отвечать за одну конкретную задачу или функциональность.

## Суть принципа

```cpp
// ❌ НАРУШЕНИЕ SRP: Класс делает слишком много
class Employee {
private:
    std::string name;
    double salary;
    std::string email;
    
public:
    // 1. Работа с данными сотрудника
    void setName(const std::string& n) { name = n; }
    std::string getName() const { return name; }
    
    // 2. Расчет зарплаты
    double calculateSalary(int hours) {
        return hours * 100;  // бизнес-логика
    }
    
    // 3. Сохранение в базу данных
    void saveToDatabase() {
        // SQL запросы
        // std::cout << "INSERT INTO employees..." << std::endl;
    }
    
    // 4. Генерация отчетов
    void generateReport() {
        // Генерация PDF/Excel
        // std::cout << "Generating report..." << std::endl;
    }
    
    // 5. Отправка email
    void sendEmail(const std::string& message) {
        // Работа с SMTP
        // std::cout << "Sending email..." << std::endl;
    }
};
```

**Проблема:** Класс `Employee` нарушает SRP, потому что:
1. Управляет данными сотрудника
2. Содержит бизнес-логику расчета зарплаты
3. Работает с базой данных
4. Генерирует отчеты
5. Отправляет email

## Примеры нарушения SRP

### Пример 1: **"Божественный объект" (God Object)**
```cpp
// ❌ МЕГА-КЛАСС, который делает все
class Application {
private:
    // Данные пользователя
    UserData userData;
    
    // Настройки
    Config settings;
    
    // Кэш
    Cache cache;
    
    // Соединения
    DatabaseConnection db;
    NetworkConnection net;
    
public:
    // UI операции
    void renderUI() { /* ... */ }
    void handleClick() { /* ... */ }
    
    // Бизнес-логика
    void processOrder() { /* ... */ }
    void calculateTax() { /* ... */ }
    
    // Работа с данными
    void saveToDB() { /* ... */ }
    void loadFromDB() { /* ... */ }
    
    // Сетевое взаимодействие
    void sendHTTPRequest() { /* ... */ }
    void parseJSON() { /* ... */ }
    
    // Логирование
    void logError() { /* ... */ }
    void logDebug() { /* ... */ }
    
    // Утилиты
    void validateInput() { /* ... */ }
    void formatDate() { /* ... */ }
    
    // Конфигурация
    void loadConfig() { /* ... */ }
    void saveConfig() { /* ... */ }
};
```

### Пример 2: **Смешение абстракций**
```cpp
// ❌ Класс смешивает разные абстракции
class Document {
private:
    std::string content;
    std::string filename;
    
public:
    // 1. Управление содержимым
    void setContent(const std::string& text) { content = text; }
    std::string getContent() const { return content; }
    
    // 2. Работа с файлами (другая ответственность!)
    void saveToFile() {
        std::ofstream file(filename);
        file << content;
        file.close();
    }
    
    void loadFromFile() {
        std::ifstream file(filename);
        std::stringstream buffer;
        buffer << file.rdbuf();
        content = buffer.str();
    }
    
    // 3. Форматирование текста (еще одна ответственность!)
    void formatAsHTML() {
        content = "<html><body>" + content + "</body></html>";
    }
    
    void formatAsMarkdown() {
        // Преобразование в Markdown
    }
    
    // 4. Печать (и еще одна!)
    void print() {
        std::cout << "Printing document..." << std::endl;
        // Логика печати
    }
};
```

### Пример 3: **Сервис, который делает всё**
```cpp
// ❌ Сервис с множеством ответственностей
class UserService {
public:
    // Аутентификация
    bool authenticate(const std::string& username, const std::string& password) {
        // Проверка пароля
        // Генерация токена
        // Запись в лог
        return true;
    }
    
    // Управление пользователями
    User createUser(const UserData& data) {
        // Валидация данных
        // Создание в БД
        // Отправка приветственного email
        // Логирование
        return User();
    }
    
    // Восстановление пароля
    void resetPassword(const std::string& email) {
        // Генерация токена сброса
        // Отправка email
        // Обновление БД
        // Логирование
    }
    
    // Генерация отчетов
    Report generateUserReport() {
        // Запрос к БД
        // Агрегация данных
        // Форматирование отчета
        // Сохранение файла
        return Report();
    }
    
    // Отправка уведомлений
    void sendNotification(int userId, const std::string& message) {
        // Получение предпочтений пользователя
        // Форматирование сообщения
        // Отправка (email/SMS/push)
        // Логирование
    }
};
```

## Последствия нарушения SRP

### 1. **Трудности с тестированием**
```cpp
// ❌ Сложно тестировать из-за множества зависимостей
class OrderProcessor {
public:
    double calculateTotal(Order& order) {
        // Бизнес-логика
        double total = order.subtotal * 1.2;  // +20% налог
        
        // Побочный эффект: сохранение в БД
        database.save(order);
        
        // Побочный эффект: отправка email
        emailService.sendReceipt(order);
        
        // Побочный эффект: логирование
        logger.log("Order processed");
        
        return total;
    }
};

// Тестирование становится кошмаром:
TEST(OrderProcessorTest, CalculateTotal) {
    OrderProcessor processor;
    Order order;
    // Нужно мокировать БД, email сервис, логгер...
    // И все это для теста простого расчета!
}
```

### 2. **Сложность рефакторинга**
```cpp
// ❌ Изменение в одной области затрагивает все
class ReportGenerator {
public:
    void generate() {
        // 1. Получение данных
        Data data = database.query();
        
        // 2. Обработка
        Data processed = processData(data);
        
        // 3. Форматирование
        std::string html = formatAsHTML(processed);
        
        // 4. Экспорт
        saveToFile(html, "report.html");
        
        // 5. Отправка
        emailService.send("boss@company.com", html);
    }
    
    // Если нужно изменить формат с HTML на PDF:
    // 1. Меняем форматирование
    // 2. Меняем сохранение файла (расширение)
    // 3. Меняем отправку (вложение вместо HTML тела)
    // Все в одном методе!
};
```

### 3. **Дублирование кода**
```cpp
// ❌ Похожие функциональности в разных классах
class ProductService {
public:
    void saveProduct(Product& p) {
        // Валидация
        validate(p);
        // Сохранение в БД
        database.save(p);
        // Логирование
        logger.log("Product saved");
    }
};

class UserService {
public:
    void saveUser(User& u) {
        // Та же валидация, но для пользователя
        validate(u);
        // То же сохранение
        database.save(u);
        // То же логирование  
        logger.log("User saved");
    }
    
private:
    // Дублированная валидация
    void validate(const User& u) {
        if (u.name.empty()) throw ValidationError();
        // ...
    }
};
```

## Как соблюдать SRP

### Решение 1: **Разделение по ответственностям**
```cpp
// ✅ Правильное разделение ответственностей
class Employee {
private:
    std::string name;
    double salary;
    
public:
    // Только данные и их доступ
    void setName(const std::string& n) { name = n; }
    std::string getName() const { return name; }
    
    void setSalary(double s) { salary = s; }
    double getSalary() const { return salary; }
};

// Отдельный класс для расчета зарплаты
class SalaryCalculator {
public:
    double calculate(const Employee& emp, int hours) {
        return hours * 100;  // Бизнес-логика
    }
};

// Отдельный класс для работы с БД
class EmployeeRepository {
public:
    void save(const Employee& emp) {
        // SQL запросы
        // std::cout << "INSERT INTO employees..." << std::endl;
    }
    
    Employee load(int id) {
        // Загрузка из БД
        return Employee();
    }
};

// Отдельный класс для отчетов
class ReportGenerator {
public:
    void generateReport(const Employee& emp) {
        // Генерация отчета
    }
};

// Отдельный класс для уведомлений
class NotificationService {
public:
    void sendEmail(const Employee& emp, const std::string& message) {
        // Отправка email
    }
};
```

### Решение 2: **Использование композиции**
```cpp
// ✅ Композиция вместо монолитного класса
class OrderProcessor {
private:
    TaxCalculator taxCalculator;
    DatabaseRepository repository;
    EmailService emailService;
    Logger logger;
    
public:
    double processOrder(Order& order) {
        // 1. Расчет (делегируем TaxCalculator)
        double total = taxCalculator.calculate(order);
        
        // 2. Сохранение (делегируем DatabaseRepository)
        repository.save(order);
        
        // 3. Уведомление (делегируем EmailService)
        emailService.sendReceipt(order);
        
        // 4. Логирование (делегируем Logger)
        logger.log("Order processed");
        
        return total;
    }
};
```

### Решение 3: **Выделение сервисов**
```cpp
// ✅ Разделение UserService на специализированные сервисы
class AuthenticationService {
public:
    bool authenticate(const std::string& username, const std::string& password);
    Token generateToken(const User& user);
};

class UserManagementService {
public:
    User createUser(const UserData& data);
    void updateUser(int userId, const UserData& updates);
    void deleteUser(int userId);
};

class PasswordService {
public:
    void resetPassword(const std::string& email);
    void changePassword(int userId, const std::string& newPassword);
};

class NotificationService {
public:
    void sendWelcomeEmail(const User& user);
    void sendPasswordResetEmail(const std::string& email);
    void sendNotification(int userId, const std::string& message);
};

class ReportingService {
public:
    Report generateUserReport();
    Report generateActivityReport();
};
```

## Практическое правило определения SRP

### "Правило одного изменения"
```cpp
// Спросите себя: "По каким причинам может измениться этот класс?"
class Invoice {
public:
    // Причина 1: Изменение формата расчета
    double calculateTotal() {
        return subtotal + tax - discount;
    }
    
    // Причина 2: Изменение формата вывода
    void print() {
        std::cout << "Invoice #" << number << std::endl;
        std::cout << "Total: $" << calculateTotal() << std::endl;
    }
    
    // Причина 3: Изменение способа сохранения
    void saveToFile() {
        std::ofstream file("invoice.txt");
        file << "Invoice data...";
    }
    
    // Причина 4: Изменение правил валидации
    bool isValid() {
        return subtotal > 0 && !customerName.empty();
    }
};
// 4 причины для изменения → нарушает SRP!
```

## Примеры хорошего SRP

### Пример 1: **Чистый класс сущности**
```cpp
// ✅ Только данные, никакой бизнес-логики
class Product {
private:
    int id;
    std::string name;
    double price;
    int stockQuantity;
    
public:
    // Конструкторы
    Product(int id, std::string name, double price, int stock)
        : id(id), name(std::move(name)), price(price), stockQuantity(stock) {}
    
    // Геттеры (доступ к данным)
    int getId() const { return id; }
    std::string getName() const { return name; }
    double getPrice() const { return price; }
    int getStockQuantity() const { return stockQuantity; }
    
    // Сеттеры (изменение данных)
    void setPrice(double newPrice) { 
        if (newPrice >= 0) price = newPrice; 
    }
    
    void setStockQuantity(int quantity) {
        if (quantity >= 0) stockQuantity = quantity;
    }
    
    // Никакой бизнес-логики, работы с БД, UI и т.д.
};
```

### Пример 2: **Сервис с одной ответственностью**
```cpp
// ✅ Только валидация данных
class UserValidator {
public:
    bool validateUsername(const std::string& username) {
        if (username.empty()) return false;
        if (username.length() < 3 || username.length() > 20) return false;
        if (!std::regex_match(username, std::regex("^[a-zA-Z0-9_]+$"))) return false;
        return true;
    }
    
    bool validateEmail(const std::string& email) {
        // Проверка формата email
        std::regex emailRegex(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");
        return std::regex_match(email, emailRegex);
    }
    
    bool validatePassword(const std::string& password) {
        // Проверка сложности пароля
        if (password.length() < 8) return false;
        bool hasUpper = false, hasLower = false, hasDigit = false;
        for (char c : password) {
            if (std::isupper(c)) hasUpper = true;
            if (std::islower(c)) hasLower = true;
            if (std::isdigit(c)) hasDigit = true;
        }
        return hasUpper && hasLower && hasDigit;
    }
};
```

### Пример 3: **Repository pattern**
```cpp
// ✅ Только работа с хранилищем данных
class UserRepository {
private:
    DatabaseConnection db;
    
public:
    User findById(int id) {
        // SQL: SELECT * FROM users WHERE id = ?
        // Преобразование результата в объект User
        return User();
    }
    
    std::vector<User> findAll() {
        // SQL: SELECT * FROM users
        // Преобразование результатов
        return {};
    }
    
    void save(const User& user) {
        if (user.getId() == 0) {
            // INSERT
        } else {
            // UPDATE
        }
    }
    
    void deleteById(int id) {
        // SQL: DELETE FROM users WHERE id = ?
    }
    
    // Только CRUD операции, никакой бизнес-логики
};
```

## Преимущества соблюдения SRP

```cpp
// Соблюдение SRP дает:
class SRPBenefits {
public:
    // 1. ЛЕГКОЕ ТЕСТИРОВАНИЕ
    void testability() {
        // Каждый класс тестируется изолированно
        // Можно использовать моки для зависимостей
    }
    
    // 2. ПРОСТОТА ПОНИМАНИЯ
    void understandability() {
        // Класс делает одну вещь → легко понять его назначение
    }
    
    // 3. УПРОЩЕНИЕ РЕФАКТОРИНГА
    void refactoringEase() {
        // Изменения в одной области не затрагивают другие
    }
    
    // 4. ПЕРЕИСПОЛЬЗОВАНИЕ КОДА
    void reusability() {
        // Классы с одной ответственностью легче переиспользовать
    }
    
    // 5. СНИЖЕНИЕ КОЛИЧЕСТВА КОНФЛИКТОВ
    void mergeConflicts() {
        // Разные разработчики работают с разными классами
        // Меньше конфликтов при слиянии кода
    }
};
```

## Как определить нарушение SRP?

### Признаки "запаха кода":
1. **Класс имеет слишком много методов** (более 10-15 публичных методов)
2. **Методы класса логически не связаны** между собой
3. **Класс зависит от многих других классов** (высокая связность)
4. **Изменения в одной части класса требуют изменений в других частях**
5. **Тестирование класса требует мокирования множества зависимостей**

### Практический тест:
```cpp
// Задайте вопросы:
class SRPTest {
    // 1. Можно ли описать назначение класса одним предложением?
    //    "Этот класс отвечает за ______"
    
    // 2. Если нужно изменить ______, придется ли менять этот класс?
    //    (должна быть только одна причина)
    
    // 3. Можно ли вынести часть функциональности в отдельный класс
    //    без потери смысла?
};
```

## Заключение

**SRP — это фундаментальный принцип, который помогает создавать:**
- ✅ **Поддерживаемый код** (легко изменять и расширять)
- ✅ **Тестируемый код** (можно тестировать изолированно)
- ✅ **Переиспользуемый код** (классы делают одну вещь, но делают её хорошо)
- ✅ **Читаемый код** (легко понять назначение класса)

**Помните:** Нарушение SRP — самая распространенная проблема в проектах. Если класс становится слишком большим или сложным — спросите себя: "Не нарушает ли он принцип единственной ответственности?"