# Проблемы с вызовом деструктора при наследовании в C++

## Основные проблемы

### 1. **Невиртуальный деструктор в базовом классе (самая опасная проблема)**
```cpp
class Base {
public:
    Base() { cout << "Base constructor" << endl; }
    ~Base() { cout << "Base destructor" << endl; }  // ❌ НЕ виртуальный!
};

class Derived : public Base {
public:
    Derived() { 
        data = new int[100];
        cout << "Derived constructor" << endl; 
    }
    ~Derived() { 
        delete[] data;  // ⚠️ Этот деструктор может НЕ вызваться!
        cout << "Derived destructor" << endl; 
    }
private:
    int* data;
};

int main() {
    Base* obj = new Derived();  // Указатель базового типа
    delete obj;  // ⚠️ ОПАСНО: вызовется только ~Base(), ~Derived() НЕ вызовется!
    // УТЕЧКА ПАМЯТИ: массив data не освобождается
}
```

**Правильное решение:**
```cpp
class Base {
public:
    virtual ~Base() {  // ✅ Виртуальный деструктор
        cout << "Base destructor" << endl;
    }
};
```

### 2. **Неправильный порядок вызова деструкторов**
```cpp
class Resource {
public:
    Resource() { cout << "Resource acquired" << endl; }
    ~Resource() { cout << "Resource released" << endl; }
};

class Base {
public:
    Base() { cout << "Base constructor" << endl; }
    virtual ~Base() { cout << "Base destructor" << endl; }
};

class Derived : public Base {
private:
    Resource res;
public:
    Derived() { cout << "Derived constructor" << endl; }
    ~Derived() override { 
        cout << "Derived destructor" << endl;
        // Ресурсы освобождаются ЗДЕСЬ
    }
};

int main() {
    Derived d;
    // При выходе из области видимости:
    // 1. ~Derived() (выводит "Derived destructor")
    // 2. Деструктор Resource (автоматически)
    // 3. ~Base()
}
```
**Правильный порядок:** Деструкторы вызываются в обратном порядке конструкторов:
1. Деструктор производного класса
2. Деструкторы членов класса (в обратном порядке объявления)
3. Деструкторы базовых классов (в обратном порядке наследования)

### 3. **Явный вызов деструктора (опасная практика)**
```cpp
class Base {
public:
    virtual ~Base() { cout << "Base dtor" << endl; }
};

class Derived : public Base {
public:
    ~Derived() override { cout << "Derived dtor" << endl; }
};

int main() {
    Derived* d = new Derived();
    
    d->~Derived();  // ⚠️ Явный вызов деструктора
    
    // ПРОБЛЕМЫ:
    // 1. Память не освобождена (не вызван operator delete)
    // 2. Деструктор базового класса НЕ вызван автоматически
    // 3. Объект "мертв", но память все еще занята
    
    // Нужно также явно вызвать деструктор базового класса:
    d->Base::~Base();  // ⚠️ Очень опасно!
    
    // И освободить память:
    operator delete(d);  // Освобождение без вызова деструктора
}
```

### 4. **Проблемы с множественным наследованием**
```cpp
class Base1 {
public:
    Base1() { cout << "Base1 constructor" << endl; }
    virtual ~Base1() { cout << "Base1 destructor" << endl; }
};

class Base2 {
public:
    Base2() { cout << "Base2 constructor" << endl; }
    virtual ~Base2() { cout << "Base2 destructor" << endl; }
};

class Derived : public Base1, public Base2 {
public:
    Derived() { cout << "Derived constructor" << endl; }
    ~Derived() override { cout << "Derived destructor" << endl; }
};

int main() {
    Base2* obj = new Derived();
    delete obj;  
    // Проблема: если Base2 не является первым базовым классом,
    // указатель может нуждаться в корректировке
    // Но с виртуальными деструкторами - всё работает
}
```

### 5. **Унаследованные конструкторы и деструкторы**
```cpp
class Base {
public:
    virtual ~Base() = default;
    Base() = default;
    Base(const Base&) { cout << "Base copy" << endl; }
};

class Derived : public Base {
    // Не определяем конструкторы - используем сгенерированные
};

int main() {
    Derived d1;
    Derived d2 = d1;  // Вызывается сгенерированный конструктор копирования
    // Он вызовет конструктор копирования Base
    // Деструкторы вызовутся правильно
}
```

## Специфические проблемы и их решения

### Проблема 1: **Деструкторы при исключениях**
```cpp
class Dangerous {
public:
    Dangerous() { 
        cout << "Dangerous constructor" << endl; 
        throw std::runtime_error("Oops!");  // Исключение в конструкторе
    }
    ~Dangerous() { 
        cout << "Dangerous destructor" << endl; 
    }
};

int main() {
    try {
        Dangerous d;  // Конструктор бросает исключение
        // Деструктор НЕ вызывается, т.к. объект не был полностью создан
    } catch (...) {
        cout << "Exception caught" << endl;
    }
}
```

### Проблема 2: **Чисто виртуальный деструктор**
```cpp
class AbstractBase {
public:
    virtual ~AbstractBase() = 0;  // Чисто виртуальный деструктор
};

AbstractBase::~AbstractBase() {  // ⚠️ Должен быть определен!
    cout << "AbstractBase destructor" << endl;
}

class Derived : public AbstractBase {
public:
    ~Derived() override { 
        cout << "Derived destructor" << endl; 
    }
};

int main() {
    AbstractBase* obj = new Derived();
    delete obj;  // ✅ Работает, если деструктор AbstractBase определен
}
```

### Проблема 3: **Деструкторы в виртуальном наследовании**
```cpp
class VirtualBase {
public:
    VirtualBase() { cout << "VirtualBase constructor" << endl; }
    virtual ~VirtualBase() { cout << "VirtualBase destructor" << endl; }
};

class Derived1 : virtual public VirtualBase {
public:
    Derived1() { cout << "Derived1 constructor" << endl; }
    ~Derived1() override { cout << "Derived1 destructor" << endl; }
};

class Derived2 : virtual public VirtualBase {
public:
    Derived2() { cout << "Derived2 constructor" << endl; }
    ~Derived2() override { cout << "Derived2 destructor" << endl; }
};

class Final : public Derived1, public Derived2 {
public:
    Final() { cout << "Final constructor" << endl; }
    ~Final() override { cout << "Final destructor" << endl; }
};

int main() {
    Final f;
    // Порядок вызова деструкторов:
    // 1. ~Final()
    // 2. ~Derived2()
    // 3. ~Derived1()
    // 4. ~VirtualBase()
}
```

## Правила безопасного использования

### Правило 1: **Виртуальный деструктор для полиморфных базовых классов**
```cpp
class Base {
public:
    virtual ~Base() = default;  // Всегда делайте деструктор виртуальным
    // если класс предназначен для полиморфного использования
};
```

### Правило 2: **Правило пяти (Rule of Five)**
```cpp
class ResourceHolder {
    int* data;
public:
    // Конструктор
    ResourceHolder(size_t size) : data(new int[size]) {}
    
    // 1. Деструктор
    ~ResourceHolder() { delete[] data; }
    
    // 2. Конструктор копирования
    ResourceHolder(const ResourceHolder& other) 
        : data(new int[/*размер*/]) {
        // копирование данных
    }
    
    // 3. Оператор присваивания копированием
    ResourceHolder& operator=(const ResourceHolder& other) {
        if (this != &other) {
            delete[] data;
            data = new int[/*размер*/];
            // копирование данных
        }
        return *this;
    }
    
    // 4. Конструктор перемещения
    ResourceHolder(ResourceHolder&& other) noexcept 
        : data(other.data) {
        other.data = nullptr;
    }
    
    // 5. Оператор присваивания перемещением
    ResourceHolder& operator=(ResourceHolder&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Правило 3: **Не вызывайте деструктор явно (за редкими исключениями)**
```cpp
// ❌ ПЛОХО
obj->~MyClass();

// ✅ ХОРОШО (только при использовании placement new)
void* memory = malloc(sizeof(MyClass));
MyClass* obj = new (memory) MyClass();  // Placement new
// ...
obj->~MyClass();  // Явный вызов допустим
free(memory);
```

### Правило 4: **Используйте умные указатели**
```cpp
class Base {
public:
    virtual ~Base() = default;
};

class Derived : public Base {
    std::vector<int> data;
};

int main() {
    // Автоматическое управление временем жизни
    std::unique_ptr<Base> obj = std::make_unique<Derived>();
    
    // При выходе из области видимости:
    // 1. Вызывается ~Derived()
    // 2. Вызывается ~Base()
    // 3. Память освобождается
    // Даже если произойдет исключение!
}
```

## Техники предотвращения проблем

### Техника 1: **final классы (C++11)**
```cpp
class NonInheritable final {
    // Не может иметь наследников
    // Деструктор может быть невиртуальным
};

// class Derived : public NonInheritable {};  // ❌ Ошибка
```

### Техника 2: **Защищенные деструкторы**
```cpp
class OnlyHeapAllocated {
protected:
    ~OnlyHeapAllocated() = default;  // Защищенный деструктор
public:
    void destroy() { delete this; }  // Управляемое удаление
};

// Автоматическое удаление через умный указатель с custom deleter
auto deleter = [](OnlyHeapAllocated* p) { p->destroy(); };
std::unique_ptr<OnlyHeapAllocated, decltype(deleter)> ptr(new OnlyHeapAllocated(), deleter);
```

### Техника 3: **Проверка на виртуальность деструктора**
```cpp
#include <type_traits>

template<typename Base>
void checkVirtualDestructor() {
    static_assert(
        std::has_virtual_destructor<Base>::value,
        "Base class must have virtual destructor!"
    );
}

class GoodBase {
public:
    virtual ~GoodBase() = default;
};

class BadBase {
public:
    ~BadBase() = default;
};

checkVirtualDestructor<GoodBase>();  // ✅ OK
// checkVirtualDestructor<BadBase>(); // ❌ Ошибка компиляции
```

## Таблица проблем и решений

| Проблема | Симптомы | Решение |
|----------|----------|---------|
| Невиртуальный деструктор | Утечка памяти при удалении через указатель на базовый класс | Сделать деструктор виртуальным |
| Явный вызов деструктора | Неопределенное поведение, двойное освобождение | Избегать явного вызова, использовать delete |
| Исключение в деструкторе | Неопределенное поведение, утечки ресурсов | Не бросать исключения в деструкторах |
| Множественное наследование | Неправильный порядок вызова деструкторов | Использовать виртуальные деструкторы |
| Виртуальное наследование | Деструктор виртуальной базы вызывается один раз | Конструктор самого производного класса инициализирует виртуальную базу |

## Золотые правила

1. **Для полиморфных базовых классов всегда объявляйте виртуальный деструктор**
2. **Если класс содержит виртуальные функции, у него должен быть виртуальный деструктор**
3. **Не вызывайте деструктор явно (кроме placement new)**
4. **Не бросайте исключения в деструкторах**
5. **Используйте умные указатели для автоматического управления временем жизни**
6. **Следуйте Правилу Пяти/Нуля при работе с ресурсами**
7. **При наследовании убедитесь, что все базовые классы имеют виртуальные деструкторы**

## Пример безопасной иерархии
```cpp
class Base {
public:
    virtual ~Base() = default;  // Виртуальный деструктор
    Base() = default;
    Base(const Base&) = default;
    Base(Base&&) = default;
    Base& operator=(const Base&) = default;
    Base& operator=(Base&&) = default;
};

class Derived : public Base {
private:
    std::unique_ptr<int[]> data;  // Умный указатель для ресурсов
    
public:
    Derived(size_t size) : data(std::make_unique<int[]>(size)) {}
    ~Derived() override = default;  // Деструктор по умолчанию
    
    // Правило нуля: нет необходимости в ручном управлении ресурсами
};
```