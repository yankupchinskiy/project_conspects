## Разрешение перегрузки шаблонных методов функций

Разрешение перегрузки шаблонных методов происходит в несколько этапов с учетом специализации шаблонов:

### Основные этапы разрешения перегрузки:

1. **Поиск кандидатов**
   - Все нешаблонные функции с подходящим именем
   - Все шаблонные функции, которые можно инстанцировать для данных аргументов

2. **Выбор жизнеспособных функций**
   - Функции с корректным количеством параметров
   - Функции, где аргументы могут быть преобразованы к типам параметров

3. **Ранжирование кандидатов** (в порядке предпочтения):

### Правила приоритета:

#### 1. **Нешаблонные функции имеют высший приоритет**
```cpp
void foo(int);        // #1
template<typename T>
void foo(T);          // #2

foo(42);              // Выбирается #1 (нешаблонная)
```

#### 2. **Более специализированные шаблонные функции предпочтительнее**
```cpp
template<typename T>
void bar(T);          // #3 - менее специализирована

template<typename T>
void bar(T*);         // #4 - более специализирована

int x = 5;
bar(&x);              // Выбирается #4
```

#### 3. **Явные специализации шаблонов**
```cpp
template<typename T>
void baz(T);          // #5 - основной шаблон

template<>
void baz<int>(int);   // #6 - явная специализация

baz(10);              // Выбирается #6
```

### Специфичные случаи:

#### **SFINAE (Substitution Failure Is Not An Error)**
```cpp
template<typename T>
typename T::type func(T);  // #7 - работает только для типов с ::type

template<typename T>
T func(T);                 // #8 - общий случай

func(42);                  // #7 отбрасывается по SFINAE, выбирается #8
```

#### **Перегрузка методов в классах**
```cpp
class MyClass {
public:
    template<typename T>
    void process(T x) { cout << "generic"; }      // #9
    
    template<>
    void process<int>(int x) { cout << "int"; }   // #10
    
    void process(double x) { cout << "double"; }  // #11
};

MyClass obj;
obj.process(5);     // Выбирается #10 (специализация шаблона)
obj.process(3.14);  // Выбирается #11 (нешаблонный метод)
```

#### **Variadic templates (с переменным числом аргументов)**
```cpp
template<typename T>
void print(T t) { cout << t; }                    // #12

template<typename T, typename... Args>
void print(T t, Args... args) {                   // #13
    cout << t;
    print(args...);
}

print(1, 2, 3);  // Выбирается #13 (более специфичный набор параметров)
```

### Алгоритм выбора в упрощенном виде:

1. Если есть **точное совпадение нешаблонной функции** → выбирается она
2. Иначе, если есть **явная специализация шаблона** для данных типов → выбирается она
3. Иначе, выбирается **наиболее специализированный шаблон** (по частичному порядку)
4. Иначе, выбирается **основной шаблон**
5. Если неоднозначность → ошибка компиляции

### Пример с частичным порядком:
```cpp
template<typename T>
void test(T) {}           // A: T

template<typename T>
void test(T*) {}          // B: T* - более специализирована

template<typename T>
void test(const T*) {}    // C: const T* - еще более специализирована

int* p;
const int* cp;

test(p);   // Выбирается B
test(cp);  // Выбирается C
```

**Важно**: Правила разрешения перегрузки шаблонов могут различаться между компиляторами и стандартами C++ (особенно в C++11, C++14, C++17, C++20 с концептами).