# Компиляция шаблонов (template instantiation) в C++

## Двухфазный процесс компиляции шаблонов

### Фаза 1: **Анализ определения шаблона** (Template Definition)
```cpp
template<typename T>
class Vector {
private:
    T* data;
    size_t size;
    
public:
    Vector(size_t n) : size(n), data(new T[n]) {}  // 1. Проверяется базовый синтаксис
    
    ~Vector() { delete[] data; }
    
    T& operator[](size_t index) {
        return data[index];  // 2. Независимые имена проверяются сейчас
    }
    
    void sort() {
        std::sort(data, data + size);  // 3. Зависимые имена - отложенная проверка
    }
};
```

### Фаза 2: **Инстанцирование шаблона** (Template Instantiation)
```cpp
int main() {
    Vector<int> intVec(10);   // 1. Компилятор генерирует Vector<int>
    Vector<double> dblVec(5); // 2. Компилятор генерирует Vector<double>
    
    // Для каждого типа создается отдельный экземпляр класса
}
```

## Подробный процесс компиляции

### Шаг 1: **Парсинг и создание AST**
```cpp
// Исходный код
template<typename T>
T max(T a, T b) {
    return a > b ? a : b;
}

// Компилятор создает AST для шаблона:
/*
FunctionTemplateDecl 'max'
├── TemplateTypeParmDecl 'T'
└── FunctionDecl 'max'
    ├── ParmVarDecl 'a' type 'T'
    ├── ParmVarDecl 'b' type 'T'
    └── CompoundStmt
        └── ReturnStmt
            └── ConditionalOperator
                ├── BinaryOperator '>'
                │   ├── DeclRefExpr 'a'
                │   └── DeclRefExpr 'b'
                ├── DeclRefExpr 'a'
                └── DeclRefExpr 'b'
*/
```

### Шаг 2: **Инстанцирование при использовании**
```cpp
// При первом использовании шаблона
int x = max(5, 10);  // T = int
double y = max(3.14, 2.71);  // T = double

// Компилятор генерирует:
int max_int(int a, int b) {  // Специализация для int
    return a > b ? a : b;
}

double max_double(double a, double b) {  // Специализация для double
    return a > b ? a : b;
}
```

## Типы инстанцирования шаблонов

### 1. **Неявное инстанцирование** (Implicit Instantiation)
```cpp
template<typename T>
class Stack {
private:
    T* elements;
    int top;
    
public:
    Stack(int size) : elements(new T[size]), top(-1) {}
    
    void push(T value) {
        elements[++top] = value;
    }
    
    T pop() {
        return elements[top--];
    }
};

int main() {
    Stack<int> intStack(10);    // Неявное инстанцирование Stack<int>
    Stack<std::string> strStack(5);  // Неявное инстанцирование Stack<string>
    
    // Компилятор генерирует код только для используемых методов
    intStack.push(42);  // Генерируется Stack<int>::push(int)
    intStack.pop();     // Генерируется Stack<int>::pop()
    // Stack<int>::Stack(int) уже сгенерирован при создании объекта
}
```

### 2. **Явное инстанцирование** (Explicit Instantiation)
```cpp
// mytemplate.h
template<typename T>
class MyClass {
public:
    void method1();
    void method2(T value);
};

// mytemplate.cpp
#include "mytemplate.h"

// Реализации методов
template<typename T>
void MyClass<T>::method1() { /* ... */ }

template<typename T>
void MyClass<T>::method2(T value) { /* ... */ }

// Явное инстанцирование для конкретных типов
template class MyClass<int>;     // Генерирует все методы для int
template class MyClass<double>;  // Генерирует все методы для double

// main.cpp
#include "mytemplate.h"

int main() {
    MyClass<int> obj1;    // Использует явно инстанцированную версию
    MyClass<double> obj2; // Использует явно инстанцированную версию
    // MyClass<float> obj3;  // Ошибка линковки: нет явного инстанцирования
}
```

### 3. **Специализация** (Specialization)
```cpp
// Первичный шаблон
template<typename T>
class Printer {
public:
    void print(const T& value) {
        std::cout << "Generic: " << value << std::endl;
    }
};

// Полная специализация для const char*
template<>
class Printer<const char*> {
public:
    void print(const char* value) {
        std::cout << "C-string: " << (value ? value : "(null)") << std::endl;
    }
};

// Частичная специализация для указателей
template<typename T>
class Printer<T*> {
public:
    void print(T* value) {
        std::cout << "Pointer: " << (value ? std::to_string(*value) : "nullptr") << std::endl;
    }
};

int main() {
    Printer<int> p1;           // Использует первичный шаблон
    p1.print(42);              // Generic: 42
    
    Printer<const char*> p2;   // Использует полную специализацию
    p2.print("Hello");         // C-string: Hello
    
    Printer<int*> p3;          // Использует частичную специализацию
    int x = 100;
    p3.print(&x);              // Pointer: 100
}
```

## Процесс компиляции шаблонных функций

### Двухфазный поиск имен (Two-Phase Name Lookup)
```cpp
#include <iostream>

void global_func() {
    std::cout << "Global function" << std::endl;
}

template<typename T>
class MyClass {
public:
    void method() {
        global_func();      // 1. Независимое имя - разрешается на 1 фазе
        dependent_func<T>(); // 2. Зависимое имя - разрешается на 2 фазе
        T::static_method();  // 3. Зависимое имя - разрешается на 2 фазе
    }
};

// Зависимая функция
template<typename T>
void dependent_func() {
    std::cout << "Dependent function" << std::endl;
}
```

### Инстанцирование шаблонных функций
```cpp
template<typename T>
T process(T value) {
    // Этот код компилируется только при инстанцировании
    return value * 2;  // Должен поддерживать operator*
}

template<typename Container>
void printContainer(const Container& cont) {
    // Требуется begin() и end()
    for (auto it = cont.begin(); it != cont.end(); ++it) {
        std::cout << *it << " ";
    }
}

int main() {
    // process<int> инстанцируется успешно
    int result = process(5);  // OK: int поддерживает operator*
    
    // process<std::string> не скомпилируется
    // std::string s = process(std::string("test"));  // Ошибка: нет operator*
    
    std::vector<int> vec = {1, 2, 3};
    printContainer(vec);  // OK: vector имеет begin() и end()
}
```

## Особенности компиляции шаблонов классов

### 1. **Ленивое инстанцирование** (Lazy Instantiation)
```cpp
template<typename T>
class Database {
private:
    T* connection;
    
public:
    Database() {
        // Этот код проверяется при инстанцировании конструктора
        connection = new T();
    }
    
    void connect() {
        connection->open();  // Требуется метод open()
    }
    
    // Этот метод никогда не инстанцируется, если не используется
    void advancedFeature() {
        connection->someAdvancedMethod();  // Даже если T не имеет этого метода
    }
};

class SimpleConnection {
public:
    void open() { std::cout << "Opened" << std::endl; }
    // Нет someAdvancedMethod()
};

int main() {
    Database<SimpleConnection> db;  // OK
    db.connect();  // OK
    
    // db.advancedFeature();  // Ошибка компиляции, только если вызвать
    // SimpleConnection не имеет someAdvancedMethod()
}
```

### 2. **Инстанцирование отдельных членов**
```cpp
template<typename T>
class Widget {
public:
    void method1() { /* использует T */ }
    void method2() { /* использует T */ }
    void method3() { /* требует специфичных для T операций */ }
};

class TypeA {
    // Имеет все необходимые операции
};

class TypeB {
    // Не имеет операций для method3
};

int main() {
    Widget<TypeA> wa;
    wa.method1();  // Инстанцируется только method1
    wa.method2();  // Инстанцируется method2
    wa.method3();  // Инстанцируется method3 - OK для TypeA
    
    Widget<TypeB> wb;
    wb.method1();  // Инстанцируется method1
    wb.method2();  // Инстанцируется method2
    // wb.method3();  // Не инстанцируется, т.к. не вызывается
    // Если бы вызвали - была бы ошибка компиляции
}
```

## Модели компиляции шаблонов

### 1. **Модель включения** (Inclusion Model) - стандартная
```cpp
// vector.h - ВСЁ в заголовочном файле
#ifndef VECTOR_H
#define VECTOR_H

#include <cstddef>

template<typename T>
class Vector {
private:
    T* data;
    size_t capacity;
    size_t size;
    
public:
    Vector(size_t initial_capacity = 10);
    ~Vector();
    
    void push_back(const T& value);
    T& operator[](size_t index);
    // ...
};

// Определения методов ТОЖЕ в заголовке
template<typename T>
Vector<T>::Vector(size_t initial_capacity) 
    : data(new T[initial_capacity]), capacity(initial_capacity), size(0) {}

template<typename T>
void Vector<T>::push_back(const T& value) {
    if (size >= capacity) {
        // Реаллокация
    }
    data[size++] = value;
}

#endif // VECTOR_H
```

### 2. **Модель разделения** (Separation Model) - с `export` (устарело)
```cpp
// C++98/03 поддерживало export, но больше нет
// vector.h
export template<typename T>  // Ключевое слово export
class Vector {
public:
    void push_back(const T& value);
};

// vector.cpp
#include "vector.h"

template<typename T>
void Vector<T>::push_back(const T& value) {
    // Реализация
}
// Это НЕ работает в современных компиляторах!
```

### 3. **Явное инстанцирование с разделением**
```cpp
// vector.h - только объявление
template<typename T>
class Vector {
private:
    T* data;
    size_t size;
    
public:
    Vector();
    ~Vector();
    void push_back(const T& value);
};

// vector.cpp - реализация
template<typename T>
Vector<T>::Vector() : data(nullptr), size(0) {}

template<typename T>
Vector<T>::~Vector() {
    delete[] data;
}

template<typename T>
void Vector<T>::push_back(const T& value) {
    // Реализация
}

// Явное инстанцирование часто используемых типов
template class Vector<int>;
template class Vector<double>;
template class Vector<std::string>;
```

## Оптимизации компиляции шаблонов

### 1. **Мемоизация инстанцирований** (Memoization)
```cpp
// Компилятор кэширует инстанцированные шаблоны
template<typename T>
T add(T a, T b) { return a + b; }

// В разных единицах трансляции
// file1.cpp
int sum1 = add(1, 2);  // Компилятор генерирует add<int>

// file2.cpp  
int sum2 = add(3, 4);  // Если в той же программе, может использоваться
                       // уже сгенерированный add<int>
```

### 2. **Инлайн-инстанцирование**
```cpp
template<typename T>
inline T min(T a, T b) {  // inline подсказывает компилятору
    return a < b ? a : b;
}

// Компилятор может встроить код при инстанцировании
int result = min(5, 10);
// Может быть развернуто в: int result = 5 < 10 ? 5 : 10;
```

## Процесс линковки шаблонов

### Проблема: **Множественные инстанцирования**
```cpp
// utils.h
template<typename T>
T square(T x) {
    return x * x;
}

// a.cpp
#include "utils.h"
int a = square(5);  // Генерирует square<int> в a.obj

// b.cpp
#include "utils.h"  
int b = square(5);  // Генерирует square<int> в b.obj

// При линковке: две копии square<int>!
// Компилятор/линковщик должен выбрать одну (ODR - One Definition Rule)
```

### Решение: **COMDAT секции**
```cpp
// Современные компиляторы помещают шаблоны в COMDAT секции
// .obj файл (a.obj):
// COMDAT section for square<int>:
// square_int:
//     mov eax, [esp+4]
//     imul eax, eax
//     ret

// Линковщик удаляет дубликаты COMDAT секций
```

## SFINAE и компиляция

### Substitution Failure Is Not An Error
```cpp
#include <type_traits>

// Шаблон 1
template<typename T, typename = std::enable_if_t<std::is_integral<T>::value>>
void process(T value) {
    std::cout << "Integral: " << value << std::endl;
}

// Шаблон 2  
template<typename T, typename = std::enable_if_t<std::is_floating_point<T>::value>>
void process(T value) {
    std::cout << "Floating: " << value << std::endl;
}

int main() {
    process(42);      // Выбирает шаблон 1 (SFINAE для шаблона 2)
    process(3.14);    // Выбирает шаблон 2 (SFINAE для шаблона 1)
    // process("hello"); // Ошибка: нет подходящего шаблона
}
```

## Время компиляции шаблонов

### Измерение времени компиляции
```cpp
// Шаблонные метапрограммы вычисляются во время компиляции
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

// Вычисляется компилятором!
int x = Factorial<5>::value;  // 120

// Современные constexpr
template<typename T, int N>
constexpr T power(T base) {
    T result = 1;
    for (int i = 0; i < N; ++i) {
        result *= base;
    }
    return result;
}

// Вычисляется во время компиляции (если аргументы известны)
const int result = power<int, 5>(2);  // 32
```

## Проблемы и решения

### Проблема 1: **Длинное время компиляции**
```cpp
// Большие шаблоны замедляют компиляцию
template<typename T1, typename T2, typename T3, typename T4, typename T5>
class ComplexTemplate {
    // Много кода...
};

// Решение: Предварительные объявления и явное инстанцирование
extern template class ComplexTemplate<int, double, float, char, bool>;
```

### Проблема 2: **Раздувание кода** (Code Bloat)
```cpp
// Каждая специализация добавляет код
template<typename T, int Size>
class Array {
    T data[Size];
    // Одинаковый код для всех типов...
};

Array<int, 10> a1;
Array<int, 20> a2;     // Другая специализация
Array<double, 10> a3;  // Третья специализация

// Решение: Вынос общей логики в базовый класс
template<typename T>
class ArrayBase {
protected:
    // Общая логика без размера
};

template<typename T, int Size>
class Array : private ArrayBase<T> {
    T data[Size];
    // Использует ArrayBase<T>
};
```

### Проблема 3: **Ошибки компиляции**
```cpp
template<typename Container>
void sortContainer(Container& c) {
    std::sort(c.begin(), c.end());  // Требует random-access итераторы
}

std::list<int> lst;
// sortContainer(lst);  // Ошибка: list не имеет random-access итераторов
                        // Ошибка появляется глубоко в std::sort

// Решение: Концепты (C++20)
template<std::random_access_iterator Iter>
void betterSort(Iter first, Iter last) {
    std::sort(first, last);  // Ошибка на уровне объявления
}
```

## Таблица этапов компиляции

| Этап | Что происходит | Пример |
|------|----------------|---------|
| **Парсинг** | Построение AST для шаблона | `template<typename T> class X;` |
| **Проверка независимых имен** | Проверка синтаксиса, не зависящего от T | `int x = 5;` в шаблоне |
| **Инстанцирование** | Генерация кода для конкретных типов | `X<int> x;` |
| **Проверка зависимых имен** | Проверка кода с подставленным типом | `T::method()` проверяется для `int::method()` |
| **Генерация кода** | Создание машинного кода | Генерация функций и данных |
| **Оптимизация** | Встраивание, удаление мертвого кода | Встраивание простых методов |
| **Линковка** | Объединение инстанцирований из разных единиц трансляции | Удаление дубликатов `vector<int>` |

## Современные особенности (C++17/20)

### Вывод типа шаблона класса (CTAD)
```cpp
template<typename T>
class Vector {
public:
    Vector(std::initializer_list<T> list) {}
};

// C++17: Автоматический вывод типа
Vector v{1, 2, 3};  // Vector<int>, без явного указания типа

// Руководства по выводу (deduction guides)
template<typename Iter>
Vector(Iter, Iter) -> Vector<typename std::iterator_traits<Iter>::value_type>;
```

### Шаблонные параметры `auto` (C++20)
```cpp
template<auto Value>  // Значение любого типа
struct Constant {
    static constexpr auto value = Value;
};

Constant<42> c1;      // int
Constant<'A'> c2;     // char
Constant<3.14> c3;    // double
```

## Заключение

**Ключевые моменты компиляции шаблонов:**

1. **Двухфазная компиляция**: проверка независимых имен сразу, зависимых - при инстанцировании
2. **Ленивое инстанцирование**: код генерируется только для используемых методов
3. **Инстанцирование по требованию**: при первом использовании с конкретными типами
4. **ODR для шаблонов**: одно определение на программу, дубликаты удаляются линковщиком
5. **SFINAE**: ошибки подстановки в шаблонах - не ошибки компиляции

**Оптимизации:**
- Кэширование инстанцирований
- COMDAT секции для удаления дубликатов
- Встраивание простых шаблонных функций
- Вычисление на этапе компиляции (constexpr, метапрограммирование)

**Лучшие практики:**
- Размещайте определения шаблонов в заголовочных файлах
- Используйте явное инстанцирование для уменьшения времени компиляции
- Применяйте разделение через базовые классы для избежания раздувания кода
- Используйте концепты (C++20) для лучших сообщений об ошибках