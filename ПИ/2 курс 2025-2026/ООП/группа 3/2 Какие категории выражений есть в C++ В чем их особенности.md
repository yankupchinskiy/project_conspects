# Категории выражений (Value Categories) в C++

Категории выражений определяют, как можно использовать результат выражения. Это фундаментальная концепция C++, которая особенно важна для понимания семантики перемещения и перегрузки функций.

## Основные категории (до C++11)

### 1. **lvalue** (left value)
Выражение, которое представляет объект с определенным местом в памяти.

**Характеристики:**
- Имеет адрес, который можно получить с помощью `&`
- Может находиться слева от оператора присваивания
- Обычно имеет имя
- Время жизни не ограничено текущим выражением

**Примеры:**
```cpp
int x = 5;      // x - lvalue
x = 10;         // OK: x может быть слева от =

int* p = &x;    // OK: можно взять адрес

int arr[10];
arr[3] = 7;     // arr[3] - lvalue

int& ref = x;   // ref - lvalue
ref = 20;       // OK

std::string s = "hello";
s[0] = 'H';     // s[0] - lvalue
```

### 2. **rvalue** (right value)
Временное значение, которое не сохраняется за пределами выражения.

**Характеристики:**
- Не имеет адреса (нельзя применить `&`)
- Может находиться только справа от присваивания
- Обычно анонимное
- Время жизни ограничено текущим выражением

**Примеры:**
```cpp
int x = 5;      // 5 - rvalue
x = 2 + 3;      // (2 + 3) - rvalue

int y = x + 1;  // (x + 1) - rvalue

int func();     // func() - rvalue (если возвращает по значению)
y = func();

std::string s = "hello" + std::string(" world");
// "hello" - rvalue
// std::string(" world") - rvalue
```

## Расширенные категории (C++11 и далее)

C++11 ввел более точную классификацию, разделив rvalue на две подкатегории:

### 3. **prvalue** (pure rvalue)
"Чистое" временное значение, которое не имеет идентичности.

**Характеристики:**
- Не имеет адреса
- Не может быть модифицировано (если не считать временный материализации)
- Используется для инициализации

**Примеры:**
```cpp
42;                     // литерал
x + y;                  // результат операции
func();                 // функция, возвращающая по значению
std::string("temp");    // временный объект
```

### 4. **xvalue** (expiring value)
"Умирающее" значение - объект, ресурсы которого могут быть перемещены.

**Характеристики:**
- Имеет идентичность (адрес)
- Но может быть "опустошено" (перемещено)
- Может быть привязано к rvalue-ссылке

**Примеры:**
```cpp
std::string s1 = "hello";
std::string s2 = std::move(s1);  // std::move(s1) - xvalue

int&& func();                    // возвращает xvalue
auto&& r = func();               // r - ссылка на xvalue

std::vector<int> v = {1, 2, 3};
int x = v.back();                // v.back() - lvalue
int y = std::move(v.back());     // std::move(v.back()) - xvalue
```

### 5. **glvalue** (generalized lvalue)
Обобщенные lvalue - включают как lvalue, так и xvalue.

**Характеристики:**
- Имеет идентичность
- Может быть полиморфным (виртуальные функции)

## Иерархия категорий

```
     expression
      /      \
   glvalue  rvalue
   /    \    /    \
lvalue  xvalue   prvalue
```

**Простая мнемоника:**
- **lvalue**: имеет имя, адрес, долгоживущее
- **xvalue**: имеет имя, но "умирает" (перемещается)
- **prvalue**: не имеет имени, временное

## Особенности каждой категории

### Для **lvalue**:
```cpp
int x = 5;
int& lref1 = x;          // OK
int& lref2 = 10;         // ОШИБКА: нельзя привязать lvalue-ссылку к rvalue
const int& clref = 10;   // OK: const lvalue-ссылка может связываться с rvalue
```

### Для **xvalue**:
```cpp
int x = 5;
int&& rref1 = std::move(x);  // OK: rvalue-ссылка связывается с xvalue
int&& rref2 = x;             // ОШИБКА: нельзя привязать rvalue-ссылку к lvalue
```

### Для **prvalue**:
```cpp
int&& rref = 10;        // OK: prvalue связывается с rvalue-ссылкой
int& lref = 10;         // ОШИБКА
const int& clref = 10;  // OK: продлевает время жизни временного объекта
```

## Практическое применение

### 1. **Перегрузка функций**
```cpp
void process(int& x) {
    std::cout << "lvalue: " << x << std::endl;
}

void process(int&& x) {
    std::cout << "rvalue: " << x << std::endl;
}

int main() {
    int a = 5;
    process(a);           // вызывает первую версию (lvalue)
    process(10);          // вызывает вторую версию (rvalue)
    process(std::move(a)); // вызывает вторую версию (xvalue)
}
```

### 2. **Конструкторы и операторы присваивания**
```cpp
class String {
    char* data;
public:
    // Конструктор копирования (принимает lvalue)
    String(const String& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
    
    // Конструктор перемещения (принимает rvalue)
    String(String&& other) noexcept {
        data = other.data;    // перемещаем ресурс
        other.data = nullptr; // обнуляем у источника
    }
    
    // Оператор присваивания с перемещением
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### 3. **Шаблоны и perfect forwarding**
```cpp
template<typename T>
void wrapper(T&& arg) {  // универсальная ссылка
    // Perfect forwarding
    process(std::forward<T>(arg));
}

int x = 5;
wrapper(x);              // T = int&,  arg = int&  (lvalue)
wrapper(10);             // T = int,   arg = int&& (rvalue)
wrapper(std::move(x));   // T = int&&, arg = int&& (xvalue)
```

### 4. **Ссылочные квалификаторы для методов**
```cpp
class Widget {
public:
    void process() & {   // вызывается только для lvalue-объектов
        std::cout << "processing lvalue widget" << std::endl;
    }
    
    void process() && {  // вызывается только для rvalue-объектов
        std::cout << "processing rvalue widget" << std::endl;
    }
};

Widget w;
w.process();            // lvalue версия
Widget().process();     // rvalue версия
std::move(w).process(); // rvalue версия
```

## Правила преобразований

### 1. **Временная материализация (temporary materialization)**
prvalue преобразуется в xvalue при необходимости:
```cpp
int x = 5;
int&& r = x + 1;  // (x + 1) - prvalue материализуется во временный объект (xvalue)
```

### 2. **Lvalue-to-rvalue преобразование**
```cpp
int x = 5;
int y = x;  // x (lvalue) преобразуется в rvalue для инициализации y
```

### 3. **Array-to-pointer decay**
```cpp
int arr[10];
int* p = arr;  // arr (lvalue массива) преобразуется в rvalue-указатель
```

## Определение категории выражения

### Использование `decltype`
```cpp
int x = 5;
int& r = x;
int&& rr = 10;

decltype((x))  a = x;   // int&   (lvalue)
decltype((5))  b = 5;   // int&&  (prvalue)
decltype((r))  c = x;   // int&   (lvalue)
decltype((rr)) d = 10;  // int&&  (xvalue)
```

### Шаблон для определения категории
```cpp
#include <iostream>
#include <type_traits>

template<typename T>
void print_category(T&&) {
    if constexpr (std::is_lvalue_reference_v<T>) {
        std::cout << "lvalue" << std::endl;
    } else if constexpr (std::is_rvalue_reference_v<T>) {
        std::cout << "rvalue (xvalue или prvalue)" << std::endl;
    } else {
        std::cout << "prvalue" << std::endl;
    }
}
```

## Важные исключения и особенности

### 1. **Строковые литералы**
```cpp
"hello";  // lvalue (имеет статическую память), тип const char[6]
```

### 2. **Имена функций**
```cpp
void func();
func;  // lvalue (у функции есть адрес)
```

### 3. **Встроенные операторы**
```cpp
int x = 5;
++x;    // lvalue (возвращает измененный x)
x++;    // prvalue (возвращает старое значение)
(x);    // lvalue (скобки не меняют категорию)
```

### 4. **Тернарный оператор**
```cpp
int a = 1, b = 2;
(a < b ? a : b) = 3;  // OK: если оба операнда lvalue, результат - lvalue
// (a < b ? a : 5) = 3;  // ОШИБКА: если один операнд rvalue, результат - rvalue
```

## Заключение

Понимание категорий выражений критически важно для:
1. Правильной работы с семантикой перемещения
2. Оптимизации производительности
3. Написания шаблонов с perfect forwarding
4. Создания эффективных и безопасных классов

**Золотое правило:** lvalue = имеет имя/адрес, rvalue = временное, xvalue = "умирающее" lvalue, которое можно переместить.