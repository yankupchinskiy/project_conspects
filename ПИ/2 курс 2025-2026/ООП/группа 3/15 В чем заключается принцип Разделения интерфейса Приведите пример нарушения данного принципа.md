# Принцип разделения интерфейса (Interface Segregation Principle - ISP)

## Что такое ISP?

**ISP** — четвертый принцип SOLID, который гласит: *"Клиенты не должны зависеть от интерфейсов, которые они не используют"*. Это означает, что большие "толстые" интерфейсы нужно разбивать на маленькие, специфические интерфейсы, чтобы клиенты реализовывали только то, что им действительно нужно.

## Примеры нарушения ISP

### Пример 1: **"Божественный интерфейс" устройства**
```cpp
// ❌ НАРУШЕНИЕ ISP: Один интерфейс на все случаи жизни
class IMultiFunctionDevice {
public:
    // Принтерные методы
    virtual void print(const Document& doc) = 0;
    virtual void scan(const Document& doc) = 0;
    virtual void copy(const Document& doc) = 0;
    
    // Факсовые методы
    virtual void fax(const Document& doc) = 0;
    virtual void receiveFax() = 0;
    
    // Сетевые методы
    virtual void connectToNetwork() = 0;
    virtual void sendEmail(const std::string& to, const std::string& subject) = 0;
    
    // Административные методы
    virtual void showInkLevels() = 0;
    virtual void showPaperStatus() = 0;
    virtual void calibrate() = 0;
    
    virtual ~IMultiFunctionDevice() = default;
};

// Простой принтер вынужден реализовывать ВСЕ методы
class SimplePrinter : public IMultiFunctionDevice {
public:
    void print(const Document& doc) override {
        std::cout << "Printing document..." << std::endl;
    }
    
    // ⚠️ Простой принтер не может сканировать!
    void scan(const Document& doc) override {
        throw std::runtime_error("This printer cannot scan!");
    }
    
    // ⚠️ Простой принтер не может копировать!
    void copy(const Document& doc) override {
        throw std::runtime_error("This printer cannot copy!");
    }
    
    // ⚠️ Простой принтер не может отправлять факсы!
    void fax(const Document& doc) override {
        throw std::runtime_error("This printer cannot fax!");
    }
    
    void receiveFax() override {
        throw std::runtime_error("This printer cannot receive fax!");
    }
    
    void connectToNetwork() override {
        throw std::runtime_error("This printer is not network capable!");
    }
    
    void sendEmail(const std::string& to, const std::string& subject) override {
        throw std::runtime_error("This printer cannot send email!");
    }
    
    void showInkLevels() override {
        std::cout << "Cyan: 60%, Magenta: 45%, Yellow: 70%, Black: 30%" << std::endl;
    }
    
    void showPaperStatus() override {
        std::cout << "Paper: 80 sheets remaining" << std::endl;
    }
    
    void calibrate() override {
        std::cout << "Calibrating printer..." << std::endl;
    }
};

// Использование
void printReport(IMultiFunctionDevice& device) {
    Document report;
    device.print(report);
    
    // Проблема: даже для простой печати мы должны иметь устройство
    // со ВСЕМИ возможностями, даже если они не используются!
}

int main() {
    SimplePrinter printer;
    
    // ❌ Клиент вынужден зависеть от интерфейса с ненужными методами
    printReport(printer);
    
    // Попытка использовать другие методы приведет к исключениям
    try {
        printer.scan(Document());
    } catch (const std::exception& e) {
        std::cout << "Error: " << e.what() << std::endl;
    }
}
```

### Пример 2: **Работник с множеством обязанностей**
```cpp
// ❌ НАРУШЕНИЕ ISP: Один интерфейс для всех типов работников
class IWorker {
public:
    // Программистские методы
    virtual void writeCode() = 0;
    virtual void debugCode() = 0;
    virtual void attendScrumMeeting() = 0;
    
    // Менеджерские методы
    virtual void manageTeam() = 0;
    virtual void conductInterview() = 0;
    virtual void createReports() = 0;
    
    // Тестировщики методы
    virtual void writeTests() = 0;
    virtual void executeTests() = 0;
    virtual void reportBugs() = 0;
    
    // Секретарские методы
    virtual void answerCalls() = 0;
    virtual void scheduleMeetings() = 0;
    virtual void handleCorrespondence() = 0;
    
    // Уборщик методы
    virtual void cleanOffice() = 0;
    virtual void disposeTrash() = 0;
    
    virtual ~IWorker() = default;
};

// Программист вынужден реализовывать ненужные ему методы
class Programmer : public IWorker {
public:
    void writeCode() override {
        std::cout << "Writing beautiful code..." << std::endl;
    }
    
    void debugCode() override {
        std::cout << "Debugging... found it! Off-by-one error." << std::endl;
    }
    
    void attendScrumMeeting() override {
        std::cout << "Attending daily scrum..." << std::endl;
    }
    
    // ❌ Программист не должен управлять командой
    void manageTeam() override {
        throw std::runtime_error("I'm not a manager!");
    }
    
    // ❌ Программист не должен проводить интервью
    void conductInterview() override {
        throw std::runtime_error("I'm not HR!");
    }
    
    // ❌ Программист не должен создавать отчеты (ну, почти)
    void createReports() override {
        throw std::runtime_error("I hate paperwork!");
    }
    
    // ❌ Программист не пишет тесты (в этой компании)
    void writeTests() override {
        throw std::runtime_error("We have QA for that!");
    }
    
    void executeTests() override {
        throw std::runtime_error("Not my job!");
    }
    
    void reportBugs() override {
        throw std::runtime_error("QA's responsibility!");
    }
    
    // ❌ Программист не секретарь
    void answerCalls() override {
        throw std::runtime_error("I'm busy coding!");
    }
    
    void scheduleMeetings() override {
        throw std::runtime_error("Use the calendar app!");
    }
    
    void handleCorrespondence() override {
        throw std::runtime_error("Email is for managers!");
    }
    
    // ❌ Программист не уборщик
    void cleanOffice() override {
        throw std::runtime_error("Call the janitor!");
    }
    
    void disposeTrash() override {
        throw std::runtime_error("We have cleaning staff!");
    }
};

// Использование
void codeSomething(IWorker& worker) {
    worker.writeCode();
    worker.debugCode();
    
    // Проблема: чтобы заставить программиста писать код,
    // мы должны передать объект со 100+ методами, большинство из которых
    // выбрасывают исключения!
}
```

### Пример 3: **Интерфейс банковской операции**
```cpp
// ❌ НАРУШЕНИЕ ISP: Один интерфейс для всех банковских операций
class IBankingOperations {
public:
    // Базовые операции
    virtual void deposit(double amount) = 0;
    virtual void withdraw(double amount) = 0;
    virtual double checkBalance() = 0;
    
    // Кредитные операции
    virtual void applyForLoan(double amount) = 0;
    virtual void repayLoan(double amount) = 0;
    virtual double getLoanBalance() = 0;
    
    // Инвестиционные операции
    virtual void buyStock(const std::string& symbol, int quantity) = 0;
    virtual void sellStock(const std::string& symbol, int quantity) = 0;
    virtual void checkPortfolio() = 0;
    
    // Ипотечные операции
    virtual void applyForMortgage(double propertyValue) = 0;
    virtual void makeMortgagePayment(double amount) = 0;
    virtual double getMortgageBalance() = 0;
    
    // Страховые операции
    virtual void buyInsurance(const std::string& type, double coverage) = 0;
    virtual void fileInsuranceClaim(const std::string& claimDetails) = 0;
    virtual void checkInsurancePolicies() = 0;
    
    // Международные операции
    virtual void sendInternationalTransfer(const std::string& country, 
                                          double amount) = 0;
    virtual void receiveInternationalTransfer(const std::string& fromCountry,
                                            double amount) = 0;
    virtual double getExchangeRate(const std::string& currency) = 0;
    
    virtual ~IBankingOperations() = default;
};

// Простой сберегательный счет
class SavingsAccount : public IBankingOperations {
private:
    double balance = 0;
    
public:
    void deposit(double amount) override {
        balance += amount;
    }
    
    void withdraw(double amount) override {
        if (amount <= balance) {
            balance -= amount;
        }
    }
    
    double checkBalance() override {
        return balance;
    }
    
    // ❌ Сберегательный счет не поддерживает кредиты
    void applyForLoan(double amount) override {
        throw std::runtime_error("Savings account cannot apply for loans!");
    }
    
    void repayLoan(double amount) override {
        throw std::runtime_error("No loans on this account!");
    }
    
    double getLoanBalance() override {
        throw std::runtime_error("No loan balance available!");
    }
    
    // ❌ Сберегательный счет не для инвестиций
    void buyStock(const std::string& symbol, int quantity) override {
        throw std::runtime_error("Cannot buy stocks from savings account!");
    }
    
    // ... и так далее для всех остальных методов
    // Всего 20 методов, из которых нужно реализовать только 3!
};
```

### Пример 4: **Интерфейс графического элемента UI**
```cpp
// ❌ НАРУШЕНИЕ ISP: Один интерфейс для всех UI элементов
class IUIControl {
public:
    // Методы для кнопок
    virtual void click() = 0;
    virtual void doubleClick() = 0;
    
    // Методы для текстовых полей
    virtual void setText(const std::string& text) = 0;
    virtual std::string getText() const = 0;
    
    // Методы для чекбоксов/радиокнопок
    virtual void setChecked(bool checked) = 0;
    virtual bool isChecked() const = 0;
    
    // Методы для слайдеров
    virtual void setValue(int value) = 0;
    virtual int getValue() const = 0;
    virtual void setRange(int min, int max) = 0;
    
    // Методы для выпадающих списков
    virtual void addItem(const std::string& item) = 0;
    virtual void removeItem(int index) = 0;
    virtual std::vector<std::string> getItems() const = 0;
    
    // Методы для отображения
    virtual void render() = 0;
    virtual void setPosition(int x, int y) = 0;
    virtual void setSize(int width, int height) = 0;
    
    // Методы для стилизации
    virtual void setColor(const std::string& color) = 0;
    virtual void setFont(const std::string& font) = 0;
    virtual void setBorder(bool hasBorder) = 0;
    
    virtual ~IUIControl() = default;
};

// Простая кнопка
class Button : public IUIControl {
private:
    std::string text;
    int x, y, width, height;
    
public:
    void click() override {
        std::cout << "Button clicked!" << std::endl;
    }
    
    void doubleClick() override {
        std::cout << "Button double-clicked!" << std::endl;
    }
    
    // ❌ Кнопка не имеет текста для get/set?
    void setText(const std::string& t) override {
        text = t;
    }
    
    std::string getText() const override {
        return text;
    }
    
    // ❌ Кнопка не может быть "отмечена"
    void setChecked(bool checked) override {
        throw std::runtime_error("Button cannot be checked!");
    }
    
    bool isChecked() const override {
        throw std::runtime_error("Button cannot be checked!");
    }
    
    // ❌ Кнопка не имеет значения для set/get
    void setValue(int value) override {
        throw std::runtime_error("Button doesn't have a value!");
    }
    
    int getValue() const override {
        throw std::runtime_error("Button doesn't have a value!");
    }
    
    void setRange(int min, int max) override {
        throw std::runtime_error("Button doesn't have a range!");
    }
    
    // ❌ Кнопка не имеет элементов списка
    void addItem(const std::string& item) override {
        throw std::runtime_error("Button cannot have items!");
    }
    
    // ... и так далее для остальных 10+ методов!
};
```

## Как соблюдать ISP?

### Решение 1: **Разделение на специализированные интерфейсы**
```cpp
// ✅ СОБЛЮДЕНИЕ ISP: Разделяем большой интерфейс на маленькие

// Интерфейс для печати
class IPrinter {
public:
    virtual void print(const Document& doc) = 0;
    virtual ~IPrinter() = default;
};

// Интерфейс для сканирования
class IScanner {
public:
    virtual void scan(const Document& doc) = 0;
    virtual ~IScanner() = default;
};

// Интерфейс для копирования
class ICopier {
public:
    virtual void copy(const Document& doc) = 0;
    virtual ~ICopier() = default;
};

// Интерфейс для факса
class IFaxMachine {
public:
    virtual void fax(const Document& doc) = 0;
    virtual void receiveFax() = 0;
    virtual ~IFaxMachine() = default;
};

// Теперь классы реализуют только то, что им нужно

// Простой принтер
class SimplePrinter : public IPrinter {
public:
    void print(const Document& doc) override {
        std::cout << "Printing document..." << std::endl;
    }
    // ✅ Не нужно реализовывать scan(), copy(), fax() и т.д.
};

// Многофункциональное устройство
class MultiFunctionDevice : public IPrinter, public IScanner, public ICopier, public IFaxMachine {
public:
    void print(const Document& doc) override {
        std::cout << "Printing..." << std::endl;
    }
    
    void scan(const Document& doc) override {
        std::cout << "Scanning..." << std::endl;
    }
    
    void copy(const Document& doc) override {
        std::cout << "Copying..." << std::endl;
    }
    
    void fax(const Document& doc) override {
        std::cout << "Sending fax..." << std::endl;
    }
    
    void receiveFax() override {
        std::cout << "Receiving fax..." << std::endl;
    }
};

// Клиенты зависят только от нужных интерфейсов
void printReport(IPrinter& printer) {
    Document report;
    printer.print(report);  // ✅ Клиент зависит только от IPrinter
}

void scanDocument(IScanner& scanner) {
    Document doc;
    scanner.scan(doc);  // ✅ Клиент зависит только от IScanner
}
```

### Решение 2: **Интерфейсы для конкретных ролей**
```cpp
// ✅ СОБЛЮДЕНИЕ ISP: Специализированные интерфейсы для ролей

// Программист
class IProgrammer {
public:
    virtual void writeCode() = 0;
    virtual void debugCode() = 0;
    virtual void attendScrumMeeting() = 0;
    virtual ~IProgrammer() = default;
};

// Менеджер
class IManager {
public:
    virtual void manageTeam() = 0;
    virtual void conductInterview() = 0;
    virtual void createReports() = 0;
    virtual ~IManager() = default;
};

// Тестировщик
class IQATester {
public:
    virtual void writeTests() = 0;
    virtual void executeTests() = 0;
    virtual void reportBugs() = 0;
    virtual ~IQATester() = default;
};

// Человек может реализовать несколько ролей
class SeniorDeveloper : public IProgrammer, public IManager {
public:
    void writeCode() override {
        std::cout << "Writing complex code..." << std::endl;
    }
    
    void debugCode() override {
        std::cout << "Debugging production issues..." << std::endl;
    }
    
    void attendScrumMeeting() override {
        std::cout << "Leading daily scrum..." << std::endl;
    }
    
    void manageTeam() override {
        std::cout << "Managing junior developers..." << std::endl;
    }
    
    void conductInterview() override {
        std::cout << "Interviewing candidates..." << std::endl;
    }
    
    void createReports() override {
        std::cout << "Creating sprint reports..." << std::endl;
    }
};

// Junior разработчик только программирует
class JuniorDeveloper : public IProgrammer {
public:
    void writeCode() override {
        std::cout << "Writing simple code..." << std::endl;
    }
    
    void debugCode() override {
        std::cout << "Debugging simple issues..." << std::endl;
    }
    
    void attendScrumMeeting() override {
        std::cout << "Listening to scrum..." << std::endl;
    }
    // ✅ Не нужно реализовывать методы менеджера
};
```

### Решение 3: **Композиция интерфейсов**
```cpp
// ✅ СОБЛЮДЕНИЕ ISP: Создаем базовые интерфейсы и комбинируем их

// Базовые банковские операции
class IDepositable {
public:
    virtual void deposit(double amount) = 0;
    virtual ~IDepositable() = default;
};

class IWithdrawable {
public:
    virtual void withdraw(double amount) = 0;
    virtual ~IWithdrawable() = default;
};

class IBalanceCheckable {
public:
    virtual double checkBalance() = 0;
    virtual ~IBalanceCheckable() = default;
};

// Специализированные интерфейсы
class ILoanOperations {
public:
    virtual void applyForLoan(double amount) = 0;
    virtual void repayLoan(double amount) = 0;
    virtual double getLoanBalance() = 0;
    virtual ~ILoanOperations() = default;
};

class IInvestmentOperations {
public:
    virtual void buyStock(const std::string& symbol, int quantity) = 0;
    virtual void sellStock(const std::string& symbol, int quantity) = 0;
    virtual void checkPortfolio() = 0;
    virtual ~IInvestmentOperations() = default;
};

// Сберегательный счет
class SavingsAccount : public IDepositable, 
                       public IWithdrawable, 
                       public IBalanceCheckable {
private:
    double balance = 0;
    
public:
    void deposit(double amount) override {
        balance += amount;
    }
    
    void withdraw(double amount) override {
        if (amount <= balance) {
            balance -= amount;
        }
    }
    
    double checkBalance() override {
        return balance;
    }
    // ✅ Реализованы только нужные методы
};

// Инвестиционный счет
class InvestmentAccount : public IDepositable,
                          public IWithdrawable,
                          public IBalanceCheckable,
                          public IInvestmentOperations {
private:
    double balance = 0;
    std::map<std::string, int> portfolio;
    
public:
    void deposit(double amount) override {
        balance += amount;
    }
    
    void withdraw(double amount) override {
        if (amount <= balance) {
            balance -= amount;
        }
    }
    
    double checkBalance() override {
        return balance;
    }
    
    void buyStock(const std::string& symbol, int quantity) override {
        portfolio[symbol] += quantity;
        balance -= quantity * 100;  // Упрощенная логика
    }
    
    void sellStock(const std::string& symbol, int quantity) override {
        if (portfolio[symbol] >= quantity) {
            portfolio[symbol] -= quantity;
            balance += quantity * 100;
        }
    }
    
    void checkPortfolio() override {
        for (const auto& [symbol, qty] : portfolio) {
            std::cout << symbol << ": " << qty << " shares" << std::endl;
        }
    }
};
```

### Решение 4: **Адаптеры для обратной совместимости**
```cpp
// ✅ СОБЛЮДЕНИЕ ISP: Используем адаптеры для старых интерфейсов

// Новые специализированные интерфейсы
class IClickable {
public:
    virtual void click() = 0;
    virtual void doubleClick() = 0;
    virtual ~IClickable() = default;
};

class ITextEditable {
public:
    virtual void setText(const std::string& text) = 0;
    virtual std::string getText() const = 0;
    virtual ~ITextEditable() = default;
};

class IValueAdjustable {
public:
    virtual void setValue(int value) = 0;
    virtual int getValue() const = 0;
    virtual void setRange(int min, int max) = 0;
    virtual ~IValueAdjustable() = default;
};

// Адаптер для старого кода, который использует IUIControl
class UIControlAdapter : public IUIControl {
protected:
    IClickable* clickable = nullptr;
    ITextEditable* textEditable = nullptr;
    IValueAdjustable* valueAdjustable = nullptr;
    
public:
    void click() override {
        if (clickable) clickable->click();
        else throw std::runtime_error("Not clickable");
    }
    
    void doubleClick() override {
        if (clickable) clickable->doubleClick();
        else throw std::runtime_error("Not clickable");
    }
    
    void setText(const std::string& text) override {
        if (textEditable) textEditable->setText(text);
        else throw std::runtime_error("Not text editable");
    }
    
    // ... аналогично для других методов
};

// Специализированная кнопка
class ModernButton : public IClickable, public ITextEditable {
public:
    void click() override {
        std::cout << "Modern button clicked!" << std::endl;
    }
    
    void doubleClick() override {
        std::cout << "Modern button double clicked!" << std::endl;
    }
    
    void setText(const std::string& text) override {
        this->text = text;
    }
    
    std::string getText() const override {
        return text;
    }
    
private:
    std::string text;
};
```

## Последствия нарушения ISP

### 1. **"Загрязнение" интерфейса**
```cpp
// Классы имеют методы, которые никогда не используются
class UnusedMethods {
    void method1() { /* Используется */ }
    void method2() { /* Никогда не вызывается */ }
    void method3() { /* Никогда не вызывается */ }
    void method4() { /* Никогда не вызывается */ }
    // ... 20 таких методов
};
```

### 2. **Сложность реализации**
```cpp
// Каждый новый класс должен реализовывать десятки методов
class PainfulImplementation : public IGodInterface {
    // 50 методов, из которых нужны только 5
    // Остальные 45 нужно либо заглушать, либо выбрасывать исключения
};
```

### 3. **Хрупкость системы**
```cpp
// Изменение в "толстом" интерфейсе затрагивает все классы
class FragileSystem {
    // Если в IGodInterface добавить новый метод,
    // то ВСЕ 100 классов должны его реализовать!
};
```

### 4. **Путаница в использовании**
```cpp
// Разработчики не знают, какие методы действительно можно вызывать
void confusedClient(IWorker& worker) {
    // Можно ли вызвать worker.cleanOffice()?
    // Будет ли исключение?
    // Нужно ли проверять тип?
    
    if (auto* programmer = dynamic_cast<Programmer*>(&worker)) {
        // Ага, это программист, значит cleanOffice() выбросит исключение
    }
    // Это антипаттерн!
}
```

## Best Practices для соблюдения ISP

### 1. **Принцип "одной ответственности для интерфейсов"**
```cpp
// Каждый интерфейс должен отвечать за одну конкретную функциональность
class ISingleResponsibility {
    // Хорошо: 3-5 методов, связанных одной целью
    virtual void doOneThing() = 0;
    virtual void doRelatedThing() = 0;
    virtual void doAnotherRelatedThing() = 0;
};
```

### 2. **Интерфейсы по ролям, а не по классам**
```cpp
// Вместо IEmployee с 50 методами
// Создаем интерфейсы по ролям:
class ICanCode { /* методы программиста */ };
class ICanManage { /* методы менеджера */ };
class ICanTest { /* методы тестировщика */ };

// Класс может реализовать несколько ролей
class TechLead : public ICanCode, public ICanManage {};
```

### 3. **Разделение по уровням абстракции**
```cpp
// Базовые низкоуровневые интерфейсы
class IReadable {
    virtual char readByte() = 0;
};

class IWritable {
    virtual void writeByte(char b) = 0;
};

// Высокоуровневые интерфейсы (композиция базовых)
class IReader : public IReadable {
    virtual std::string readLine() = 0;
    virtual std::string readAll() = 0;
};

class IWriter : public IWritable {
    virtual void writeLine(const std::string& line) = 0;
    virtual void writeAll(const std::string& content) = 0;
};

class IReadWriter : public IReader, public IWriter {};
```

## Как обнаружить нарушение ISP?

### Признаки "запаха кода":
1. **Интерфейс с более чем 5-7 методами**
2. **Классы реализуют методы, которые выбрасывают исключения `NotImplementedException`**
3. **Клиенты зависят от методов, которые они не используют**
4. **Частое использование `dynamic_cast` для проверки возможностей объекта**
5. **Интерфейс имеет методы из разных предметных областей**

### Тест на соблюдение ISP:
```cpp
// Если вы можете разделить интерфейс на две группы методов,
// которые используются разными клиентами - нарушение ISP!

class IViolatesISP {
    // Группа A: используется клиентом X
    virtual void methodForClientX1() = 0;
    virtual void methodForClientX2() = 0;
    
    // Группа B: используется клиентом Y
    virtual void methodForClientY1() = 0;
    virtual void methodForClientY2() = 0;
    virtual void methodForClientY3() = 0;
    
    // ❌ Нарушение: разделите на два интерфейса!
};
```

## Практическое правило

**"Клиент должен знать только о тех методах, которые он действительно использует. Если клиенту приходится знать о методе, который он не вызывает - это нарушение ISP."**

## Заключение

**ISP помогает создавать:**
- ✅ **Гибкие системы** (легко добавлять новые реализации)
- ✅ **Чистые интерфейсы** (каждый интерфейс имеет четкое назначение)
- ✅ **Удобные реализации** (классы реализуют только нужные методы)
- ✅ **Устойчивые к изменениям системы** (изменение одного интерфейса не затрагивает всех)

**Ключевые принципы соблюдения ISP:**
1. **Интерфейсы должны быть маленькими и сфокусированными**
2. **Клиенты не должны зависеть от методов, которые они не используют**
3. **Разделяйте большие интерфейсы на специализированные**
4. **Используйте множественное наследование интерфейсов**

**Помните:** Много маленьких интерфейсов лучше, чем один большой. Разделение интерфейсов делает код более модульным, тестируемым и поддерживаемым.