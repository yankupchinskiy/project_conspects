# Таблица виртуальных методов (vtable) в C++

## Что такое vtable?

**Vtable (virtual table)** — это механизм реализации динамического полиморфизма в C++. Это таблица указателей на виртуальные функции, которая создается компилятором для каждого класса, имеющего виртуальные методы.

## Как устроена vtable?

### Базовый пример
```cpp
class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
    virtual void eat() { cout << "Animal eats" << endl; }
    virtual ~Animal() { cout << "Animal destroyed" << endl; }
};

class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
    void eat() override { cout << "Dog eats meat" << endl; }
    ~Dog() override { cout << "Dog destroyed" << endl; }
};
```

**В памяти это выглядит примерно так:**

```
Animal vtable:
[0] → Animal::speak()
[1] → Animal::eat()
[2] → Animal::~Animal()

Dog vtable:
[0] → Dog::speak()      // переопределено
[1] → Dog::eat()        // переопределено  
[2] → Dog::~Dog()       // переопределено
```

## Структура объекта с виртуальными методами

```cpp
Animal* animal = new Dog();
```

**В памяти объект `Dog` содержит:**
```
Dog object in memory:
[0] vptr → Dog vtable
[1] данные Animal
[2] данные Dog
```

**`vptr` (virtual pointer)** — это скрытый указатель, который добавляется компилятором в начало объекта, если класс содержит виртуальные функции.

## Как производится вызов виртуальных методов?

### Пошаговый механизм вызова

```cpp
Animal* animal = new Dog();
animal->speak();  // Динамический вызов
```

**Что происходит внутри:**

1. **Получение vptr**: Компилятор генерирует код для получения vptr из объекта
   ```cpp
   // Псевдокод: что на самом деле происходит
   void** vptr = *(void***)animal;  // Получаем vptr из объекта
   ```

2. **Доступ к vtable**: Получаем указатель на функцию из таблицы
   ```cpp
   // speak() обычно имеет индекс 0 в vtable
   void (*func)() = (void (*)())vptr[0];
   ```

3. **Вызов функции**: Вызываем функцию через указатель
   ```cpp
   func(animal);  // Передаем this (указатель на объект)
   ```

**Эквивалентный код, который генерирует компилятор:**
```cpp
// Примерный машинный код
mov rax, [rdi]        ; Получаем vptr (rdi = this)
call [rax + offset]   ; Вызываем функцию по смещению
```

## Детальное представление в памяти

```cpp
class Shape {
public:
    virtual void draw() = 0;
    virtual double area() const = 0;
    virtual ~Shape() {}
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    void draw() override { /* рисование круга */ }
    double area() const override { return 3.14 * radius * radius; }
};
```

### В памяти:
```
Объект Circle:
[0] vptr → Circle vtable
[8] radius (double)

Circle vtable:
[0] → Circle::draw()
[8] → Circle::area()
[16] → Circle::~Circle()
[24] → typeinfo for Circle (RTTI)
```

## Особенности реализации

### 1. **Разные компиляторы, разные реализации**
```cpp
// GCC/Clang обычно используют такой layout:
class Base {
    void* vptr;      // неявно добавлен
    int base_data;
};

// MSVC может использовать другой порядок
```

### 2. **Виртуальное наследование сложнее**
```cpp
class A { virtual void fa() {} };
class B { virtual void fb() {} };
class C : public A, public B {
    void fa() override {}
    void fb() override {}
};

C c;
A* a = &c;
B* b = &c;

// a и b могут указывать на разные адреса в объекте c
// У объекта c будет ДВА vptr (для A и B частей)
```

### 3. **Порядок методов в vtable**
```cpp
class Example {
public:
    virtual void first() {}    // индекс 0
    virtual void second() {}   // индекс 1
    virtual void third() {}    // индекс 2
    virtual ~Example() {}      // индекс 3
};
```

## Код, демонстрирующий работу vtable

```cpp
#include <iostream>
#include <cstdint>

class Base {
public:
    virtual void func1() { std::cout << "Base::func1" << std::endl; }
    virtual void func2() { std::cout << "Base::func2" << std::endl; }
    virtual ~Base() {}
    
    int x = 42;
};

class Derived : public Base {
public:
    void func1() override { std::cout << "Derived::func1" << std::endl; }
    // func2 не переопределен - будет использоваться базовая версия
    
    int y = 100;
};

// Функция для исследования vtable
void inspectVTable(Base* obj) {
    // Получаем vptr (первое поле в объекте)
    std::uintptr_t* vptr = *reinterpret_cast<std::uintptr_t**>(obj);
    
    std::cout << "VTable address: " << vptr << std::endl;
    
    // Предполагаем, что первые три слота - это func1, func2, деструктор
    using FuncPtr = void(*)(Base*);
    
    FuncPtr f1 = reinterpret_cast<FuncPtr>(vptr[0]);
    FuncPtr f2 = reinterpret_cast<FuncPtr>(vptr[1]);
    FuncPtr dtor = reinterpret_cast<FuncPtr>(vptr[2]);
    
    std::cout << "Calling func1 through vtable: ";
    f1(obj);
    
    std::cout << "Calling func2 through vtable: ";
    f2(obj);
}

int main() {
    Base* b = new Derived();
    
    std::cout << "Object address: " << b << std::endl;
    std::cout << "Size of Base: " << sizeof(Base) << std::endl;
    std::cout << "Size of Derived: " << sizeof(Derived) << std::endl;
    
    inspectVTable(b);
    
    // Обычный вызов
    std::cout << "\nNormal virtual call:" << std::endl;
    b->func1();
    b->func2();
    
    delete b;
    return 0;
}
```

## Практические аспекты vtable

### 1. **Накладные расходы**
- **Память**: +8 байт на объект (vptr) + сама vtable (~8 байт на метод)
- **Время**: Дополнительное обращение к памяти при вызове

### 2. **Оптимизации компилятора**
```cpp
// Devirtualization - компилятор может устранить виртуальный вызов
Base* obj = new Derived();
obj->func1();  // Может быть заменено на прямой вызов Derived::func1()

// Но если тип неизвестен:
Base* getObject();  // Реализация где-то в другом месте
Base* obj = getObject();  // Тип неизвестен
obj->func1();  // Должен быть виртуальный вызов
```

### 3. **RTTI (Run-Time Type Information)**
```cpp
#include <typeinfo>

Base* obj = new Derived();
const std::type_info& ti = typeid(*obj);  // Использует информацию из vtable
std::cout << ti.name() << std::endl;  // Выведет что-то вроде "7Derived"
```

### 4. **Сравнение производительности**
```cpp
// Виртуальный вызов (медленнее)
virtual void process() { /* ... */ }

// Невиртуальный вызов (быстрее)
void process() { /* ... */ }

// Шаблонный полиморфизм (статический)
template<typename T>
void process(T& obj) { obj.process(); }
```

## Проблемы и ограничения

### 1. **Вызов из конструктора/деструктора**
```cpp
class Base {
public:
    Base() { 
        foo();  // Вызовет Base::foo(), даже если создается Derived
    }
    virtual void foo() { cout << "Base::foo" << endl; }
};

class Derived : public Base {
public:
    void foo() override { cout << "Derived::foo" << endl; }
};

Derived d;  // Выведет "Base::foo" - vptr еще не переключен
```

### 2. **Виртуальные функции и inline**
```cpp
class Example {
public:
    virtual void func() { /* ... */ }  // Не может быть inline (кроме случаев devirtualization)
};
```

### 3. **Порядок инициализации vptr**
```cpp
class Base {
public:
    virtual void f() {}
    Base() { f(); }  // Вызовет Base::f()
};

class Derived : public Base {
public:
    void f() override {}
    Derived() { f(); }  // Вызовет Derived::f()
};
```

## Продвинутые темы

### 1. **Множественное наследование и vtable**
```cpp
class Base1 {
public:
    virtual void f1() {}
    int a;
};

class Base2 {
public:
    virtual void f2() {}
    int b;
};

class Derived : public Base1, public Base2 {
public:
    void f1() override {}
    void f2() override {}
    int c;
};

Derived d;
Base1* b1 = &d;  // Указывает на начало объекта
Base2* b2 = &d;  // Указывает на Base2 часть (смещение в объекте)

// У объекта d будет ДВЕ vtable: для Base1 и Base2 частей
```

### 2. **Изменение vptr (опасно!)**
```cpp
class Base { virtual void f() {} };
class Derived1 : public Base { void f() override {} };
class Derived2 : public Base { void f() override {} };

Derived1 d1;
Derived2 d2;

// Меняем vptr (НЕ ДЕЛАЙТЕ ЭТОГО!)
*reinterpret_cast<void**>(&d1) = *reinterpret_cast<void**>(&d2);

d1.f();  // Неопределенное поведение!
```

## Таблица сравнения механизмов вызова

| Метод вызова | Механизм | Время выполнения | Инлайнинг | Размер кода |
|-------------|----------|------------------|-----------|-------------|
| **Прямой вызов** | Адрес известен на этапе компиляции | 1x | Да | Меньше |
| **Виртуальный вызов** | Через vtable (косвенный вызов) | 1.5-2x | Нет | Больше |
| **CRTP (статический полиморфизм)** | Шаблоны, нет vtable | 1x | Да | Больше (инстанцирование) |

## Заключение

**Таблица виртуальных методов — это:**
1. **Механизм** для реализации полиморфизма
2. **Таблица указателей** на виртуальные функции
3. **Скрытый указатель (vptr)** в каждом объекте
4. **Динамическое разрешение вызовов** во время выполнения

**Ключевые моменты:**
- Vtable создается на класс, а не на объект
- Vptr инициализируется в конструкторе
- Порядок методов в vtable соответствует порядку объявления
- Виртуальные вызовы дороже прямых вызовов
- Компилятор может оптимизировать (devirtualize) некоторые вызовы

**Используйте виртуальные функции когда:**
- Нужен полиморфизм во время выполнения
- Иерархия классов может расширяться
- Требуется инверсия зависимостей

**Избегайте когда:**
- Критична производительность
- Можно использовать шаблоны (статический полиморфизм)
- Все типы известны на этапе компиляции