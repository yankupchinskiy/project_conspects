# Принцип инверсии зависимостей (Dependency Inversion Principle - DIP)

## Что такое DIP?

**DIP** — пятый принцип SOLID, который гласит: 
1. **Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.**
2. **Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.**

Это означает, что код должен зависеть от интерфейсов, а не от конкретных реализаций.

## Примеры нарушения DIP

### Пример 1: **Прямая зависимость от конкретной реализации**
```cpp
// ❌ НАРУШЕНИЕ DIP: Верхний уровень зависит от нижнего уровня
// Конкретная реализация (низкий уровень)
class MySQLDatabase {
public:
    void connect() {
        std::cout << "Connecting to MySQL database..." << std::endl;
    }
    
    void query(const std::string& sql) {
        std::cout << "Executing MySQL query: " << sql << std::endl;
    }
    
    void disconnect() {
        std::cout << "Disconnecting from MySQL..." << std::endl;
    }
};

// Высокоуровневый модуль зависит от низкоуровневого
class UserRepository {
private:
    MySQLDatabase database;  // ⚠️ Прямая зависимость от конкретной БД
    
public:
    UserRepository() {
        database.connect();
    }
    
    ~UserRepository() {
        database.disconnect();
    }
    
    void saveUser(const User& user) {
        std::string sql = "INSERT INTO users VALUES ('" + user.name + "')";
        database.query(sql);
    }
    
    User getUser(int id) {
        std::string sql = "SELECT * FROM users WHERE id = " + std::to_string(id);
        database.query(sql);
        return User(); // упрощенный возврат
    }
};

// Проблема: если нужно сменить БД на PostgreSQL, придется менять UserRepository
```

### Пример 2: **Зависимость от конкретного сервиса**
```cpp
// ❌ НАРУШЕНИЕ DIP: Бизнес-логика зависит от конкретной инфраструктуры
// Конкретный email сервис (низкий уровень)
class GmailService {
public:
    void authenticate(const std::string& username, const std::string& password) {
        std::cout << "Authenticating with Gmail..." << std::endl;
    }
    
    void sendEmail(const std::string& to, const std::string& subject, const std::string& body) {
        std::cout << "Sending email via Gmail to " << to << std::endl;
        // Использует конкретные API Gmail
    }
    
    void setGmailSettings(const std::string& settings) {
        // Специфичные настройки Gmail
    }
};

// Бизнес-логика (высокий уровень)
class NotificationService {
private:
    GmailService gmailService;  // ⚠️ Зависит от конкретного провайдера
    
public:
    NotificationService(const std::string& username, const std::string& password) {
        gmailService.authenticate(username, password);
    }
    
    void sendWelcomeEmail(const User& user) {
        std::string subject = "Welcome!";
        std::string body = "Hello " + user.name + ", welcome to our service!";
        gmailService.sendEmail(user.email, subject, body);
    }
    
    void sendPasswordReset(const User& user, const std::string& token) {
        std::string subject = "Password Reset";
        std::string body = "Reset token: " + token;
        gmailService.sendEmail(user.email, subject, body);
    }
};

// Проблемы:
// 1. Нельзя использовать другой email-провайдер без изменения NotificationService
// 2. Трудно тестировать (нужен реальный Gmail аккаунт)
// 3. При изменении API Gmail нужно менять бизнес-логику
```

### Пример 3: **Создание зависимостей внутри класса**
```cpp
// ❌ НАРУШЕНИЕ DIP: Класс сам создает свои зависимости
class OrderProcessor {
private:
    PaymentGateway* paymentGateway;
    EmailService* emailService;
    Database* database;
    
public:
    OrderProcessor() {
        // ⚠️ Создание конкретных зависимостей внутри класса
        paymentGateway = new StripePaymentGateway();  // Конкретная реализация
        emailService = new SendGridEmailService();    // Конкретная реализация  
        database = new MySQLDatabase();               // Конкретная реализация
        
        // Инициализация зависимостей
        paymentGateway->configure("stripe_api_key");
        emailService->setup("sendgrid_api_key");
        database->connect("localhost", "root", "password");
    }
    
    ~OrderProcessor() {
        delete paymentGateway;
        delete emailService;
        delete database;
    }
    
    void processOrder(Order& order) {
        // Бизнес-логика обработки заказа
        paymentGateway->charge(order.total);
        database->save(order);
        emailService->sendReceipt(order);
    }
};

// Проблемы:
// 1. OrderProcessor тесно связан с конкретными реализациями
// 2. Невозможно подменить реализации для тестирования
// 3. При изменении любой зависимости нужно менять OrderProcessor
// 4. Нарушение Single Responsibility Principle (создание объектов)
```

### Пример 4: **Зависимость от конкретного формата**
```cpp
// ❌ НАРУШЕНИЕ DIP: Сервис зависит от конкретного формата данных
class XMLParser {
public:
    void parse(const std::string& xml) {
        std::cout << "Parsing XML: " << xml << std::endl;
    }
    
    std::string toXML(const Data& data) {
        return "<data>" + data.toString() + "</data>";
    }
};

class DataProcessor {
private:
    XMLParser xmlParser;  // ⚠️ Зависит от конкретного формата
    
public:
    void process(const std::string& xmlData) {
        xmlParser.parse(xmlData);
        // Обработка данных...
        
        Data result;
        std::string xmlOutput = xmlParser.toXML(result);
        saveOutput(xmlOutput);
    }
    
private:
    void saveOutput(const std::string& xml) {
        std::cout << "Saving XML: " << xml << std::endl;
    }
};

// Проблема: если нужно поддерживать JSON, придется переписывать DataProcessor
```

### Пример 5: **Цепочка зависимостей**
```cpp
// ❌ НАРУШЕНИЕ DIP: Цепочка конкретных зависимостей
class FileLogger {
public:
    void log(const std::string& message) {
        std::ofstream file("app.log", std::ios::app);
        file << message << std::endl;
    }
};

class UserService {
private:
    FileLogger logger;  // Конкретная зависимость
    
public:
    void registerUser(const User& user) {
        // Регистрация пользователя
        logger.log("User registered: " + user.name);
    }
};

class OrderService {
private:
    UserService userService;  // Конкретная зависимость
    FileLogger logger;        // Конкретная зависимость
    
public:
    void createOrder(Order& order) {
        // Создание заказа
        userService.registerUser(order.user);
        logger.log("Order created for user: " + order.user.name);
    }
};

// Проблемы:
// 1. OrderService зависит от конкретной реализации UserService
// 2. OrderService зависит от конкретной реализации FileLogger
// 3. Тестирование OrderService требует реального UserService и файловой системы
// 4. Изменение в любом низкоуровневом классе затрагивает высокоуровневые
```

## Как соблюдать DIP?

### Решение 1: **Зависимость от абстракций**
```cpp
// ✅ СОБЛЮДЕНИЕ DIP: Оба уровня зависят от абстракций

// Абстракция (интерфейс)
class IDatabase {
public:
    virtual void connect() = 0;
    virtual void disconnect() = 0;
    virtual void executeQuery(const std::string& sql) = 0;
    virtual ~IDatabase() = default;
};

// Конкретная реализация (низкий уровень)
class MySQLDatabase : public IDatabase {
public:
    void connect() override {
        std::cout << "Connecting to MySQL..." << std::endl;
    }
    
    void disconnect() override {
        std::cout << "Disconnecting from MySQL..." << std::endl;
    }
    
    void executeQuery(const std::string& sql) override {
        std::cout << "Executing MySQL query: " << sql << std::endl;
    }
};

class PostgreSQLDatabase : public IDatabase {
public:
    void connect() override {
        std::cout << "Connecting to PostgreSQL..." << std::endl;
    }
    
    void disconnect() override {
        std::cout << "Disconnecting from PostgreSQL..." << std::endl;
    }
    
    void executeQuery(const std::string& sql) override {
        std::cout << "Executing PostgreSQL query: " << sql << std::endl;
    }
};

// Высокоуровневый модуль (зависит от абстракции)
class UserRepository {
private:
    IDatabase& database;  // ✅ Зависимость от абстракции
    
public:
    UserRepository(IDatabase& db) : database(db) {  // Внедрение зависимости
        database.connect();
    }
    
    ~UserRepository() {
        database.disconnect();
    }
    
    void saveUser(const User& user) {
        std::string sql = "INSERT INTO users VALUES ('" + user.name + "')";
        database.executeQuery(sql);
    }
    
    User getUser(int id) {
        std::string sql = "SELECT * FROM users WHERE id = " + std::to_string(id);
        database.executeQuery(sql);
        return User();
    }
};

// Использование
int main() {
    // Можно легко подменить реализацию
    MySQLDatabase mysqlDB;
    UserRepository repo1(mysqlDB);
    repo1.saveUser(User("John"));
    
    // Или использовать PostgreSQL
    PostgreSQLDatabase pgDB;
    UserRepository repo2(pgDB);
    repo2.saveUser(User("Jane"));
    
    // ✅ UserRepository не зависит от конкретных баз данных
}
```

### Решение 2: **Внедрение зависимостей через конструктор**
```cpp
// ✅ СОБЛЮДЕНИЕ DIP: Зависимости внедряются извне

// Абстракции
class IPaymentGateway {
public:
    virtual void charge(double amount) = 0;
    virtual ~IPaymentGateway() = default;
};

class IEmailService {
public:
    virtual void sendEmail(const std::string& to, 
                          const std::string& subject, 
                          const std::string& body) = 0;
    virtual ~IEmailService() = default;
};

class IDatabase {
public:
    virtual void save(const Order& order) = 0;
    virtual ~IDatabase() = default;
};

// Конкретные реализации
class StripePaymentGateway : public IPaymentGateway {
public:
    void charge(double amount) override {
        std::cout << "Charging $" << amount << " via Stripe" << std::endl;
    }
};

class PayPalPaymentGateway : public IPaymentGateway {
public:
    void charge(double amount) override {
        std::cout << "Charging $" << amount << " via PayPal" << std::endl;
    }
};

class SendGridEmailService : public IEmailService {
public:
    void sendEmail(const std::string& to, 
                   const std::string& subject, 
                   const std::string& body) override {
        std::cout << "Sending email via SendGrid to " << to << std::endl;
    }
};

// Бизнес-логика (высокий уровень)
class OrderProcessor {
private:
    IPaymentGateway& paymentGateway;  // ✅ Зависимость от абстракции
    IEmailService& emailService;      // ✅ Зависимость от абстракции
    IDatabase& database;              // ✅ Зависимость от абстракции
    
public:
    // Внедрение зависимостей через конструктор
    OrderProcessor(IPaymentGateway& pg, IEmailService& es, IDatabase& db)
        : paymentGateway(pg), emailService(es), database(db) {}
    
    void processOrder(Order& order) {
        // Бизнес-логика
        paymentGateway.charge(order.total);
        database.save(order);
        
        std::string subject = "Order Confirmation";
        std::string body = "Thank you for your order!";
        emailService.sendEmail(order.user.email, subject, body);
    }
};

// Фабрика или DI-контейнер создает зависимости
int main() {
    // Конфигурация зависимостей
    StripePaymentGateway stripe;
    SendGridEmailService sendgrid;
    MySQLDatabase database;
    
    // Внедрение зависимостей
    OrderProcessor processor(stripe, sendgrid, database);
    
    Order order;
    processor.processOrder(order);
    
    // Легко подменить реализации
    PayPalPaymentGateway paypal;
    OrderProcessor anotherProcessor(paypal, sendgrid, database);
}
```

### Решение 3: **Шаблон Dependency Injection Container**
```cpp
// ✅ СОБЛЮДЕНИЕ DIP: Контейнер управляет зависимостями

// Простой DI-контейнер
class DIContainer {
private:
    std::unordered_map<std::string, std::function<std::any()>> factories;
    
public:
    template<typename T>
    void registerFactory(std::function<T*()> factory) {
        factories[typeid(T).name()] = [factory]() -> std::any {
            return std::any(factory());
        };
    }
    
    template<typename T>
    T* resolve() {
        auto it = factories.find(typeid(T).name());
        if (it != factories.end()) {
            return std::any_cast<T*>(it->second());
        }
        return nullptr;
    }
};

// Использование с DIP
int main() {
    DIContainer container;
    
    // Регистрируем зависимости (конфигурация)
    container.registerFactory<ILogger>([]() {
        return static_cast<ILogger*>(new FileLogger());
    });
    
    container.registerFactory<IDatabase>([]() {
        return static_cast<IDatabase*>(new PostgreSQLDatabase());
    });
    
    container.registerFactory<IPaymentGateway>([]() {
        return static_cast<IPaymentGateway*>(new StripePaymentGateway());
    });
    
    // Разрешаем зависимости
    ILogger* logger = container.resolve<ILogger>();
    IDatabase* db = container.resolve<IDatabase>();
    IPaymentGateway* pg = container.resolve<IPaymentGateway>();
    
    // Создаем сервис с внедренными зависимостями
    OrderService orderService(*logger, *db, *pg);
    
    // Можно легко изменить конфигурацию, не меняя OrderService
}
```

### Решение 4: **Шаблон Фабричный метод**
```cpp
// ✅ СОБЛЮДЕНИЕ DIP: Использование фабрик для создания зависимостей

// Абстрактная фабрика
class IDatabaseFactory {
public:
    virtual std::unique_ptr<IDatabase> createDatabase() = 0;
    virtual ~IDatabaseFactory() = default;
};

// Конкретные фабрики
class MySQLDatabaseFactory : public IDatabaseFactory {
public:
    std::unique_ptr<IDatabase> createDatabase() override {
        return std::make_unique<MySQLDatabase>();
    }
};

class PostgreSQLDatabaseFactory : public IDatabaseFactory {
public:
    std::unique_ptr<IDatabase> createDatabase() override {
        return std::make_unique<PostgreSQLDatabase>();
    }
};

// Сервис зависит от фабрики (абстракции)
class ReportService {
private:
    std::unique_ptr<IDatabase> database;
    
public:
    ReportService(IDatabaseFactory& factory) {
        database = factory.createDatabase();  // Создание через абстракцию
        database->connect();
    }
    
    void generateReport() {
        // Использование базы данных
        database->executeQuery("SELECT * FROM reports");
    }
};

// Конфигурация на уровне приложения
int main() {
    // В зависимости от конфигурации используем нужную фабрику
#ifdef USE_MYSQL
    MySQLDatabaseFactory factory;
#else
    PostgreSQLDatabaseFactory factory;
#endif
    
    ReportService service(factory);
    service.generateReport();
}
```

### Решение 5: **Шаблон Стратегия с DIP**
```cpp
// ✅ СОБЛЮДЕНИЕ DIP: Стратегия через абстракции

// Абстракция для стратегии сортировки
class ISortStrategy {
public:
    virtual void sort(std::vector<int>& data) = 0;
    virtual ~ISortStrategy() = default;
};

// Конкретные стратегии
class QuickSortStrategy : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Sorting with QuickSort" << std::endl;
        std::sort(data.begin(), data.end());
    }
};

class MergeSortStrategy : public ISortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Sorting with MergeSort" << std::endl;
        std::sort(data.begin(), data.end()); // упрощенно
    }
};

// Контекст (высокий уровень) зависит от абстракции
class Sorter {
private:
    ISortStrategy& strategy;  // ✅ Зависимость от абстракции
    
public:
    Sorter(ISortStrategy& strat) : strategy(strat) {}
    
    void sortData(std::vector<int>& data) {
        strategy.sort(data);
    }
    
    // Можно динамически менять стратегию
    void setStrategy(ISortStrategy& newStrategy) {
        strategy = newStrategy;
    }
};

// Использование
int main() {
    std::vector<int> data = {5, 2, 8, 1, 9};
    
    QuickSortStrategy quickSort;
    MergeSortStrategy mergeSort;
    
    Sorter sorter(quickSort);  // Используем QuickSort
    sorter.sortData(data);
    
    sorter.setStrategy(mergeSort);  // Меняем на MergeSort
    sorter.sortData(data);
}
```

## Последствия нарушения DIP

### 1. **Жесткая связанность (Tight Coupling)**
```cpp
// ❌ Изменение в низкоуровневом модуле требует изменений в высокоуровневом
class HighLevelModule {
    LowLevelModule dependency;  // Прямая зависимость
    
    void doSomething() {
        dependency.specificMethod();  // Если метод изменится, нужно менять этот код
    }
};
```

### 2. **Сложность тестирования**
```cpp
// ❌ Невозможно подменить реальные зависимости моками
class Service {
    RealDatabase database;  // Реальная БД
    
    void process() {
        database.query();  // Как протестировать без реальной БД?
    }
};
```

### 3. **Трудности с расширением**
```cpp
// ❌ Добавление новой функциональности требует изменения существующего кода
class PaymentProcessor {
    PayPalGateway gateway;  // Только PayPal
    
    // Чтобы добавить Stripe, нужно менять этот класс
};
```

### 4. **Нарушение Open/Closed Principle**
```cpp
// ❌ Класс закрыт для расширения
class ReportGenerator {
    PDFExporter exporter;  // Только PDF
    
    // Чтобы добавить Excel экспорт, нужно менять класс
};
```

## Best Practices для соблюдения DIP

### 1. **Инверсия зависимостей в архитектуре**
```cpp
// Слоистая архитектура с DIP
class Application {
    // Высокоуровневые модули зависят от абстракций
    IService& service;
    
public:
    Application(IService& srv) : service(srv) {}
};

// Абстракция (интерфейс)
class IService {
public:
    virtual void execute() = 0;
    virtual ~IService() = default;
};

// Низкоуровневый модуль реализует абстракцию
class ConcreteService : public IService {
    IRepository& repository;  // Также зависит от абстракции
    
public:
    ConcreteService(IRepository& repo) : repository(repo) {}
    
    void execute() override {
        // Использует репозиторий через абстракцию
    }
};
```

### 2. **Принцип Голливуда: "Не звоните нам, мы вам позвоним"**
```cpp
// Фреймворк вызывает ваш код, а не наоборот
class Framework {
public:
    virtual void onEvent(Event& event) = 0;  // Абстракция для callback
};

class MyApplication : public Framework {
public:
    void onEvent(Event& event) override {
        // Реализация callback
    }
};

// Фреймворк контролирует поток выполнения
// Приложение зависит от абстракций фреймворка
```

### 3. **Зависимость от стабильных абстракций**
```cpp
// Зависьте от интерфейсов, которые редко меняются
class IStableInterface {
    // Только основные, стабильные методы
    virtual void essentialOperation() = 0;
    virtual ~IStableInterface() = default;
};

// А не от интерфейсов, которые часто меняются
class IUnstableInterface {
    // Много методов, которые часто меняются
    virtual void operation1() = 0;
    virtual void operation2() = 0;
    virtual void operation3() = 0;  // Добавили вчера
    virtual void operation4() = 0;  // Добавим завтра
};
```

## Как обнаружить нарушение DIP?

### Признаки "запаха кода":
1. **Классы создают свои зависимости с помощью `new`**
2. **Классы содержат конкретные типы в полях и параметрах методов**
3. **Много импортов/включений конкретных реализаций**
4. **Сложно написать unit-тесты без реальных зависимостей**
5. **Изменение в низкоуровневом модуле требует изменений в высокоуровневом**

### Тест на соблюдение DIP:
```cpp
// Спросите себя:
class DIPTest {
    // 1. Если я изменю низкоуровневый модуль, нужно ли менять высокоуровневый?
    // 2. Можно ли протестировать высокоуровневый модуль без реальных зависимостей?
    // 3. Можно ли легко подменить реализацию зависимости?
    // 4. Зависит ли модуль от абстракции или конкретной реализации?
};
```

## Заключение

**DIP помогает создавать:**
- ✅ **Гибкие системы** (легко заменять реализации)
- ✅ **Тестируемые системы** (можно использовать моки и стабы)
- ✅ **Модульные системы** (компоненты слабо связаны)
- ✅ **Устойчивые к изменениям системы** (изменения в деталях не затрагивают абстракции)

**Ключевые принципы соблюдения DIP:**
1. **Зависьте от абстракций, а не от конкретных классов**
2. **Высокоуровневые модули не должны зависеть от низкоуровневых**
3. **Внедряйте зависимости извне (Dependency Injection)**
4. **Используйте интерфейсы для определения контрактов**

**Помните:** DIP — это не просто про использование интерфейсов. Это про направление зависимостей. Правильное направление зависимостей — от конкретики к абстракции, от изменчивого к стабильному, от деталей реализации к политикам.
