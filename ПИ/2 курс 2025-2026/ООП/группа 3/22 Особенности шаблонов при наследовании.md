# Особенности шаблонов при наследовании

## Основные концепции

### 1. **Зависимые базовые классы (dependent base classes)**
Когда базовый класс зависит от параметра шаблона, компилятор не знает его членов до инстанцирования:

```cpp
template<typename T>
class Base {
public:
    void baseMethod() {}
    int baseValue;
};

template<typename T>
class Derived : public Base<T> {  // Base<T> - зависимый базовый класс
public:
    void derivedMethod() {
        // ❌ Ошибка: baseMethod не найден
        // baseMethod();
        
        // ✅ Правильно: через this->
        this->baseMethod();
        
        // ✅ Или через полное имя
        Base<T>::baseMethod();
        
        // ✅ Или using в теле класса
        using Base<T>::baseMethod;
        baseMethod();
    }
    
    void anotherMethod() {
        // ❌ Ошибка
        // int x = baseValue;
        
        // ✅ Правильно
        int x = this->baseValue;
    }
};
```

### 2. **Наследование от специализаций шаблонов**

```cpp
// Основной шаблон
template<typename T>
class Container {
protected:
    T* data;
};

// Явная специализация
template<>
class Container<int> {
protected:
    int* data;
    void specialIntMethod() {}
};

// Наследование от специализации
class IntContainerDerived : public Container<int> {
public:
    void useSpecial() {
        specialIntMethod();  // Доступ к методам специализации
    }
};

// Наследование от общего шаблона
template<typename U>
class DerivedContainer : public Container<U> {
    // Можно добавить специфичную функциональность
};
```

## Ключевые особенности

### 1. **CRTP (Curiously Recurring Template Pattern)**
Шаблонная идиома, когда класс наследуется от шаблона с самим собой как параметром:

```cpp
// Базовый шаблонный класс
template<typename Derived>
class BaseCRTP {
public:
    void interface() {
        // Вызов метода производного класса
        static_cast<Derived*>(this)->implementation();
    }
    
    // Методы, реализуемые через производный класс
    void printSize() {
        std::cout << sizeof(Derived) << "\n";
    }
};

// Производный класс
class DerivedClass : public BaseCRTP<DerivedClass> {
public:
    void implementation() {
        std::cout << "Derived implementation\n";
    }
    
    // Дополнительные методы
    void extraMethod() {}
};

DerivedClass d;
d.interface();    // Вызывает DerivedClass::implementation()
d.printSize();    // Выводит размер DerivedClass
```

#### **Практическое применение CRTP**:

```cpp
// 1. Статический полиморфизм
template<typename Derived>
class Comparable {
public:
    bool operator!=(const Derived& other) const {
        return !(static_cast<const Derived&>(*this) == other);
    }
};

class MyClass : public Comparable<MyClass> {
    int value;
public:
    MyClass(int v) : value(v) {}
    bool operator==(const MyClass& other) const {
        return value == other.value;
    }
};

// 2. Подсчет экземпляров
template<typename T>
class InstanceCounter {
protected:
    InstanceCounter() { ++count; }
    ~InstanceCounter() { --count; }
    InstanceCounter(const InstanceCounter&) { ++count; }
public:
    static size_t getCount() { return count; }
private:
    static inline size_t count = 0;
};

class Widget : public InstanceCounter<Widget> {};

std::cout << Widget::getCount();  // Количество созданных Widget
```

### 2. **Наследование с разными параметрами шаблонов**

```cpp
template<typename T, size_t N>
class FixedArray {
protected:
    T data[N];
};

// Наследование с изменением параметров
template<typename T>
class DynamicArray : public FixedArray<T, 0> {
    size_t capacity;
public:
    DynamicArray(size_t size) : capacity(size) {
        this->data = new T[capacity];  // Переопределяем хранение
    }
    ~DynamicArray() { delete[] this->data; }
};

// Наследование с добавлением параметров
template<typename T, typename Allocator = std::allocator<T>>
class ManagedArray : public FixedArray<T, 100> {
    Allocator alloc;
    // Дополнительная функциональность с аллокатором
};
```

### 3. **Шаблонные производные классы**

```cpp
// Базовый класс может быть нешаблонным
class BaseNonTemplate {
protected:
    virtual void process() = 0;
};

template<typename T>
class TemplateDerived : public BaseNonTemplate {
    T value;
protected:
    void process() override {
        // Реализация, зависящая от T
        std::cout << typeid(T).name() << ": " << value << "\n";
    }
public:
    TemplateDerived(T v) : value(v) {}
};
```

### 4. **Множественное наследование от шаблонов**

```cpp
template<typename T>
class Storage {
protected:
    T* data;
};

template<typename U>
class Serializer {
public:
    virtual std::string serialize() const = 0;
};

template<typename T>
class MyClass : public Storage<T>, public Serializer<MyClass<T>> {
    T value;
public:
    std::string serialize() const override {
        return std::to_string(value);
    }
};

// Использование
MyClass<int> obj;
obj.serialize();  // Доступ к методу из шаблонного базового класса
```

### 5. **Наследование конструкторов**

```cpp
template<typename T>
class BaseWithConstructor {
public:
    BaseWithConstructor(T val) : value(val) {}
    T value;
};

// Наследование конструктора в шаблонном классе
template<typename T>
class DerivedInheriting : public BaseWithConstructor<T> {
public:
    using BaseWithConstructor<T>::BaseWithConstructor;
    // Конструктор BaseWithConstructor(T) теперь доступен в DerivedInheriting
};

DerivedInheriting<int> d(42);  // Использует унаследованный конструктор
```

### 6. **Доступ к typedef/using из базового класса**

```cpp
template<typename T>
class BaseWithTypes {
public:
    using value_type = T;
    using pointer = T*;
    using reference = T&;
    
    typedef std::vector<T> ContainerType;
};

template<typename T>
class Derived : public BaseWithTypes<T> {
public:
    // ❌ Ошибка: value_type не найден
    // value_type getValue();
    
    // ✅ Правильно
    typename BaseWithTypes<T>::value_type getValue();
    
    // Или через using
    using typename BaseWithTypes<T>::value_type;
    value_type getValue();  // Теперь OK
};
```

## Проблемы и их решения

### 1. **Проблема двухфазного поиска (two-phase name lookup)**

```cpp
template<typename T>
class Base {
public:
    void method() {}           // #1 - зависимое имя
    typedef int InternalType;  // #2 - зависимое имя
};

template<typename T>
class Derived : public Base<T> {
public:
    void test() {
        // Фаза 1: при определении шаблона
        // Независимые имена ищутся сейчас
        std::cout << "Hello";  // Найдено
        
        // Фаза 2: при инстанциации
        // Зависимые имена ищутся в Base<ConcreteType>
        method();               // ❌ Не найдено на фазе 1
        
        this->method();         // ✅ Зависимое имя, будет искаться на фазе 2
        
        InternalType x;         // ❌ Не найдено
        typename Base<T>::InternalType y;  // ✅
    }
};
```

### 2. **Виртуальные методы в шаблонных классах**

```cpp
template<typename T>
class BaseTemplate {
public:
    virtual void process(T value) {
        std::cout << "Base: " << value << "\n";
    }
    
    // Виртуальный деструктор важен!
    virtual ~BaseTemplate() = default;
};

class DerivedInt : public BaseTemplate<int> {
public:
    void process(int value) override {
        std::cout << "DerivedInt: " << value << "\n";
    }
};

class DerivedDouble : public BaseTemplate<double> {
public:
    void process(double value) override {
        std::cout << "DerivedDouble: " << value << "\n";
    }
};

// BaseTemplate<int> и BaseTemplate<double> - разные классы
// Нет общего полиморфизма между ними
```

### 3. **Шаблонные дружественные классы**

```cpp
template<typename T>
class Base {
private:
    T secret;
    
    // Дружественный класс должен быть объявлен
    template<typename U> friend class FriendClass;
};

template<typename U>
class FriendClass {
public:
    template<typename T>
    void accessSecret(Base<T>& base) {
        std::cout << base.secret;  // Доступ к приватному члену
    }
};
```

## Практические паттерны

### 1. **Policy-based design**

```cpp
// Политики как шаблонные базовые классы
template<typename T>
struct DefaultAllocator {
    T* allocate(size_t n) { return new T[n]; }
    void deallocate(T* p) { delete[] p; }
};

template<typename T>
struct CustomAllocator {
    T* allocate(size_t n) { /* кастомная аллокация */ }
    void deallocate(T* p) { /* кастомное освобождение */ }
};

template<typename T, template<typename> class AllocPolicy = DefaultAllocator>
class Container : private AllocPolicy<T> {
    T* data;
    size_t size;
public:
    Container(size_t n) : size(n) {
        data = this->allocate(n);  // Используем политику
    }
    ~Container() {
        this->deallocate(data);
    }
};
```

### 2. **Mixin-классы**

```cpp
// Базовые миксины
template<typename Derived>
class Printable {
public:
    void print() const {
        std::cout << static_cast<const Derived&>(*this).toString() << "\n";
    }
};

template<typename Derived>
class Cloneable {
public:
    Derived* clone() const {
        return new Derived(static_cast<const Derived&>(*this));
    }
};

// Класс, использующий миксины
class MyClass : public Printable<MyClass>, public Cloneable<MyClass> {
    int value;
public:
    MyClass(int v) : value(v) {}
    std::string toString() const {
        return "MyClass(" + std::to_string(value) + ")";
    }
};

MyClass obj(42);
obj.print();           // Из Printable
MyClass* copy = obj.clone();  // Из Cloneable
```

### 3. **Type erasure через наследование**

```cpp
// Нешаблонный интерфейс
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
};

// Шаблонная реализация
template<typename T>
class DrawableImpl : public Drawable {
    T object;
public:
    DrawableImpl(T obj) : object(std::move(obj)) {}
    void draw() const override {
        object.draw();  // Предполагается, что T имеет метод draw()
    }
};

// Контейнер стирания типа
class Canvas {
    std::vector<std::unique_ptr<Drawable>> objects;
public:
    template<typename T>
    void add(T obj) {
        objects.push_back(std::make_unique<DrawableImpl<T>>(std::move(obj)));
    }
    
    void drawAll() {
        for (auto& obj : objects) obj->draw();
    }
};
```

## Важные правила

1. **Для доступа к членам зависимых базовых классов** всегда используйте:
   - `this->member`
   - `Base<T>::member`
   - `using Base<T>::member`

2. **Шаблонные классы не могут быть виртуальными базовыми** для нешаблонных классов напрямую, но можно через промежуточный класс.

3. **Каждая инстанциация шаблона** создаёт отдельный класс в иерархии.

4. **Специализации могут нарушать полиморфизм**, если они не сохраняют интерфейс базового шаблона.

5. **При наследовании шаблонных классов** компиляция происходит в два этапа, что влияет на поиск имён.

Эти особенности делают шаблоны и наследование мощным, но требующим внимания инструментом в C++.