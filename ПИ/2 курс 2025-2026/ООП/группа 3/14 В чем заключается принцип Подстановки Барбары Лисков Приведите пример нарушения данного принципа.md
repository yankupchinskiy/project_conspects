# Принцип подстановки Барбары Лисков (Liskov Substitution Principle - LSP)

## Что такое LSP?

**LSP** — третий принцип SOLID, который гласит: *"Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности программы"*. Другими словами, если класс `S` является подтипом класса `T`, то объекты типа `T` могут быть заменены объектами типа `S` без нарушения корректности программы.

## Классическое нарушение LSP

### Пример 1: **Прямоугольник и Квадрат**
```cpp
// ❌ НАРУШЕНИЕ LSP: Квадрат не может быть заменой Прямоугольника
class Rectangle {
protected:
    int width;
    int height;
    
public:
    Rectangle(int w, int h) : width(w), height(h) {}
    
    virtual void setWidth(int w) { width = w; }
    virtual void setHeight(int h) { height = h; }
    
    int getWidth() const { return width; }
    int getHeight() const { return height; }
    
    int area() const { return width * height; }
};

// Квадрат - частный случай прямоугольника? Математически да, но в ООП нет!
class Square : public Rectangle {
public:
    Square(int size) : Rectangle(size, size) {}
    
    void setWidth(int w) override {
        width = w;
        height = w;  // ⚠️ Нарушение: меняем и ширину, и высоту
    }
    
    void setHeight(int h) override {
        height = h;
        width = h;   // ⚠️ Нарушение: меняем и высоту, и ширину
    }
};

// Функция, которая ожидает Rectangle
void testRectangle(Rectangle& rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    
    // Ожидаем площадь = 20 (5 * 4)
    int expectedArea = 20;
    int actualArea = rect.area();
    
    std::cout << "Expected area: " << expectedArea << std::endl;
    std::cout << "Actual area: " << actualArea << std::endl;
    
    if (actualArea != expectedArea) {
        std::cout << "❌ LSP VIOLATION!" << std::endl;
    }
}

int main() {
    Rectangle rect(1, 1);
    testRectangle(rect);  // ✅ Ожидаемо: 20
    
    Square square(1);
    testRectangle(square); // ❌ Получим: 16 (4 * 4) вместо 20!
    // Квадрат нарушает контракт Rectangle!
}
```

## Примеры нарушения LSP

### Пример 2: **Птицы, которые не летают**
```cpp
// ❌ НАРУШЕНИЕ LSP: Не все птицы летают
class Bird {
public:
    virtual void fly() {
        std::cout << "Flying..." << std::endl;
    }
    
    virtual void eat() {
        std::cout << "Eating..." << std::endl;
    }
};

class Sparrow : public Bird {
public:
    // ✅ Воробей может летать
};

class Penguin : public Bird {
public:
    // ❌ Пингвин не может летать, но вынужден реализовывать fly()
    void fly() override {
        throw std::runtime_error("Penguins can't fly!");
    }
};

void makeBirdFly(Bird& bird) {
    // Этот код ожидает, что ВСЕ птицы могут летать
    bird.fly();
}

int main() {
    Sparrow sparrow;
    makeBirdFly(sparrow);  // ✅ OK
    
    Penguin penguin;
    try {
        makeBirdFly(penguin);  // ❌ Выбросит исключение!
    } catch (const std::exception& e) {
        std::cout << "Penguin failed: " << e.what() << std::endl;
    }
    
    // Пингвин нарушает LSP: он не может быть заменой Bird
    // в контексте, где требуется fly()
}
```

### Пример 3: **Коллекции с изменением поведения**
```cpp
// ❌ НАРУШЕНИЕ LSP: Подкласс ужесточает условия
class Collection {
public:
    virtual void add(int item) {
        elements.push_back(item);
    }
    
    virtual int get(int index) const {
        if (index < 0 || index >= elements.size()) {
            return -1;  // Возвращаем -1 при ошибке
        }
        return elements[index];
    }
    
protected:
    std::vector<int> elements;
};

class StrictCollection : public Collection {
public:
    // ⚠️ Нарушение: ужесточаем предусловия
    void add(int item) override {
        if (item < 0) {
            throw std::invalid_argument("Only positive numbers allowed!");
        }
        Collection::add(item);
    }
    
    // ⚠️ Нарушение: ослабляем постусловия
    int get(int index) const override {
        if (index < 0 || index >= elements.size()) {
            throw std::out_of_range("Index out of range!");  // Кидаем исключение вместо -1
        }
        return elements[index];
    }
};

void processCollection(Collection& coll) {
    // Этот код работает с базовым классом
    coll.add(-5);  // ✅ Для Collection это нормально
    int value = coll.get(100);  // ✅ Для Collection вернет -1
    
    // Но для StrictCollection:
    // 1. add(-5) выбросит исключение
    // 2. get(100) выбросит другое исключение
    // Нарушение LSP: подкласс нельзя использовать вместо базового!
}
```

### Пример 4: **Исключения в деструкторах**
```cpp
// ❌ НАРУШЕНИЕ LSP: Деструктор с исключением
class DatabaseConnection {
public:
    virtual ~DatabaseConnection() {
        // Базовый класс гарантирует безопасное разрушение
        close();  // Может выбросить исключение, но перехватывает его
    }
    
    void close() {
        try {
            // Закрытие соединения
            if (/* ошибка */) {
                throw std::runtime_error("Close failed");
            }
        } catch (...) {
            // Логируем, но не пропускаем исключение наружу
            std::cerr << "Error closing connection" << std::endl;
        }
    }
};

class StrictDatabaseConnection : public DatabaseConnection {
public:
    ~StrictDatabaseConnection() override {
        // ⚠️ Нарушение: пропускаем исключение из деструктора
        if (!isClosedProperly()) {
            throw std::runtime_error("Destructor failed!");  // ОПАСНО!
        }
    }
    
    void specialOperation() {
        // Операция, которая может сделать объект некорректным
    }
    
private:
    bool isClosedProperly() const { return false; }
};

void useConnection(DatabaseConnection* conn) {
    // Работа с соединением
    delete conn;  // ✅ Для DatabaseConnection безопасно
                   // ❌ Для StrictDatabaseConnection может выбросить исключение!
}
```

### Пример 5: **Изменение возвращаемого типа ковариантно**
```cpp
class Animal {
public:
    virtual Animal* clone() const {
        return new Animal(*this);
    }
    
    virtual void speak() const {
        std::cout << "Animal sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    // ✅ Правильно: ковариантный возвращаемый тип
    Dog* clone() const override {
        return new Dog(*this);
    }
    
    void speak() const override {
        std::cout << "Woof!" << std::endl;
    }
    
    void fetch() {
        std::cout << "Fetching..." << std::endl;
    }
};

class Cat : public Animal {
public:
    // ❌ Нарушение LSP: меняем семантику метода
    Cat* clone() const override {
        // Возвращаем неполную копию!
        Cat* copy = new Cat(*this);
        copy->lives = 9;  // Все коты начинают с 9 жизней
        return copy;
    }
    
    void speak() const override {
        std::cout << "Meow!" << std::endl;
    }
    
private:
    int lives = 9;
};

void cloneAndSpeak(Animal* animal) {
    Animal* cloned = animal->clone();
    // Ожидание: cloned - точная копия animal
    cloned->speak();
    
    // Но для Cat: cloned будет отличаться от оригинального animal!
    // Нарушение LSP: метод clone() должен создавать точную копию
}
```

## Правила LSP (Контрактное программирование)

### 1. **Предусловия не могут быть усилены**
```cpp
class Base {
public:
    // Предусловие: x >= 0
    virtual void process(int x) {
        if (x < 0) throw std::invalid_argument("x must be >= 0");
        // ...
    }
};

class Derived : public Base {
public:
    // ❌ НАРУШЕНИЕ: усиление предусловия (x > 0)
    void process(int x) override {
        if (x <= 0) throw std::invalid_argument("x must be > 0");  // Ужесточили!
        Base::process(x);
    }
};
```

### 2. **Постусловия не могут быть ослаблены**
```cpp
class Base {
public:
    // Постусловие: возвращаемое значение >= 0
    virtual int calculate() const {
        int result = /* вычисления */;
        if (result < 0) throw std::runtime_error("Result must be >= 0");
        return result;
    }
};

class Derived : public Base {
public:
    // ❌ НАРУШЕНИЕ: ослабление постусловия
    int calculate() const override {
        int result = /* вычисления */;
        // Пропускаем проверку! Может вернуть отрицательное число
        return result;
    }
};
```

### 3. **Инварианты базового класса должны сохраняться**
```cpp
class Account {
protected:
    double balance;
    
public:
    // Инвариант: balance >= 0
    Account(double initialBalance) : balance(initialBalance) {
        if (balance < 0) throw std::invalid_argument("Balance cannot be negative");
    }
    
    virtual void withdraw(double amount) {
        if (amount > balance) throw std::runtime_error("Insufficient funds");
        balance -= amount;
        // Инвариант: balance >= 0 сохраняется
    }
};

class OverdraftAccount : public Account {
public:
    // ❌ НАРУШЕНИЕ: нарушаем инвариант (баланс может быть отрицательным)
    OverdraftAccount(double initialBalance, double overdraftLimit) 
        : Account(initialBalance), overdraftLimit(overdraftLimit) {}
    
    void withdraw(double amount) override {
        if (amount > balance + overdraftLimit) {
            throw std::runtime_error("Exceeds overdraft limit");
        }
        balance -= amount;  // ⚠️ Баланс может стать отрицательным!
        // Инвариант базового класса нарушен
    }
    
private:
    double overdraftLimit;
};
```

## Как соблюдать LSP?

### Решение 1: **Разделение интерфейсов (Interface Segregation)**
```cpp
// ✅ СОБЛЮДЕНИЕ LSP: Разделяем интерфейсы
class IFlyable {
public:
    virtual void fly() = 0;
    virtual ~IFlyable() = default;
};

class ISwimmable {
public:
    virtual void swim() = 0;
    virtual ~ISwimmable() = default;
};

class Bird {
public:
    virtual void eat() {
        std::cout << "Eating..." << std::endl;
    }
    virtual ~Bird() = default;
};

class Sparrow : public Bird, public IFlyable {
public:
    void fly() override {
        std::cout << "Sparrow flying" << std::endl;
    }
};

class Penguin : public Bird, public ISwimmable {
public:
    void swim() override {
        std::cout << "Penguin swimming" << std::endl;
    }
};

// Теперь мы используем конкретные интерфейсы
void makeItFly(IFlyable& flyable) {
    flyable.fly();  // ✅ Гарантировано, что объект может летать
}

void makeItSwim(ISwimmable& swimmable) {
    swimmable.swim();  // ✅ Гарантировано, что объект может плавать
}
```

### Решение 2: **Композиция вместо наследования**
```cpp
// ✅ СОБЛЮДЕНИЕ LSP: Используем композицию
class Shape {
public:
    virtual double area() const = 0;
    virtual ~Shape() = default;
};

class Rectangle : public Shape {
private:
    int width;
    int height;
    
public:
    Rectangle(int w, int h) : width(w), height(h) {}
    
    void setWidth(int w) { width = w; }
    void setHeight(int h) { height = h; }
    
    double area() const override {
        return width * height;
    }
};

class Square : public Shape {
private:
    int size;
    
public:
    Square(int s) : size(s) {}
    
    void setSize(int s) { size = s; }
    
    double area() const override {
        return size * size;
    }
};

// Теперь Square не наследует от Rectangle
// И не нарушает его контракт
```

### Решение 3: **Шаблонный метод с защищенными методами**
```cpp
// ✅ СОБЛЮДЕНИЕ LSP: Защищенные методы для изменения поведения
class DataProcessor {
public:
    // Шаблонный метод - фиксированная структура
    void process() {
        if (!canProcess()) {
            throw std::runtime_error("Cannot process");
        }
        
        loadData();
        validateData();
        transformData();
        saveData();
    }
    
    virtual ~DataProcessor() = default;
    
protected:
    // Защищенные методы для настройки
    virtual bool canProcess() const { return true; }
    virtual void loadData() = 0;
    virtual void validateData() { /* базовая реализация */ }
    virtual void transformData() = 0;
    virtual void saveData() { /* базовая реализация */ }
};

class SafeDataProcessor : public DataProcessor {
protected:
    bool canProcess() const override {
        // Проверяем условия, но не меняем структуру process()
        return checkPermissions() && checkDiskSpace();
    }
    
    void validateData() override {
        // Усиливаем валидацию, но не нарушаем контракт
        DataProcessor::validateData();
        additionalValidation();
    }
    
private:
    bool checkPermissions() const { return true; }
    bool checkDiskSpace() const { return true; }
    void additionalValidation() { /* ... */ }
};
```

## Техники проверки соблюдения LSP

### 1. **Тест "является" (is-a)**
```cpp
// Спросите: "S является T?"
// Если ответ "да, но..." - вероятно нарушение LSP

// "Квадрат является прямоугольником?"
// Математически: да
// В программировании: нет, потому что квадрат меняет поведение

// "Пингвин является птицей?"
// Биологически: да
// В программировании: да, но не летающей птицей
// Нужно разделить интерфейсы!
```

### 2. **Тест подстановки**
```cpp
// Напишите функцию, которая работает с базовым классом
void useBase(Base& obj) {
    // Выполняем типичные операции
    obj.operation1();
    obj.operation2();
    
    // Проверяем инварианты
    assert(obj.invariantHolds());
}

// Теперь передайте в эту функцию объект подкласса
Derived derived;
useBase(derived);  // ✅ Если работает без ошибок - LSP соблюден
                   // ❌ Если есть ошибки или неожиданное поведение - нарушение
```

### 3. **Контрактное программирование**
```cpp
// Явно документируйте контракты
class Contract {
public:
    /**
     * @pre amount > 0 (предусловие)
     * @post balance >= 0 (постусловие)
     * @invariant balance >= minBalance (инвариант)
     */
    virtual void withdraw(double amount) = 0;
    
    // Теперь подклассы обязаны соблюдать эти контракты
};
```

## Последствия нарушения LSP

### 1. **Неожиданное поведение**
```cpp
// Код работает с базовым классом
std::vector<Base*> objects;
for (auto obj : objects) {
    obj->doSomething();  // ❌ Для некоторых подклассов поведение может быть другим
}
```

### 2. **Сложность отладки**
```cpp
// Нарушение LSP приводит к тонким багам
void process(Base* obj) {
    // Предполагаем определенное поведение
    obj->step1();
    obj->step2();  // ⚠️ Для Derived это может делать что-то другое!
    
    // Ошибка проявляется далеко от места вызова
}
```

### 3. **Нарушение принципа подстановки в стандартной библиотеке**
```cpp
// STL ожидает соблюдения LSP
std::vector<Animal*> zoo;
zoo.push_back(new Dog());
zoo.push_back(new Penguin());  // ⚠️ Проблема, если Penguin нарушает контракт Animal

for (auto animal : zoo) {
    animal->makeSound();  // Ожидаем, что все животные издают звук
    // Но что, если Penguin::makeSound() бросает исключение?
}
```

## Best Practices для соблюдения LSP

### 1. **Проектируйте для расширения, а не модификации**
```cpp
// ✅ Хорошо: Добавляем новые классы, а не меняем существующие
class Logger {
public:
    virtual void log(const std::string& message) = 0;
    virtual ~Logger() = default;
};

class FileLogger : public Logger { /* ... */ };
class DatabaseLogger : public Logger { /* ... */ };
class NetworkLogger : public Logger { /* ... */ };

// Можно добавить новый тип логгера без изменения кода, который использует Logger
```

### 2. **Избегайте наследования, если есть "но"**
```cpp
// Если вы говорите: "S является T, но..."
// Это признак, что наследование неподходящее

// "Окружность является эллипсом, но..."
// "Квадрат является прямоугольником, но..."
// "Пингвин является птицей, но..."

// В таких случаях используйте композицию или разделение интерфейсов
```

### 3. **Соблюдайте контракты методов**
```cpp
class ContractAware {
public:
    // Документируйте и соблюдайте:
    // 1. Что метод ожидает (предусловия)
    // 2. Что метод гарантирует (постусловия)
    // 3. Что остается неизменным (инварианты)
    
    /**
     * @pre index >= 0 && index < size()
     * @post возвращает элемент по указанному индексу
     * @invariant size() не изменяется
     */
    virtual int get(int index) const = 0;
};
```

## Как обнаружить нарушение LSP?

### Признаки "запаха кода":
1. **Подклассы переопределяют методы и выбрасывают исключения**
2. **Подклассы возвращают значения в другом диапазоне**
3. **Подклассы требуют дополнительных проверок типа (dynamic_cast)**
4. **Клиентский код содержит проверки типа объекта**
5. **Подклассы не поддерживают все методы базового класса**

### Практический тест:
```cpp
void testLSP(Base* base) {
    // Если вам нужно писать такой код - нарушение LSP:
    if (auto derived = dynamic_cast<Derived*>(base)) {
        // Особенная обработка для Derived
    } else {
        // Обычная обработка
    }
}
```

## Заключение

**LSP помогает создавать:**
- ✅ **Надежные системы** (подклассы не ломают ожидания)
- ✅ **Предсказуемые системы** (поведение объектов понятно)
- ✅ **Модульные системы** (компоненты можно свободно заменять)
- ✅ **Тестируемые системы** (легко писать unit-тесты)

**Ключевые принципы соблюдения LSP:**
1. **Подклассы не должны усиливать предусловия**
2. **Подклассы не должны ослаблять постусловия**
3. **Подклассы должны сохранять инварианты базового класса**
4. **Исторические ограничения должны соблюдаться**

**Помните:** Наследование должно означать "является" во всех смыслах, а не только в некоторых. Если подкласс не может полноценно заменить базовый класс во всех контекстах - это нарушение LSP. В таких случаях лучше использовать композицию или разделение интерфейсов.