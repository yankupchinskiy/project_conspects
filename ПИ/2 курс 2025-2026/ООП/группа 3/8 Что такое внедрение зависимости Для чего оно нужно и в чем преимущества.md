# Внедрение зависимостей (Dependency Injection, DI)

## Что такое внедрение зависимости?

**Внедрение зависимости** — это паттерн проектирования, при котором зависимости (сервисы, объекты) передаются классу извне, вместо того чтобы создаваться внутри него. Это реализация принципа инверсии зависимостей (Dependency Inversion Principle).

### Простой пример

**Без DI (плохо):**
```cpp
class UserService {
private:
    Database* db;
    Logger* logger;
    
public:
    UserService() {
        db = new MySQLDatabase();  // Жесткая привязка
        logger = new FileLogger();  // Жесткая привязка
    }
};
```

**С DI (хорошо):**
```cpp
class UserService {
private:
    IDatabase* db;
    ILogger* logger;
    
public:
    UserService(IDatabase* db, ILogger* logger)  // Зависимости внедряются
        : db(db), logger(logger) {}
};
```

## Для чего нужно внедрение зависимостей?

### 1. **Слабая связанность (Loose Coupling)**
```cpp
// Интерфейсы
class IDatabase {
public:
    virtual void save(const std::string& data) = 0;
    virtual ~IDatabase() = default;
};

class ILogger {
public:
    virtual void log(const std::string& message) = 0;
    virtual ~ILogger() = default;
};

// Реализации
class MySQLDatabase : public IDatabase { /* ... */ };
class PostgreSQLDatabase : public IDatabase { /* ... */ };

class FileLogger : public ILogger { /* ... */ };
class ConsoleLogger : public ILogger { /* ... */ };

// Сервис не зависит от конкретных реализаций
class OrderService {
private:
    IDatabase* db;
    ILogger* logger;
    
public:
    OrderService(IDatabase* db, ILogger* logger)
        : db(db), logger(logger) {}
    
    void processOrder(Order order) {
        db->save(order.toString());
        logger->log("Order processed");
    }
};

// Использование с разными реализациями
int main() {
    IDatabase* db = new PostgreSQLDatabase();
    ILogger* logger = new ConsoleLogger();
    
    OrderService service(db, logger);  // Внедряем зависимости
    service.processOrder(order);
    
    // Легко поменять реализации:
    // OrderService service(new MySQLDatabase(), new FileLogger());
}
```

### 2. **Упрощение тестирования**
```cpp
// Моки для тестов
class MockDatabase : public IDatabase {
public:
    void save(const std::string& data) override {
        savedData = data;  // Запоминаем для проверки
    }
    std::string savedData;
};

class MockLogger : public ILogger {
public:
    void log(const std::string& message) override {
        lastLog = message;  // Запоминаем для проверки
    }
    std::string lastLog;
};

// Тест
TEST(OrderServiceTest, ProcessOrder) {
    MockDatabase mockDb;
    MockLogger mockLogger;
    
    OrderService service(&mockDb, &mockLogger);
    Order order("123", 100.0);
    
    service.processOrder(order);
    
    // Проверяем, что зависимости были вызваны правильно
    ASSERT_EQ(mockDb.savedData, order.toString());
    ASSERT_EQ(mockLogger.lastLog, "Order processed");
}
```

### 3. **Гибкость конфигурации**
```cpp
// Фабрика или конфигуратор
class ApplicationConfig {
public:
    static IDatabase* createDatabase() {
        if (config::useMySQL) return new MySQLDatabase();
        if (config::usePostgreSQL) return new PostgreSQLDatabase();
        return new SQLiteDatabase();
    }
    
    static ILogger* createLogger() {
        if (config::logToFile) return new FileLogger();
        return new ConsoleLogger();
    }
};

// Сборка приложения
int main() {
    auto db = ApplicationConfig::createDatabase();
    auto logger = ApplicationConfig::createLogger();
    auto cache = ApplicationConfig::createCache();
    
    OrderService orderService(db, logger);
    UserService userService(db, cache);
    
    // Запуск приложения...
}
```

## Типы внедрения зависимостей

### 1. **Внедрение через конструктор (Constructor Injection) - наиболее предпочтительный**
```cpp
class PaymentProcessor {
private:
    IPaymentGateway* gateway;
    INotificationService* notifier;
    
public:
    // Все зависимости требуются при создании
    PaymentProcessor(IPaymentGateway* gateway, INotificationService* notifier)
        : gateway(gateway), notifier(notifier) {
        if (!gateway || !notifier) {
            throw std::invalid_argument("Dependencies cannot be null");
        }
    }
};
```

### 2. **Внедрение через сеттеры (Setter Injection)**
```cpp
class ReportGenerator {
private:
    IDataProvider* dataProvider = nullptr;
    IFormatter* formatter = nullptr;
    
public:
    // Зависимости могут быть установлены позже
    void setDataProvider(IDataProvider* provider) {
        dataProvider = provider;
    }
    
    void setFormatter(IFormatter* fmt) {
        formatter = fmt;
    }
    
    void generate() {
        if (!dataProvider || !formatter) {
            throw std::runtime_error("Dependencies not set");
        }
        // ...
    }
};
```

### 3. **Внедрение через интерфейс (Interface Injection)**
```cpp
// Интерфейс для классов, которым нужны зависимости
class IConfigurable {
public:
    virtual void configure(IDatabase* db, ILogger* logger) = 0;
    virtual ~IConfigurable() = default;
};

// Реализация
class UserManager : public IConfigurable {
private:
    IDatabase* db;
    ILogger* logger;
    
public:
    void configure(IDatabase* db, ILogger* logger) override {
        this->db = db;
        this->logger = logger;
    }
};
```

## DI-контейнеры (IoC-контейнеры)

### Пример простого контейнера
```cpp
class DIContainer {
private:
    std::map<std::string, std::function<void*()>> factories;
    
public:
    template<typename T>
    void registerFactory(std::function<T*()> factory) {
        factories[typeid(T).name()] = [factory]() -> void* {
            return static_cast<void*>(factory());
        };
    }
    
    template<typename T>
    T* resolve() {
        auto it = factories.find(typeid(T).name());
        if (it != factories.end()) {
            return static_cast<T*>(it->second());
        }
        return nullptr;
    }
};

// Использование
int main() {
    DIContainer container;
    
    // Регистрируем зависимости
    container.registerFactory<IDatabase>([]() {
        return static_cast<IDatabase*>(new MySQLDatabase());
    });
    
    container.registerFactory<ILogger>([]() {
        return static_cast<ILogger*>(new FileLogger());
    });
    
    // Разрешаем зависимости
    IDatabase* db = container.resolve<IDatabase>();
    ILogger* logger = container.resolve<ILogger>();
    
    OrderService service(db, logger);
}
```

## Преимущества DI

### 1. **Повышение тестируемости**
```cpp
// Без DI - сложно тестировать
class LegacyService {
private:
    RealDatabase db;  // Реальная БД
    RealSMTPClient smtp;  // Реальный SMTP
    
    void sendEmail() {
        smtp.connect("smtp.server.com", 25);  // Привязка к реальному серверу
        // Тест упадет без реального SMTP сервера
    }
};

// С DI - легко тестировать
class ModernService {
private:
    IDatabase* db;
    IEmailClient* email;
    
public:
    ModernService(IDatabase* db, IEmailClient* email) 
        : db(db), email(email) {}
    
    void sendEmail() {
        email->send("test@example.com", "Hello");  // Можно подменить
    }
};
```

### 2. **Упрощение рефакторинга**
```cpp
// Старая версия
class OldService {
private:
    MySQLDatabase db;  // Жесткая привязка
    // Если нужно поменять на PostgreSQL - меняем код
};

// Новая версия
class NewService {
private:
    IDatabase* db;  // Любая реализация
    
    // Чтобы поменять БД, достаточно изменить конфигурацию:
    // NewService service(new PostgreSQLDatabase(), ...);
};
```

### 3. **Управление жизненным циклом**
```cpp
// DI позволяет централизованно управлять объектами
class AppContainer {
private:
    std::unique_ptr<IDatabase> db;
    std::shared_ptr<ILogger> logger;
    std::vector<std::unique_ptr<IService>> services;
    
public:
    AppContainer() {
        // Singleton - один на все приложение
        db = std::make_unique<MySQLDatabase>();
        
        // Scoped - один на область видимости
        logger = std::make_shared<FileLogger>();
        
        // Transient - новый каждый раз
        services.push_back(std::make_unique<UserService>(db.get(), logger));
        services.push_back(std::make_unique<OrderService>(db.get(), logger));
    }
};
```

## Практические примеры

### Пример 1: **Веб-сервис с DI**
```cpp
// Интерфейсы
class IUserRepository {
public:
    virtual User findById(int id) = 0;
    virtual void save(const User& user) = 0;
    virtual ~IUserRepository() = default;
};

class IEmailService {
public:
    virtual void sendWelcomeEmail(const std::string& email) = 0;
    virtual ~IEmailService() = default;
};

// Сервис с DI
class UserRegistrationService {
private:
    IUserRepository* userRepo;
    IEmailService* emailService;
    
public:
    UserRegistrationService(IUserRepository* repo, IEmailService* email)
        : userRepo(repo), emailService(email) {}
    
    void registerUser(const std::string& email, const std::string& password) {
        User user(email, password);
        userRepo->save(user);
        emailService->sendWelcomeEmail(email);
    }
};
```

### Пример 2: **Игровой движок с DI**
```cpp
// Компоненты
class IPhysicsEngine {
public:
    virtual void update(float deltaTime) = 0;
    virtual ~IPhysicsEngine() = default;
};

class IRenderer {
public:
    virtual void render(const Scene& scene) = 0;
    virtual ~IRenderer() = default;
};

class IAudioSystem {
public:
    virtual void playSound(const std::string& soundId) = 0;
    virtual ~IAudioSystem() = default;
};

// Игровой движок
class GameEngine {
private:
    IPhysicsEngine* physics;
    IRenderer* renderer;
    IAudioSystem* audio;
    
public:
    GameEngine(IPhysicsEngine* physics, IRenderer* renderer, IAudioSystem* audio)
        : physics(physics), renderer(renderer), audio(audio) {}
    
    void update() {
        physics->update(0.016f);  // 60 FPS
        renderer->render(currentScene);
        // Легко тестировать без реальной графики/физики
    }
};
```

## Best Practices

### 1. **Используйте интерфейсы (абстрактные классы)**
```cpp
// Хорошо
class IService {
public:
    virtual void execute() = 0;
    virtual ~IService() = default;
};

// Плохо
class ConcreteService {  // Нет интерфейса
    void execute() { /* ... */ }
};
```

### 2. **Избегайте Service Locator (анти-паттерн)**
```cpp
// ❌ Плохо - скрытые зависимости
class BadService {
public:
    void doSomething() {
        auto db = ServiceLocator::getDatabase();  // Неявная зависимость
        // Тестировать сложно
    }
};

// ✅ Хорошо - явные зависимости
class GoodService {
private:
    IDatabase* db;
public:
    GoodService(IDatabase* db) : db(db) {}  // Явная зависимость
    void doSomething() {
        db->query();
    }
};
```

### 3. **Принцип единой ответственности (Single Responsibility)**
```cpp
// Каждый сервис делает одну вещь
class UserAuthenticator {
    // Только аутентификация
};

class UserProfileManager {
    // Только управление профилем
};

class UserNotifier {
    // Только уведомления
};
```

## Недостатки DI

### 1. **Сложность настройки**
```cpp
// Много boilerplate-кода
auto logger = std::make_shared<FileLogger>();
auto db = std::make_shared<MySQLDatabase>();
auto cache = std::make_shared<RedisCache>();
auto email = std::make_shared<SmtpEmailService>();

auto userService = std::make_shared<UserService>(
    db.get(), cache.get(), email.get()
);

auto orderService = std::make_shared<OrderService>(
    db.get(), logger.get(), email.get()
);

// Решение: использовать DI-контейнеры
```

### 2. **Сложность понимания**
- Новичкам трудно понять, откуда берутся зависимости
- Усложняет отладку

### 3. **Избыточность для простых случаев**
```cpp
// Для простых проектов DI может быть избыточным
class SimpleApp {
    // Иногда проще создавать зависимости напрямую
    FileLogger logger;  // Просто и понятно
};
```

## Современные DI-фреймворки для C++

### 1. **Boost.DI**
```cpp
#include <boost/di.hpp>
namespace di = boost::di;

class ILogger { /* ... */ };
class FileLogger : ILogger { /* ... */ };
class UserService {
public:
    UserService(ILogger& logger) {}
};

int main() {
    auto injector = di::make_injector(
        di::bind<ILogger>().to<FileLogger>()
    );
    
    auto userService = injector.create<UserService>();
}
```

### 2. **Fruit (Google)**
```cpp
#include <fruit/fruit.h>

fruit::Component<IUserService> getUserServiceComponent() {
    return fruit::createComponent()
        .bind<IDatabase, MySQLDatabase>()
        .bind<ILogger, FileLogger>()
        .install(getUserRepositoryComponent);
}
```

## Заключение

**Внедрение зависимостей дает:**

| Преимущество | Пример |
|-------------|--------|
| **Тестируемость** | Моки вместо реальных сервисов |
| **Гибкость** | Легкая замена реализаций |
| **Слабая связанность** | Зависимость от интерфейсов, а не реализаций |
| **Управление жизненным циклом** | Контроль над созданием объектов |
| **Читаемость** | Явные зависимости в конструкторе |

**Используйте DI когда:**
- Пишете тестируемый код
- Создаете библиотеки/фреймворки
- Разрабатываете сложные приложения
- Нужна гибкость конфигурации

**Не используйте DI когда:**
- Пишете простые скрипты
- Создаете throwaway-прототипы
- Производительность критична (минимальные накладные расходы)

**Золотое правило:** Используйте DI для бизнес-логики, но не обязательно для инфраструктурного кода или простых утилит.