# Выведение типов в шаблонах C++

## Что такое выведение типов в шаблонах?

**Выведение типов (template argument deduction)** — это механизм компилятора C++, который автоматически определяет типы шаблонных параметров на основе переданных аргументов функций или аргументов конструктора класса (CTAD).

## 1. Выведение типов в шаблонных функциях

### Базовый пример
```cpp
template<typename T>
void print(T value) {
    std::cout << value << std::endl;
}

int main() {
    print(42);        // T выводится как int
    print(3.14);      // T выводится как double
    print("Hello");   // T выводится как const char*
}
```

## Правила выведения типов

### Правило 1: **Выведение для параметров по значению**
```cpp
template<typename T>
void func(T param) {
    // param передается по значению
}

int main() {
    int x = 42;
    const int cx = x;
    const int& rx = x;
    
    func(x);   // T = int, param = int
    func(cx);  // T = int, const отбрасывается
    func(rx);  // T = int, ссылка отбрасывается
    func(42);  // T = int
    
    // Исключение: массивы и функции
    int arr[10];
    func(arr);  // T = int* (array-to-pointer decay)
    
    void someFunction();
    func(someFunction);  // T = void(*)() (function-to-pointer decay)
}
```

### Правило 2: **Выведение для параметров-ссылок**
```cpp
template<typename T>
void func(T& param) {
    // param передается по ссылке
}

int main() {
    int x = 42;
    const int cx = x;
    const int& rx = x;
    
    func(x);   // T = int, param = int&
    func(cx);  // T = const int, param = const int&
    func(rx);  // T = const int, param = const int&
    // func(42);  // Ошибка: нельзя передать rvalue в lvalue ссылку
}
```

### Правило 3: **Выведение для универсальных ссылок (T&&)**
```cpp
template<typename T>
void func(T&& param) {
    // param - универсальная ссылка
}

int main() {
    int x = 42;
    const int cx = x;
    const int& rx = x;
    
    func(x);   // x - lvalue => T = int&, param = int&
    func(cx);  // cx - const lvalue => T = const int&, param = const int&
    func(rx);  // rx - const lvalue ref => T = const int&, param = const int&
    func(42);  // 42 - rvalue => T = int, param = int&&
}
```

### Правило 4: **Выведение для параметров-указателей**
```cpp
template<typename T>
void func(T* param) {
    // param - указатель
}

int main() {
    int x = 42;
    const int* px = &x;
    int* const cpx = &x;
    
    func(&x);  // T = int, param = int*
    func(px);  // T = const int, param = const int*
    func(cpx); // T = int, param = int* (const отбрасывается)
}
```

## Особые случаи выведения

### 1. **Выведение для массивов**
```cpp
template<typename T, std::size_t N>
void processArray(T (&arr)[N]) {
    // T выводится как тип элемента массива
    // N выводится как размер массива
    std::cout << "Array size: " << N << std::endl;
}

template<typename T>
void processPointer(T* arr) {
    // T выводится как тип элемента
    // Размер теряется
}

int main() {
    int arr1[10];
    int arr2[5] = {1, 2, 3, 4, 5};
    
    processArray(arr1);  // T = int, N = 10
    processArray(arr2);  // T = int, N = 5
    
    processPointer(arr1);  // T = int
}
```

### 2. **Выведение для функций**
```cpp
void someFunction(int, double) {}

template<typename T>
void callFunction(T func) {
    func(10, 3.14);
}

template<typename Ret, typename... Args>
void callFunction2(Ret (*func)(Args...)) {
    // Выведение типов возвращаемого значения и аргументов
}

int main() {
    callFunction(someFunction);  // T = void(*)(int, double)
    callFunction2(someFunction); // Ret = void, Args = {int, double}
}
```

### 3. **Выведение для шаблонных шаблонных параметров**
```cpp
template<template<typename> class Container, typename T>
void processContainer(const Container<T>& container) {
    std::cout << "Container of type: " << typeid(T).name() << std::endl;
}

// Использование с deduction guides
template<typename T>
using MyVector = std::vector<T>;

int main() {
    std::vector<int> vec;
    // processContainer(vec);  // Не работает напрямую в C++17
    // Нужны дополнительные deduction guides
}
```

## 2. Class Template Argument Deduction (CTAD) - C++17

### Автоматическое выведение типов для классов
```cpp
// До C++17
std::pair<int, double> p1(42, 3.14);
std::vector<int> v1{1, 2, 3, 4, 5};

// С C++17
std::pair p2(42, 3.14);        // Выводит std::pair<int, double>
std::vector v2{1, 2, 3, 4, 5}; // Выводит std::vector<int>

// Работает с пользовательскими классами
template<typename T>
class MyContainer {
public:
    MyContainer(const T& value) : data(value) {}
private:
    T data;
};

int main() {
    MyContainer c1(42);      // Выводит MyContainer<int>
    MyContainer c2("hello"); // Выводит MyContainer<const char*>
}
```

### Deduction Guides (руководства по выведению)
```cpp
template<typename T>
class SmartPointer {
    T* ptr;
public:
    SmartPointer(T* p) : ptr(p) {}
    
    // Другие конструкторы...
};

// Deduction guide для конструктора от T*
template<typename T>
SmartPointer(T*) -> SmartPointer<T>;

// Deduction guide для конструктора от другого SmartPointer
template<typename U>
SmartPointer(SmartPointer<U>&) -> SmartPointer<U>;

int main() {
    int* raw = new int(42);
    SmartPointer sp1(raw);  // Использует guide для T* => SmartPointer<int>
    
    SmartPointer sp2(sp1);  // Использует guide для SmartPointer<U> => SmartPointer<int>
}
```

## Особенности и ограничения выведения типов

### 1. **Невозможность выведения части типов**
```cpp
template<typename T1, typename T2>
void func(T1 a, T2 b) {}

int main() {
    func<int>(3.14, 10);  // OK: T1 = int (явно), T2 = int (выведено)
    // func<>(3.14, 10);   // OK: оба типа выводятся
    // func<double>(3.14); // Ошибка: не могу вывести T2
}
```

### 2. **Несоответствия типов**
```cpp
template<typename T>
void func(T a, T b) {}

int main() {
    func(10, 20);      // OK: T = int
    // func(10, 3.14); // Ошибка: неоднозначность, T может быть int или double
    func<int>(10, 3.14); // OK: явное указание, 3.14 приводится к int
}
```

### 3. **Преобразования типов при выведении**
```cpp
template<typename T>
void func(const T& param) {}

int main() {
    int x = 42;
    const int cx = x;
    
    func(x);  // T = int (const не выводится для неконстантных ссылок)
    func(cx); // T = int (const в T не включается, так как param уже const T&)
    
    // Строковые литералы
    func("Hello");  // T = const char[6] (не const char*!)
}
```

### 4. **Выведение для default template arguments**
```cpp
template<typename T = int>
void func(T value = 0) {}

int main() {
    func();      // T = int (по умолчанию), value = 0
    func(3.14);  // T = double (выведено)
    func<int>(); // T = int (явно)
}
```

## Продвинутые техники выведения

### 1. **Выведение типов возвращаемого значения (C++14)**
```cpp
// C++14: auto с выводом типа
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

// C++14: упрощенный синтаксис
template<typename T, typename U>
auto multiply(T a, U b) {
    return a * b;  // Тип возврата выводится автоматически
}

int main() {
    auto result1 = add(10, 3.14);     // double
    auto result2 = multiply(2, 3.5);  // double
}
```

### 2. **Perfect forwarding с выведением типов**
```cpp
template<typename... Args>
auto make_unique(Args&&... args) -> std::unique_ptr<T> {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

// Фабричная функция с выведением типов
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

class Widget {
public:
    Widget(int, double, const std::string&) {}
};

int main() {
    auto widget = make_unique<Widget>(42, 3.14, "test");
    // Args выводится как {int, double, const char*}
}
```

### 3. **Выведение с SFINAE**
```cpp
// SFINAE (Substitution Failure Is Not An Error)
template<typename T>
auto process(T value) -> decltype(value.serialize(), void()) {
    // Этот вариант выбирается, если T имеет метод serialize()
    value.serialize();
}

template<typename T>
void process(T value) {
    // Запасной вариант для типов без serialize()
    std::cout << "Default processing" << std::endl;
}

class HasSerialize {
public:
    void serialize() const {
        std::cout << "Serializing..." << std::endl;
    }
};

int main() {
    HasSerialize obj1;
    process(obj1);  // Вызывается первая версия
    
    int obj2 = 42;
    process(obj2);  // Вызывается вторая версия
}
```

### 4. **Выведение в лямбда-выражениях (C++14)**
```cpp
// C++14: лямбда с auto параметрами
auto lambda = [](auto x, auto y) {
    return x + y;
};

int main() {
    auto result1 = lambda(10, 20);      // int
    auto result2 = lambda(3.14, 2.71);  // double
    auto result3 = lambda("Hello", " World");  // const char* + const char*
}
```

## Проблемы и решения

### Проблема 1: **Ссылки на массивы**
```cpp
template<typename T>
void process(T& param) {}

int main() {
    int arr[10] = {};
    process(arr);  // T = int[10], param = int(&)[10]
    
    // Как получить размер массива?
    std::cout << "Size: " << sizeof(arr)/sizeof(arr[0]) << std::endl;
}
```

### Решение: **Использование std::size (C++17)**
```cpp
template<typename T, std::size_t N>
void processArray(T (&arr)[N]) {
    std::cout << "Array size: " << N << std::endl;
    std::cout << "Using std::size: " << std::size(arr) << std::endl;
}
```

### Проблема 2: **Выведение для std::initializer_list**
```cpp
template<typename T>
void func(std::initializer_list<T> list) {}

int main() {
    func({1, 2, 3});        // OK: T = int
    // func({1, 2.5, 3});   // Ошибка: неоднозначный тип
    func<double>({1, 2.5, 3});  // OK: явное указание
}
```

### Проблема 3: **Выведение в перегруженных функциях**
```cpp
template<typename T>
void func(T a) {
    std::cout << "Template version" << std::endl;
}

void func(int a) {
    std::cout << "Non-template version" << std::endl;
}

int main() {
    func(10);    // Вызывается non-template версия (точное совпадение)
    func(10.0);  // Вызывается template версия (T = double)
    func<>(10);  // Явный вызов шаблона: T = int
}
```

## Концепты и выведение типов (C++20)

### Использование концептов для ограничения выведения
```cpp
// Без концептов
template<typename T>
requires std::integral<T>
void process(T value) {
    std::cout << "Integral: " << value << std::endl;
}

// С синтаксисом концептов
template<std::integral T>
void betterProcess(T value) {
    std::cout << "Integral: " << value << std::endl;
}

// Сокращенный синтаксис
void bestProcess(std::integral auto value) {
    std::cout << "Integral: " << value << std::endl;
}

int main() {
    process(42);      // OK: int является integral
    bestProcess(42);  // OK
    // process(3.14); // Ошибка: double не является integral
}
```

### Выведение с constrained auto
```cpp
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

Addable auto add(Addable auto a, Addable auto b) {
    return a + b;
}

int main() {
    auto r1 = add(10, 20);      // OK
    auto r2 = add(3.14, 2.71);  // OK
    // auto r3 = add("a", "b"); // Ошибка: строки не удовлетворяют концепту
}
```

## Таблица выведения типов

| Выражение | `template<typename T> void f(T param)` | `template<typename T> void f(T& param)` | `template<typename T> void f(T&& param)` |
|-----------|----------------------------------------|-----------------------------------------|------------------------------------------|
| `int x` | `T = int` | `T = int`, `param = int&` | `T = int&`, `param = int&` |
| `const int x` | `T = int` | `T = const int`, `param = const int&` | `T = const int&`, `param = const int&` |
| `const int& x` | `T = int` | `T = const int`, `param = const int&` | `T = const int&`, `param = const int&` |
| `int arr[10]` | `T = int*` | `T = int[10]`, `param = int(&)[10]` | `T = int(&)[10]`, `param = int(&)[10]` |
| `42` | `T = int` | Не компилируется | `T = int`, `param = int&&` |

## Best Practices

### 1. **Используйте auto для локальных переменных**
```cpp
auto x = 42;            // int
auto y = 3.14;          // double
auto z = std::vector{1, 2, 3};  // std::vector<int> (CTAD)
```

### 2. **Избегайте ненужных копий с auto& и const auto&**
```cpp
const auto& ref = expensiveFunction();  // Без копирования
auto& mutableRef = getMutableObject();  // Для модификации
```

### 3. **Используйте decltype для сложных выражений**
```cpp
template<typename Container>
auto getValue(const Container& c, size_t index) -> decltype(c[index]) {
    return c[index];  // Сохраняет тип возврата (включая ссылки)
}
```

### 4. **Явно указывайте типы когда нужно**
```cpp
std::vector<int> vec;  // Явный тип лучше чем auto здесь
auto size = vec.size();  // size_t выведен правильно
```

## Заключение

**Выведение типов в шаблонах — мощный механизм, который:**
- Уменьшает boilerplate код
- Повышает безопасность типов
- Позволяет писать более общий код
- Работает как с функциями, так и с классами (CTAD)

**Ключевые моменты:**
1. **Параметры по значению** теряют const и ссылки
2. **Параметры-ссылки** сохраняют const
3. **Универсальные ссылки** различают lvalue и rvalue
4. **CTAD (C++17)** выводит типы для классов
5. **Концепты (C++20)** ограничивают выводимые типы

**Помните:** Выведение типов следует правилам языка, а не интуиции. В сложных случаях проверяйте, что именно выводит компилятор, используя `typeid` или `decltype`.