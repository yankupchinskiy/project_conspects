# Принцип открытости/закрытости (Open/Closed Principle - OCP)

## Что такое OCP?

**OCP** — второй принцип SOLID, который гласит: *"Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации"*. Это означает, что мы можем добавлять новую функциональность, не изменяя существующий код.

## Основная идея

```cpp
// ❌ НАРУШЕНИЕ OCP: При добавлении новой фигуры нужно изменять код
class AreaCalculator {
public:
    double calculateTotalArea(const std::vector<Shape*>& shapes) {
        double total = 0;
        for (Shape* shape : shapes) {
            if (auto* circle = dynamic_cast<Circle*>(shape)) {
                total += 3.14 * circle->radius * circle->radius;
            } else if (auto* square = dynamic_cast<Square*>(shape)) {
                total += square->side * square->side;
            }
            // ⚠️ Для добавления треугольника нужно изменить этот метод!
        }
        return total;
    }
};
```

## Примеры нарушения OCP

### Пример 1: **Класс с жесткой логикой условий**
```cpp
// ❌ НАРУШЕНИЕ OCP: PaymentProcessor нужно изменять при добавлении нового способа оплаты
class PaymentProcessor {
public:
    enum PaymentType { CREDIT_CARD, PAYPAL, BANK_TRANSFER };
    
    void processPayment(PaymentType type, double amount) {
        switch (type) {
            case CREDIT_CARD:
                processCreditCard(amount);
                break;
            case PAYPAL:
                processPayPal(amount);
                break;
            case BANK_TRANSFER:
                processBankTransfer(amount);
                break;
            // ⚠️ При добавлении нового способа нужно:
            // 1. Добавить новый enum
            // 2. Добавить новый case
            // 3. Добавить новый метод обработки
        }
    }
    
private:
    void processCreditCard(double amount) {
        std::cout << "Processing credit card: $" << amount << std::endl;
        // Сложная логика обработки карты
    }
    
    void processPayPal(double amount) {
        std::cout << "Processing PayPal: $" << amount << std::endl;
        // Логика работы с PayPal API
    }
    
    void processBankTransfer(double amount) {
        std::cout << "Processing bank transfer: $" << amount << std::endl;
        // Логика банковского перевода
    }
};

// Использование
int main() {
    PaymentProcessor processor;
    processor.processPayment(PaymentProcessor::CREDIT_CARD, 100.0);
    
    // Проблема: для добавления ApplePay нужно менять существующий код!
    // processor.processPayment(PaymentProcessor::APPLE_PAY, 100.0); // Не скомпилируется
}
```

### Пример 2: **Отчеты с жесткой логикой генерации**
```cpp
// ❌ НАРУШЕНИЕ OCP: ReportGenerator нужно изменять для каждого нового формата
class ReportGenerator {
public:
    enum ReportType { PDF, EXCEL, HTML };
    
    void generateReport(ReportType type, const Data& data) {
        switch (type) {
            case PDF:
                generatePDF(data);
                break;
            case EXCEL:
                generateExcel(data);
                break;
            case HTML:
                generateHTML(data);
                break;
        }
    }
    
private:
    void generatePDF(const Data& data) {
        // Сложная логика генерации PDF
        std::cout << "Generating PDF report..." << std::endl;
    }
    
    void generateExcel(const Data& data) {
        // Логика генерации Excel
        std::cout << "Generating Excel report..." << std::endl;
    }
    
    void generateHTML(const Data& data) {
        // Логика генерации HTML
        std::cout << "Generating HTML report..." << std::endl;
    }
};

// Проблема: для добавления CSV отчета нужно:
// 1. Изменить enum ReportType
// 2. Добавить новый case в switch
// 3. Добавить новый метод generateCSV
// 4. Перекомпилировать весь код
```

### Пример 3: **Фильтрация с жесткими критериями**
```cpp
// ❌ НАРУШЕНИЕ OCP: ProductFilter нужно изменять для каждого нового критерия
class Product {
public:
    std::string name;
    std::string color;
    double price;
    Size size;
};

enum class Color { RED, GREEN, BLUE };
enum class Size { SMALL, MEDIUM, LARGE };

class ProductFilter {
public:
    // Для каждого нового критерия фильтрации нужно добавлять новый метод!
    std::vector<Product*> filterByColor(
        const std::vector<Product*>& products, 
        Color color) 
    {
        std::vector<Product*> result;
        for (auto& product : products) {
            if (product->color == color) {
                result.push_back(product);
            }
        }
        return result;
    }
    
    std::vector<Product*> filterBySize(
        const std::vector<Product*>& products, 
        Size size) 
    {
        std::vector<Product*> result;
        for (auto& product : products) {
            if (product->size == size) {
                result.push_back(product);
            }
        }
        return result;
    }
    
    std::vector<Product*> filterByColorAndSize(
        const std::vector<Product*>& products, 
        Color color, 
        Size size) 
    {
        std::vector<Product*> result;
        for (auto& product : products) {
            if (product->color == color && product->size == size) {
                result.push_back(product);
            }
        }
        return result;
    }
    
    // ⚠️ Проблема: комбинаций критериев растет экспоненциально!
    // Для 3 критериев нужно 7 методов (2^n - 1)
    // Для 4 критериев нужно 15 методов
    // Для 10 критериев нужно 1023 метода!
};

// Использование
int main() {
    Product apple{"Apple", Color::GREEN, 1.0, Size::SMALL};
    Product tree{"Tree", Color::GREEN, 10.0, Size::LARGE};
    Product house{"House", Color::BLUE, 100000.0, Size::LARGE};
    
    std::vector<Product*> products = {&apple, &tree, &house};
    
    ProductFilter filter;
    auto greenThings = filter.filterByColor(products, Color::GREEN);
    
    // Проблема: для фильтрации по цене нужно добавлять новый метод!
    // auto cheapThings = filter.filterByPrice(products, 50.0);
}
```

## Пример 4: **Уведомления с жесткой логикой отправки**
```cpp
// ❌ НАРУШЕНИЕ OCP: NotificationService нужно изменять при добавлении нового канала
class NotificationService {
public:
    enum Channel { EMAIL, SMS, PUSH };
    
    void sendNotification(Channel channel, const std::string& message, const User& user) {
        switch (channel) {
            case EMAIL:
                sendEmail(message, user.email);
                break;
            case SMS:
                sendSMS(message, user.phone);
                break;
            case PUSH:
                sendPush(message, user.deviceToken);
                break;
        }
    }
    
private:
    void sendEmail(const std::string& message, const std::string& email) {
        // Логика отправки email
        std::cout << "Sending email to " << email << ": " << message << std::endl;
    }
    
    void sendSMS(const std::string& message, const std::string& phone) {
        // Логика отправки SMS
        std::cout << "Sending SMS to " << phone << ": " << message << std::endl;
    }
    
    void sendPush(const std::string& message, const std::string& token) {
        // Логика отправки push-уведомления
        std::cout << "Sending push to device " << token << ": " << message << std::endl;
    }
};

// Проблема: для добавления Telegram уведомлений нужно:
// 1. Изменить enum Channel
// 2. Добавить новый case в switch
// 3. Добавить метод sendTelegram
// 4. Перекомпилировать и перетестировать весь код
```

## Как соблюдать OCP?

### Решение 1: **Полиморфизм и абстракции**
```cpp
// ✅ СОБЛЮДЕНИЕ OCP: Открыто для расширения через новые реализации
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual void processPayment(double amount) = 0;
};

class CreditCardPayment : public PaymentStrategy {
public:
    void processPayment(double amount) override {
        std::cout << "Processing credit card: $" << amount << std::endl;
        // Логика обработки карты
    }
};

class PayPalPayment : public PaymentStrategy {
public:
    void processPayment(double amount) override {
        std::cout << "Processing PayPal: $" << amount << std::endl;
        // Логика PayPal API
    }
};

class BankTransferPayment : public PaymentStrategy {
public:
    void processPayment(double amount) override {
        std::cout << "Processing bank transfer: $" << amount << std::endl;
        // Логика банковского перевода
    }
};

// ✅ Класс закрыт для модификации, открыт для расширения
class PaymentProcessor {
public:
    void processPayment(PaymentStrategy& strategy, double amount) {
        strategy.processPayment(amount);
    }
};

// Добавление нового способа оплаты БЕЗ изменения существующего кода:
class ApplePayPayment : public PaymentStrategy {
public:
    void processPayment(double amount) override {
        std::cout << "Processing Apple Pay: $" << amount << std::endl;
        // Новая логика Apple Pay
    }
};

// Использование
int main() {
    PaymentProcessor processor;
    
    CreditCardPayment ccPayment;
    processor.processPayment(ccPayment, 100.0);
    
    // Новый способ оплаты - без изменений в PaymentProcessor!
    ApplePayPayment applePay;
    processor.processPayment(applePay, 150.0);
}
```

### Решение 2: **Шаблон "Стратегия" (Strategy Pattern)**
```cpp
// ✅ СОБЛЮДЕНИЕ OCP: Фильтрация через стратегии
template<typename T>
class Specification {
public:
    virtual ~Specification() = default;
    virtual bool isSatisfied(T* item) const = 0;
};

template<typename T>
class Filter {
public:
    virtual std::vector<T*> filter(
        const std::vector<T*>& items,
        const Specification<T>& spec) const = 0;
};

// Конкретные спецификации (расширяем без модификации)
class ColorSpecification : public Specification<Product> {
    Color color;
public:
    explicit ColorSpecification(Color color) : color(color) {}
    
    bool isSatisfied(Product* item) const override {
        return item->color == color;
    }
};

class SizeSpecification : public Specification<Product> {
    Size size;
public:
    explicit SizeSpecification(Size size) : size(size) {}
    
    bool isSatisfied(Product* item) const override {
        return item->size == size;
    }
};

// Комбинированная спецификация (без модификации кода!)
template<typename T>
class AndSpecification : public Specification<T> {
    const Specification<T>& first;
    const Specification<T>& second;
public:
    AndSpecification(const Specification<T>& first, const Specification<T>& second)
        : first(first), second(second) {}
    
    bool isSatisfied(T* item) const override {
        return first.isSatisfied(item) && second.isSatisfied(item);
    }
};

// Конкретный фильтр
class BetterFilter : public Filter<Product> {
public:
    std::vector<Product*> filter(
        const std::vector<Product*>& items,
        const Specification<Product>& spec) const override 
    {
        std::vector<Product*> result;
        for (auto& item : items) {
            if (spec.isSatisfied(item)) {
                result.push_back(item);
            }
        }
        return result;
    }
};

// Использование
int main() {
    Product apple{"Apple", Color::GREEN, 1.0, Size::SMALL};
    Product tree{"Tree", Color::GREEN, 10.0, Size::LARGE};
    Product house{"House", Color::BLUE, 100000.0, Size::LARGE};
    
    std::vector<Product*> products = {&apple, &tree, &house};
    
    BetterFilter bf;
    ColorSpecification green(Color::GREEN);
    
    auto greenThings = bf.filter(products, green);
    
    // Комбинированный фильтр БЕЗ модификации кода!
    SizeSpecification large(Size::LARGE);
    AndSpecification<Product> greenAndLarge(green, large);
    
    auto greenLargeThings = bf.filter(products, greenAndLarge);
    
    // Добавление нового критерия БЕЗ изменения существующего кода:
    class PriceSpecification : public Specification<Product> {
        double maxPrice;
    public:
        explicit PriceSpecification(double maxPrice) : maxPrice(maxPrice) {}
        
        bool isSatisfied(Product* item) const override {
            return item->price <= maxPrice;
        }
    };
    
    PriceSpecification cheap(50.0);
    auto cheapThings = bf.filter(products, cheap);
}
```

### Решение 3: **Шаблон "Декоратор" (Decorator Pattern)**
```cpp
// ✅ СОБЛЮДЕНИЕ OCP: Расширение функциональности через декораторы
class Beverage {
public:
    virtual ~Beverage() = default;
    virtual std::string getDescription() const = 0;
    virtual double cost() const = 0;
};

// Базовый напиток
class Espresso : public Beverage {
public:
    std::string getDescription() const override {
        return "Espresso";
    }
    
    double cost() const override {
        return 1.99;
    }
};

// Декоратор (открыт для расширения)
class CondimentDecorator : public Beverage {
protected:
    std::unique_ptr<Beverage> beverage;
public:
    CondimentDecorator(std::unique_ptr<Beverage> beverage) 
        : beverage(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription();
    }
    
    double cost() const override {
        return beverage->cost();
    }
};

// Конкретные декораторы (расширяем без модификации кода)
class Milk : public CondimentDecorator {
public:
    Milk(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", Milk";
    }
    
    double cost() const override {
        return beverage->cost() + 0.20;
    }
};

class Mocha : public CondimentDecorator {
public:
    Mocha(std::unique_ptr<Beverage> beverage) 
        : CondimentDecorator(std::move(beverage)) {}
    
    std::string getDescription() const override {
        return beverage->getDescription() + ", Mocha";
    }
    
    double cost() const override {
        return beverage->cost() + 0.30;
    }
};

// Использование
int main() {
    // Базовый эспрессо
    auto espresso = std::make_unique<Espresso>();
    std::cout << espresso->getDescription() << " $" << espresso->cost() << std::endl;
    
    // Эспрессо с молоком (расширение без изменения кода)
    auto espressoWithMilk = std::make_unique<Milk>(std::move(espresso));
    std::cout << espressoWithMilk->getDescription() << " $" 
              << espressoWithMilk->cost() << std::endl;
    
    // Эспрессо с молоком и шоколадом (еще одно расширение)
    auto espressoWithMilkAndMocha = std::make_unique<Mocha>(std::move(espressoWithMilk));
    std::cout << espressoWithMilkAndMocha->getDescription() << " $" 
              << espressoWithMilkAndMocha->cost() << std::endl;
    
    // ✅ Добавляем новый декоратор БЕЗ изменения существующего кода:
    class WhippedCream : public CondimentDecorator {
    public:
        WhippedCream(std::unique_ptr<Beverage> beverage) 
            : CondimentDecorator(std::move(beverage)) {}
        
        std::string getDescription() const override {
            return beverage->getDescription() + ", Whipped Cream";
        }
        
        double cost() const override {
            return beverage->cost() + 0.15;
        }
    };
}
```

### Решение 4: **Шаблон "Наблюдатель" (Observer Pattern)**
```cpp
// ✅ СОБЛЮДЕНИЕ OCP: Добавление новых наблюдателей без изменения субъекта
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

class Subject {
private:
    std::vector<Observer*> observers;
    
public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }
    
    void detach(Observer* observer) {
        observers.erase(
            std::remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }
    
    void notify(const std::string& message) {
        for (Observer* observer : observers) {
            observer->update(message);
        }
    }
    
    // ✅ Класс закрыт для модификации: не нужно менять при добавлении наблюдателей
};

// Конкретные наблюдатели (расширяем систему)
class EmailNotifier : public Observer {
public:
    void update(const std::string& message) override {
        std::cout << "Sending email: " << message << std::endl;
    }
};

class SMSNotifier : public Observer {
public:
    void update(const std::string& message) override {
        std::cout << "Sending SMS: " << message << std::endl;
    }
};

// Использование
int main() {
    Subject orderSystem;
    
    EmailNotifier emailNotifier;
    SMSNotifier smsNotifier;
    
    orderSystem.attach(&emailNotifier);
    orderSystem.attach(&smsNotifier);
    
    orderSystem.notify("Order #123 created");
    
    // ✅ Добавляем нового наблюдателя БЕЗ изменения Subject:
    class PushNotifier : public Observer {
    public:
        void update(const std::string& message) override {
            std::cout << "Sending push notification: " << message << std::endl;
        }
    };
    
    PushNotifier pushNotifier;
    orderSystem.attach(&pushNotifier);
    orderSystem.notify("Order #123 shipped");
}
```

## Последствия нарушения OCP

### 1. **Хрупкость системы**
```cpp
// ❌ Изменение в одном месте ломает другие части
class OrderProcessor {
    // ...
    void processOrder(Order& order) {
        if (order.type == "REGULAR") {
            // Логика обычного заказа
        } else if (order.type == "EXPRESS") {
            // Логика экспресс-заказа
        } else if (order.type == "INTERNATIONAL") {
            // Логика международного заказа
            // ⚠️ Добавили новое условие - нужно перетестировать ВСЕ случаи!
        }
    }
};
```

### 2. **Сложность тестирования**
```cpp
// ❌ Каждое изменение требует перетестирования всего кода
class ReportSystem {
    // При добавлении нового типа отчета:
    // 1. Нужно протестировать новый функционал
    // 2. Нужно регрессионно тестировать старый функционал
    // 3. Риск сломать существующую логику
};
```

### 3. **Паралич разработки**
```cpp
// ❌ Разработчики боятся вносить изменения
class LegacySystem {
    // "Я лучше не буду добавлять эту фичу,
    // потому что придется менять 20 классов
    // и есть риск все сломать"
};
```

## Best Practices для соблюдения OCP

### 1. **Использовать абстракции**
```cpp
// ✅ Хорошо: Работаем через интерфейсы
class IShape {
public:
    virtual double area() const = 0;
    virtual ~IShape() = default;
};

class AreaCalculator {
public:
    double totalArea(const std::vector<IShape*>& shapes) {
        double total = 0;
        for (auto shape : shapes) {
            total += shape->area();  // Полиморфный вызов
        }
        return total;
    }
    // ✅ Не нужно менять при добавлении новых фигур
};
```

### 2. **Принцип инверсии зависимостей**
```cpp
// ✅ Хорошо: Зависим от абстракций
class ILogger {
public:
    virtual void log(const std::string& message) = 0;
    virtual ~ILogger() = default;
};

class Application {
private:
    ILogger& logger;  // Зависимость от абстракции
    
public:
    Application(ILogger& logger) : logger(logger) {}
    
    void run() {
        logger.log("Application started");
        // ...
    }
    // ✅ Можно подменить реализацию логгера без изменения Application
};
```

### 3. **Шаблонный метод**
```cpp
// ✅ Хорошо: Базовая реализация + хуки для расширения
class DataProcessor {
public:
    // Шаблонный метод - фиксированный алгоритм
    void process() {
        loadData();
        validateData();
        transformData();
        saveData();
    }
    
    virtual ~DataProcessor() = default;
    
protected:
    // Хуки для расширения (можно переопределить)
    virtual void loadData() {
        // Базовая реализация
        std::cout << "Loading data..." << std::endl;
    }
    
    virtual void validateData() {
        // Базовая реализация
        std::cout << "Validating data..." << std::endl;
    }
    
    virtual void transformData() = 0;  // Абстрактный - должен быть реализован
    
    virtual void saveData() {
        // Базовая реализация
        std::cout << "Saving data..." << std::endl;
    }
};

// Расширение без изменения базового класса
class CSVProcessor : public DataProcessor {
protected:
    void transformData() override {
        std::cout << "Transforming CSV data..." << std::endl;
    }
};

class JSONProcessor : public DataProcessor {
protected:
    void loadData() override {
        // Переопределяем только нужный шаг
        std::cout << "Loading JSON data..." << std::endl;
    }
    
    void transformData() override {
        std::cout << "Transforming JSON data..." << std::endl;
    }
};
```

## Как обнаружить нарушение OCP?

### Признаки "запаха кода":
1. **Большие switch/case или if/else цепочки**
2. **Частые изменения в одних и тех же классах**
3. **Классы, которые знают о многих других классах**
4. **Новые фичи требуют модификации существующего кода**
5. **Страх добавлять новую функциональность**

### Тест на соблюдение OCP:
```cpp
// Задайте вопросы:
class OCPTest {
    // 1. При добавлении новой функциональности нужно ли менять существующий код?
    // 2. Можно ли добавить новую фичу, создав только новые классы?
    // 3. Зависит ли высокоуровневый код от низкоуровневых деталей?
};
```

## Заключение

**OCP помогает создавать:**
- ✅ **Стабильные системы** (основной код не меняется)
- ✅ **Масштабируемые системы** (легко добавлять новую функциональность)
- ✅ **Тестируемые системы** (новый код не ломает старый)
- ✅ **Гибкие системы** (можно легко адаптировать к изменениям)

**Ключевые техники соблюдения OCP:**
1. **Абстракции и полиморфизм**
2. **Шаблоны проектирования** (Стратегия, Декоратор, Наблюдатель и др.)
3. **Зависимость от абстракций**, а не от конкретных реализаций
4. **Вынос изменчивой логики** в отдельные классы

**Помните:** Система, соответствующая OCP, позволяет добавлять новую функциональность, создавая новый код, а не изменяя старый. Это фундамент для создания поддерживаемых и расширяемых приложений.