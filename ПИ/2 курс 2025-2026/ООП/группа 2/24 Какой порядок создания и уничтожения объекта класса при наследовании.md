**Создание:**

1. Конструкторы виртуальных базовых классов
    
2. Конструкторы невиртуальных базовых классов
    
3. Конструкторы членов-данных
    
4. Конструктор производного класса
    

**Уничтожение** (обратный порядок):

1. Деструктор производного класса
    
2. Деструкторы членов-данных
    
3. Деструкторы невиртуальных базовых классов
    
4. Деструкторы виртуальных базовых классов


## Порядок создания и уничтожения объекта класса при наследовании

### Порядок Создания (Construction Order)

1. **Выделение памяти** для всего объекта
2. **Конструкторы базовых классов** (в порядке объявления)
3. **Конструкторы членов-объектов** (в порядке объявления в классе)
4. **Конструктор производного класса**

```cpp
class A {
public:
    A() { cout << "A constructor\n"; }
    ~A() { cout << "A destructor\n"; }
};

class B {
public:
    B() { cout << "B constructor\n"; }
    ~B() { cout << "B destructor\n"; }
};

class Member {
public:
    Member() { cout << "Member constructor\n"; }
    ~Member() { cout << "Member destructor\n"; }
};

class Derived : public A, public B {  // Порядок наследования важен!
private:
    Member m1;
    Member m2;
public:
    Derived() {
        cout << "Derived constructor\n";
    }
    ~Derived() {
        cout << "Derived destructor\n";
    }
};

/*
Создание объекта Derived d:
1. A constructor     (первый базовый класс)
2. B constructor     (второй базовый класс)
3. Member constructor (m1)
4. Member constructor (m2)
5. Derived constructor
*/
```

### Порядок Уничтожения (Destruction Order)

**Полностью обратный порядку создания:**

1. **Деструктор производного класса**
2. **Деструкторы членов-объектов** (в обратном порядке объявления)
3. **Деструкторы базовых классов** (в обратном порядке наследования)

```cpp
{
    Derived d;
    // При выходе из области видимости:
    // 1. Derived destructor
    // 2. Member destructor (m2)
    // 3. Member destructor (m1)
    // 4. B destructor
    // 5. A destructor
}
```

### Важные Особенности

#### 1. **Виртуальное наследование меняет порядок**
```cpp
class Base {
public:
    Base() { cout << "Base\n"; }
};

class A : virtual public Base {
public:
    A() { cout << "A\n"; }
};

class B : virtual public Base {
public:
    B() { cout << "B\n"; }
};

class Derived : public A, public B {
public:
    Derived() { cout << "Derived\n"; }
};

/*
Создание Derived:
1. Base (виртуальный базовый класс идёт первым)
2. A
3. B
4. Derived
*/
```

#### 2. **Конструкторы с параметрами**
```cpp
class Base {
public:
    Base(int x) { cout << "Base(" << x << ")\n"; }
};

class Derived : public Base {
public:
    // Базовый класс должен быть проинициализирован в списке инициализации
    Derived(int x, int y) : Base(x), extra(y) {
        cout << "Derived\n";
    }
private:
    int extra;
};
```

#### 3. **Исключения в конструкторах**
```cpp
class Base {
public:
    Base() { 
        cout << "Base\n";
        throw runtime_error("Base error");
    }
    ~Base() { cout << "~Base\n"; }
};

class Member {
public:
    Member() { 
        cout << "Member\n";
        throw runtime_error("Member error");
    }
    ~Member() { cout << "~Member\n"; }
};

class Derived : public Base {
    Member m;  // Если Base бросит исключение, m не будет сконструирован
public:
    Derived() { cout << "Derived\n"; }
    ~Derived() { cout << "~Derived\n"; }
};

/*
Если Base выбрасывает исключение:
- Base constructor (начало)
- Исключение!
- Деструкторы уже созданных объектов НЕ вызываются
- Память освобождается
*/
```

#### 4. **Виртуальные деструкторы**
```cpp
class Base {
public:
    Base() { cout << "Base constructor\n"; }
    virtual ~Base() { cout << "Base destructor\n"; }  // Виртуальный!
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor\n"; }
    ~Derived() override { cout << "Derived destructor\n"; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // Корректно вызовет Derived::~Derived(), затем Base::~Base()
}
```

#### 5. **Статические члены**
```cpp
class Base {
public:
    static int count;
    Base() { count++; }
    ~Base() { count--; }
};

int Base::count = 0;  // Инициализация ДО создания первого объекта

class Derived : public Base {
    static int derived_count;
public:
    Derived() { derived_count++; }
    ~Derived() { derived_count--; }
};

int Derived::derived_count = 0;
```

#### 6. **Множественное наследование с общим базовым классом**
```cpp
class Base {
public:
    Base() { cout << "Base\n"; }
};

class A : public Base {
public:
    A() { cout << "A\n"; }
};

class B : public Base {
public:
    B() { cout << "B\n"; }
};

class Derived : public A, public B {
public:
    Derived() { cout << "Derived\n"; }
};

/*
Создание Derived:
1. Base (для A)
2. A
3. Base (для B)  - ДВЕ разные копии Base!
4. B
5. Derived
*/
```

#### 7. **Вызов виртуальных методов в конструкторах/деструкторах**
```cpp
class Base {
public:
    Base() { 
        cout << "Base constructor, calling virtual: ";
        virtualMethod();  // Всегда Base::virtualMethod()
    }
    virtual ~Base() {
        cout << "Base destructor, calling virtual: ";
        virtualMethod();  // Всегда Base::virtualMethod()
    }
    virtual void virtualMethod() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor\n"; }
    ~Derived() { cout << "Derived destructor\n"; }
    void virtualMethod() override { cout << "Derived\n"; }
};

/*
Создание Derived:
Base constructor, calling virtual: Base
Derived constructor

Уничтожение:
Derived destructor
Base destructor, calling virtual: Base
*/
```

### Полный Пример с Всеми Особенностями

```cpp
class Global {
public:
    Global() { cout << "Global init\n"; }
    ~Global() { cout << "Global cleanup\n"; }
} globalObj;  // Создаётся до main(), уничтожается после

class Base1 {
public:
    Base1() { cout << "Base1\n"; }
    virtual ~Base1() { cout << "~Base1\n"; }
};

class Base2 {
public:
    Base2() { cout << "Base2\n"; }
    virtual ~Base2() { cout << "~Base2\n"; }
};

class Member {
public:
    Member() { cout << "Member\n"; }
    ~Member() { cout << "~Member\n"; }
};

class Derived : public Base1, public Base2 {
    Member m1;
    static Member staticMember;  // Не влияет на порядок создания объекта
    Member m2;
public:
    Derived() { cout << "Derived\n"; }
    ~Derived() { cout << "~Derived\n"; }
};

Member Derived::staticMember;  // Инициализируется при запуске программы

int main() {
    cout << "=== Start main ===\n";
    {
        Derived d;
        cout << "=== Leaving scope ===\n";
    }
    cout << "=== End main ===\n";
    return 0;
}

/*
Примерный вывод:
Global init
Member (для staticMember)
=== Start main ===
Base1
Base2
Member (m1)
Member (m2)
Derived
=== Leaving scope ===
~Derived
~Member (m2)
~Member (m1)
~Base2
~Base1
=== End main ===
~Member (staticMember)
Global cleanup
*/
```

## Ключевые Правила

1. **Конструкторы**: От базовых к производным, члены в порядке объявления
2. **Деструкторы**: От производных к базовым, члены в обратном порядке
3. **Виртуальные базовые классы** создаются первыми
4. **Статические члены** инициализируются до `main()` 
5. **Глобальные объекты** создаются до `main()`, уничтожаются после
6. **Исключение в конструкторе** → деструкторы уже созданных объектов не вызываются
7. **Виртуальные методы в конструкторе/деструкторе** ведут себя как невиртуальные

## Практические Рекомендации

1. **Всегда делайте деструкторы виртуальными** в базовых классах
2. **Инициализируйте базовые классы в списке инициализации** в правильном порядке
3. **Избегайте вызовов виртуальных методов** в конструкторах и деструкторах
4. **Используйте умные указатели** для автоматического управления временем жизни
5. **Следите за порядком объявления членов** — он влияет на порядок инициализации

```cpp
// Правильный паттерн
class SafeBase {
public:
    virtual ~SafeBase() = default;  // Виртуальный деструктор
protected:
    SafeBase() { /* безопасная инициализация */ }
};
```