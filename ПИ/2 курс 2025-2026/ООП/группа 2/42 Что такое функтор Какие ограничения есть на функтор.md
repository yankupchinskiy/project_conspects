# **Функторы в C++**

## **Что такое функтор?**

**Функтор (functor, function object)** — это объект, который можно использовать как функцию. В C++ это достигается перегрузкой оператора круглых скобок `operator()`.

### **Базовый пример функтора**
```cpp
#include <iostream>

// Класс-функтор
class Adder {
    int value;  // Состояние функтора
public:
    Adder(int v) : value(v) {}
    
    // Перегрузка оператора вызова функции
    int operator()(int x) const {
        return x + value;
    }
};

int main() {
    Adder add5(5);     // Создаем функтор, добавляющий 5
    Adder add10(10);   // Функтор, добавляющий 10
    
    std::cout << add5(3) << std::endl;   // 8 (3 + 5)
    std::cout << add10(3) << std::endl;  // 13 (3 + 10)
    
    // Можно использовать в алгоритмах STL
    std::cout << add5.operator()(3) << std::endl;  // То же что и add5(3)
    
    return 0;
}
```

## **Преимущества функторов перед обычными функциями**

### **1. Состояние (State)**
Функторы могут хранить состояние между вызовами.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

class Counter {
    int count;
public:
    Counter() : count(0) {}
    
    int operator()(int x) {
        count++;
        return x + count;
    }
    
    int get_count() const { return count; }
};

int main() {
    Counter counter;
    
    std::cout << counter(10) << std::endl;  // 11 (10 + 1)
    std::cout << counter(10) << std::endl;  // 12 (10 + 2)
    std::cout << counter(10) << std::endl;  // 13 (10 + 3)
    
    std::cout << "Всего вызовов: " << counter.get_count() << std::endl;
    
    return 0;
}
```

### **2. Шаблонные функторы**
```cpp
#include <iostream>

// Шаблонный функтор
template<typename T>
class Multiplier {
    T factor;
public:
    Multiplier(T f) : factor(f) {}
    
    template<typename U>
    auto operator()(U value) const -> decltype(value * factor) {
        return value * factor;
    }
};

int main() {
    Multiplier<int> mult_int(2);
    Multiplier<double> mult_double(2.5);
    
    std::cout << mult_int(5) << std::endl;       // 10 (int)
    std::cout << mult_double(5) << std::endl;    // 12.5 (double)
    std::cout << mult_int(3.14) << std::endl;    // 6.28 (double)
    
    return 0;
}
```

## **Типы функторов в C++**

### **1. Пользовательские классы с operator()**
```cpp
class Square {
public:
    int operator()(int x) const {
        return x * x;
    }
};

// Использование
Square square;
std::cout << square(5) << std::endl;  // 25
```

### **2. Структуры как функторы (все члены public по умолчанию)**
```cpp
struct Comparator {
    bool operator()(int a, int b) const {
        return a < b;
    }
};

// Использование
Comparator comp;
std::cout << std::boolalpha << comp(3, 5) << std::endl;  // true
```

### **3. Функторы с несколькими версиями operator()**
```cpp
class OverloadedFunctor {
public:
    // Версия для int
    int operator()(int x) const {
        return x * 2;
    }
    
    // Версия для double
    double operator()(double x) const {
        return x * 3.14;
    }
    
    // Версия для строки
    std::string operator()(const std::string& s) const {
        return s + " processed";
    }
};

int main() {
    OverloadedFunctor func;
    
    std::cout << func(5) << std::endl;           // 10
    std::cout << func(2.5) << std::endl;         // 7.85
    std::cout << func("Hello") << std::endl;     // "Hello processed"
    
    return 0;
}
```

## **Функторы в стандартной библиотеке C++**

### **1. Стандартные функторы из Functional
```c++
#include <functional>
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
    // Арифметические функторы
    std::plus<int> add;
    std::minus<int> subtract;
    std::multiplies<int> multiply;
    std::divides<int> divide;
    std::modulus<int> modulo;
    std::negate<int> negate;
    
    std::cout << add(10, 5) << std::endl;        // 15
    std::cout << subtract(10, 5) << std::endl;   // 5
    std::cout << multiply(10, 5) << std::endl;   // 50
    
    // Сравнения
    std::equal_to<int> equals;
    std::not_equal_to<int> not_equals;
    std::greater<int> greater;
    std::less<int> less;
    
    std::cout << std::boolalpha << equals(5, 5) << std::endl;    // true
    std::cout << greater(10, 5) << std::endl;                    // true
    
    // Логические
    std::logical_and<bool> and_op;
    std::logical_or<bool> or_op;
    std::logical_not<bool> not_op;
    
    std::cout << and_op(true, false) << std::endl;  // false
    std::cout << or_op(true, false) << std::endl;   // true
    
    // Использование в алгоритмах
    std::vector<int> numbers = {5, 2, 8, 1, 9};
    std::sort(numbers.begin(), numbers.end(), std::greater<int>());
    
    for (int n : numbers) {
        std::cout << n << " ";  // 9 8 5 2 1
    }
    std::cout << std::endl;
    
    return 0;
}
```

### **2. Функторы-адаптеры**
```cpp
#include <functional>
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Связывание аргументов (bind)
    using namespace std::placeholders;  // для _1, _2, ...
    
    // bind создает новый функтор
    auto is_greater_than_5 = std::bind(std::greater<int>(), _1, 5);
    auto multiply_by_3 = std::bind(std::multiplies<int>(), _1, 3);
    
    std::cout << is_greater_than_5(10) << std::endl;  // true
    std::cout << multiply_by_3(7) << std::endl;       // 21
    
    // Отрицание
    auto is_not_greater_than_5 = std::not1(std::bind2nd(std::greater<int>(), 5));
    
    // Мемоизация (C++11 - нет в стандартной библиотеке, но можно реализовать)
    
    return 0;
}
```

## **Ограничения и особенности функторов**

### **1. Ограничения на оператор вызова**
```cpp
class ProblematicFunctor {
public:
    // operator() МОЖЕТ быть перегружен:
    int operator()(int x) { return x; }
    double operator()(double x) { return x; }
    
    // НО нельзя определить оператор с разными возвращаемыми типами
    // при одинаковых параметрах:
    // double operator()(int x) { return x * 1.0; }  // Ошибка компиляции!
    
    // Можно использовать шаблонный метод:
    template<typename T>
    T operator()(T x) { return x; }  // Это работает
};
```

### **2. Неявные преобразования**
```cpp
class StringConverter {
public:
    // Проблема: неявное преобразование в указатель на функцию
    operator int(*)(int)() {
        return [](int x) { return x * 2; };
    }
    
    int operator()(int x) {
        return x * 3;
    }
};

int main() {
    StringConverter conv;
    
    int result1 = conv(5);  // Вызов operator() - 15
    
    // Неявное преобразование может привести к неожиданностям
    // int (*func_ptr)(int) = conv;  // Преобразование в указатель на функцию
    // int result2 = func_ptr(5);    // 10 (а не 15!)
    
    return 0;
}
```

### **3. Время жизни и копирование**
```cpp
class ResourceHolder {
    int* resource;
public:
    ResourceHolder() : resource(new int(42)) {
        std::cout << "Ресурс создан" << std::endl;
    }
    
    ~ResourceHolder() {
        delete resource;
        std::cout << "Ресурс уничтожен" << std::endl;
    }
    
    // Правило трех/пяти
    ResourceHolder(const ResourceHolder& other) 
        : resource(new int(*other.resource)) {
        std::cout << "Ресурс скопирован" << std::endl;
    }
    
    ResourceHolder& operator=(const ResourceHolder& other) {
        if (this != &other) {
            delete resource;
            resource = new int(*other.resource);
            std::cout << "Ресурс присвоен" << std::endl;
        }
        return *this;
    }
    
    int operator()() const {
        return *resource;
    }
};

int main() {
    {
        ResourceHolder func1;
        std::cout << func1() << std::endl;  // 42
        
        // Копирование функтора
        auto func2 = func1;  // Вызывается конструктор копирования
        std::cout << func2() << std::endl;  // 42
    }  // Деструкторы вызываются для func2 и func1
    
    return 0;
}
```

### **4. Производительность**
```cpp
#include <chrono>
#include <iostream>
#include <functional>

// Простая функция
int add_function(int a, int b) {
    return a + b;
}

// Функтор
struct AddFunctor {
    int operator()(int a, int b) const {
        return a + b;
    }
};

void benchmark() {
    const int iterations = 100000000;
    
    // 1. Указатель на функцию
    auto start1 = std::chrono::high_resolution_clock::now();
    int (*func_ptr)(int, int) = add_function;
    for (int i = 0; i < iterations; ++i) {
        volatile int result = func_ptr(i, i + 1);
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 2. Функтор
    auto start2 = std::chrono::high_resolution_clock::now();
    AddFunctor functor;
    for (int i = 0; i < iterations; ++i) {
        volatile int result = functor(i, i + 1);
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    // 3. std::function
    auto start3 = std::chrono::high_resolution_clock::now();
    std::function<int(int, int)> std_func = add_function;
    for (int i = 0; i < iterations; ++i) {
        volatile int result = std_func(i, i + 1);
    }
    auto end3 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    auto duration3 = std::chrono::duration_cast<std::chrono::milliseconds>(end3 - start3);
    
    std::cout << "Указатель на функцию: " << duration1.count() << "ms\n";
    std::cout << "Функтор: " << duration2.count() << "ms\n";
    std::cout << "std::function: " << duration3.count() << "ms\n";
}
```

## **Функторы vs Лямбда-выражения**

### **Сравнение синтаксиса**
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

// 1. Функтор
struct GreaterThan {
    int threshold;
    GreaterThan(int t) : threshold(t) {}
    
    bool operator()(int x) const {
        return x > threshold;
    }
};

// 2. Лямбда (с захватом)
auto make_greater_than_lambda(int threshold) {
    return [threshold](int x) { return x > threshold; };
}

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int threshold = 5;
    
    // Использование функтора
    GreaterThan gt5(threshold);
    auto it1 = std::find_if(numbers.begin(), numbers.end(), gt5);
    
    // Использование лямбды
    auto it2 = std::find_if(numbers.begin(), numbers.end(),
                           [threshold](int x) { return x > threshold; });
    
    // Лямбда с захватом по ссылке
    int counter = 0;
    std::for_each(numbers.begin(), numbers.end(),
                  [&counter, threshold](int x) {
                      if (x > threshold) counter++;
                  });
    
    std::cout << "Элементов больше " << threshold << ": " << counter << std::endl;
    
    // Функтор с состоянием
    class CounterFunctor {
        int& count;
        int threshold;
    public:
        CounterFunctor(int& c, int t) : count(c), threshold(t) {}
        
        void operator()(int x) {
            if (x > threshold) count++;
        }
    };
    
    int counter2 = 0;
    CounterFunctor cf(counter2, threshold);
    std::for_each(numbers.begin(), numbers.end(), cf);
    
    return 0;
}
```

### **Что происходит с лямбдой под капотом**
```cpp
// Лямбда:
auto lambda = [threshold](int x) { return x > threshold; };

// Преобразуется компилятором примерно в:
class __lambda_anonymous {
    int threshold;  // Захваченная переменная
public:
    __lambda_anonymous(int t) : threshold(t) {}
    
    bool operator()(int x) const {
        return x > threshold;
    }
};

// И использование:
__lambda_anonymous lambda(threshold);
```

## **Ограничения функторов**

### **1. Нет автоматического выведения типа возвращаемого значения**
```cpp
// У лямбды есть auto для возвращаемого типа
auto lambda = [](int x, int y) { return x + y; };  // Тип выводится

// У функтора нужно явно указать
struct Adder {
    // Нельзя использовать auto здесь (до C++14 в методах класса)
    int operator()(int x, int y) const {  // Явно int
        return x + y;
    }
    
    // C++14: можно в методах класса с decltype(auto)
    decltype(auto) operator()(auto x, auto y) const {
        return x + y;
    }
};
```

### **2. Более многословный синтаксис**
```cpp
// Лямбда: кратко и на месте
std::sort(vec.begin(), vec.end(), [](auto a, auto b) { return a < b; });

// Функтор: нужно определить отдельный класс
struct Less {
    bool operator()(auto a, auto b) const { return a < b; }
};
std::sort(vec.begin(), vec.end(), Less{});
```

### **3. Ограничения на захват контекста**
```cpp
int x = 5, y = 10;

// Лямбда легко захватывает переменные
auto lambda = [x, &y]() { return x + y; };

// Функтор должен явно хранить захваченные значения
class Functor {
    int x_copy;
    int& y_ref;
public:
    Functor(int x, int& y) : x_copy(x), y_ref(y) {}
    
    int operator()() const { return x_copy + y_ref; }
};

Functor func(x, y);
```

### **4. Невозможность создания на лету в сложных случаях**
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> data = {{1, "one"}, {2, "two"}, {3, "three"}};
    
    // Лямбда может быть определена прямо в вызове
    auto it = std::find_if(data.begin(), data.end(),
                          [](const auto& pair) {
                              return pair.second.find('t') != std::string::npos;
                          });
    
    // Для функтора нужно предварительное определение
    struct ContainsT {
        bool operator()(const std::pair<int, std::string>& pair) const {
            return pair.second.find('t') != std::string::npos;
        }
    };
    
    auto it2 = std::find_if(data.begin(), data.end(), ContainsT{});
    
    if (it != data.end()) {
        std::cout << "Найдено: " << it->second << std::endl;
    }
    
    return 0;
}
```

### **5. Проблемы с перегрузкой operator() для разных категорий значений**
```cpp
#include <iostream>

// Функтор с разными версиями operator()
class Processor {
public:
    // Для l-value
    void operator()(int& x) const {
        x *= 2;
        std::cout << "Обработано l-value: " << x << std::endl;
    }
    
    // Для r-value
    void operator()(int&& x) const {
        std::cout << "Обработано r-value: " << x << std::endl;
    }
    
    // Для const l-value
    void operator()(const int& x) const {
        std::cout << "Обработано const l-value: " << x << std::endl;
    }
};

// Лямбда с универсальной ссылкой (auto&&)
auto lambda_processor = [](auto&& x) {
    using T = decltype(x);
    if constexpr (std::is_lvalue_reference_v<T>) {
        if constexpr (std::is_const_v<std::remove_reference_t<T>>) {
            std::cout << "Лямбда: const l-value" << std::endl;
        } else {
            std::cout << "Лямбда: l-value" << std::endl;
        }
    } else {
        std::cout << "Лямбда: r-value" << std::endl;
    }
};

int main() {
    Processor proc;
    int a = 5;
    const int b = 10;
    
    proc(a);           // Обработано l-value: 10
    proc(20);          // Обработано r-value: 20
    proc(b);           // Обработано const l-value: 10
    
    lambda_processor(a);           // Лямбда: l-value
    lambda_processor(20);          // Лямбда: r-value
    lambda_processor(b);           // Лямбда: const l-value
    lambda_processor(std::move(a)); // Лямбда: r-value
    
    return 0;
}
```

## **Когда использовать функторы вместо лямбд?**

### **1. Для сложного состояния**
```cpp
class StatisticsCalculator {
    double sum = 0;
    double sum_squares = 0;
    int count = 0;
    
public:
    void operator()(double value) {
        sum += value;
        sum_squares += value * value;
        count++;
    }
    
    double mean() const { return count > 0 ? sum / count : 0; }
    double variance() const {
        return count > 0 ? (sum_squares / count) - (mean() * mean()) : 0;
    }
};

int main() {
    std::vector<double> data = {1.0, 2.0, 3.0, 4.0, 5.0};
    StatisticsCalculator stats;
    
    std::for_each(data.begin(), data.end(), std::ref(stats));
    
    std::cout << "Среднее: " << stats.mean() << std::endl;
    std::cout << "Дисперсия: " << stats.variance() << std::endl;
    
    return 0;
}
```

### **2. Для шаблонных стратегий**
```cpp
// Политика сравнения
template<typename Comparator>
class SortedContainer {
    std::vector<int> data;
    Comparator comp;
    
public:
    void insert(int value) {
        data.push_back(value);
        std::sort(data.begin(), data.end(), comp);
    }
    
    void print() const {
        for (int val : data) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    }
};

// Разные функторы-компараторы
struct Ascending {
    bool operator()(int a, int b) const { return a < b; }
};

struct Descending {
    bool operator()(int a, int b) const { return a > b; }
};

int main() {
    SortedContainer<Ascending> ascending_container;
    SortedContainer<Descending> descending_container;
    
    for (int i = 1; i <= 5; ++i) {
        ascending_container.insert(i);
        descending_container.insert(i);
    }
    
    std::cout << "По возрастанию: ";
    ascending_container.print();  // 1 2 3 4 5
    
    std::cout << "По убыванию: ";
    descending_container.print();  // 5 4 3 2 1
    
    return 0;
}
```

### **3. Когда нужны виртуальные функции**
```cpp
#include <iostream>
#include <memory>
#include <vector>

// Базовый класс функтора
class Operation {
public:
    virtual ~Operation() = default;
    virtual int execute(int a, int b) const = 0;
};

// Конкретные операции
class Add : public Operation {
public:
    int execute(int a, int b) const override {
        return a + b;
    }
};

class Multiply : public Operation {
public:
    int execute(int a, int b) const override {
        return a * b;
    }
};

class Calculator {
    std::vector<std::unique_ptr<Operation>> operations;
    
public:
    void add_operation(std::unique_ptr<Operation> op) {
        operations.push_back(std::move(op));
    }
    
    void calculate_all(int a, int b) const {
        for (const auto& op : operations) {
            std::cout << "Результат: " << op->execute(a, b) << std::endl;
        }
    }
};

int main() {
    Calculator calc;
    
    calc.add_operation(std::make_unique<Add>());
    calc.add_operation(std::make_unique<Multiply>());
    
    calc.calculate_all(5, 3);
    // Результат: 8 (5 + 3)
    // Результат: 15 (5 * 3)
    
    return 0;
}
```

## **Практический пример: Кэширующий функтор**
```cpp
#include <iostream>
#include <unordered_map>
#include <functional>

// Функтор с кэшированием (мемоизация)
template<typename Func>
class Memoizer {
    Func func;
    mutable std::unordered_map<int, int> cache;  // Простой кэш для int->int
    
public:
    Memoizer(Func f) : func(f) {}
    
    int operator()(int x) const {
        // Проверяем кэш
        auto it = cache.find(x);
        if (it != cache.end()) {
            std::cout << "Кэш попадание для " << x << std::endl;
            return it->second;
        }
        
        // Вычисляем и кэшируем
        std::cout << "Вычисление для " << x << std::endl;
        int result = func(x);
        cache[x] = result;
        return result;
    }
    
    void clear_cache() {
        cache.clear();
    }
};

// Рекурсивная функция Фибоначчи
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    // Создаем кэширующий функтор
    Memoizer<decltype(&fibonacci)> memo_fib(fibonacci);
    
    std::cout << "fib(10) = " << memo_fib(10) << std::endl;
    std::cout << "fib(10) = " << memo_fib(10) << std::endl;  // Из кэша
    std::cout << "fib(5) = " << memo_fib(5) << std::endl;    // Из кэша
    std::cout << "fib(15) = " << memo_fib(15) << std::endl;  // Вычисление
    
    return 0;
}
```

## **Вывод**

**Функторы в C++** — это мощная абстракция, которая:
1. **Позволяет объектам вести себя как функции**
2. **Может хранить состояние** между вызовами
3. **Поддерживает полиморфизм** через наследование
4. **Работает с шаблонами** для создания гибких компонентов

**Ограничения функторов:**
1. **Более многословный синтаксис** по сравнению с лямбдами
2. **Нет автоматического захвата контекста**
3. **Требуют явного определения класса/структуры**
4. **Ограниченная поддержка автоматического выведения типов**

**Когда использовать функторы:**
1. **Сложное состояние**, требующее методов доступа
2. **Шаблонные стратегии** и политики
3. **Полиморфное поведение** через наследование
4. **Повторно используемая логика** в нескольких местах

**Когда предпочесть лямбды:**
1. **Простые одноразовые операции**
2. **Захват контекста** на лету
3. **Алгоритмы STL** с простыми предикатами
4. **Callback-функции** с короткой логикой

Функторы остаются важной частью C++, особенно в шаблонном метапрограммировании и при проектировании библиотек, где важны гибкость и производительность.