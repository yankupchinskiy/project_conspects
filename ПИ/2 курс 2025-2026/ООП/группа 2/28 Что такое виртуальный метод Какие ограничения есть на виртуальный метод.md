## Виртуальный метод

**Виртуальный метод** - это метод класса, который может быть переопределён в производных классах. Вызов виртуального метода разрешается динамически во время выполнения через механизм виртуальных таблиц (vtable).

```cpp
class Animal {
public:
    virtual void speak() {  // Виртуальный метод
        cout << "Some sound" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {  // Переопределение виртуального метода
        cout << "Woof!" << endl;
    }
};

int main() {
    Animal* animal = new Dog();
    animal->speak();  // Вызовет Dog::speak() благодаря виртуальности
    // Вывод: "Woof!"
}
```

## Ограничения виртуальных методов

### 1. **Не могут быть шаблонными (template)**
```cpp
class Base {
public:
    template<typename T>
    virtual void process(T value) { } // ОШИБКА: виртуальный метод не может быть шаблоном
};
```

### 2. **Не могут быть конструкторами**
```cpp
class Base {
public:
    virtual Base() { } // ОШИБКА: конструктор не может быть виртуальным
};
```

### 3. **Не могут быть статическими (static)**
```cpp
class Base {
public:
    static virtual void func() { } // ОШИБКА: виртуальный метод не может быть статическим
};
```

### 4. **Не могут использовать specifier `inline` эффективно**
```cpp
class Base {
public:
    virtual inline void func() { } // Компилируется, но inline будет проигнорирован
    // Виртуальные методы не могут быть встроенными, так как вызов разрешается в runtime
};
```

### 5. **Не могут быть объявлены в `final` классах (C++11)**
```cpp
class Base final {  // final запрещает наследование
public:
    virtual void func() { } // Бессмысленно, но допустимо
};

class Derived : public Base { } // ОШИБКА: нельзя наследовать от final класса
```

### 6. **Не могут быть переопределены в `final` методах**
```cpp
class Base {
public:
    virtual void func() final { } // final запрещает переопределение
};

class Derived : public Base {
public:
    void func() override { } // ОШИБКА: нельзя переопределить final метод
};
```

### 7. **Ограничения на возвращаемый тип при переопределении**
Тип возвращаемого значения может отличаться только по **ковариантности** (возврат указателя/ссылки на производный класс):

```cpp
class Base {
public:
    virtual Base* clone() { return new Base(*this); }
};

class Derived : public Base {
public:
    Derived* clone() override { // Ковариантность: Derived* вместо Base*
        return new Derived(*this);
    }
};
```

### 8. **Не могут быть приватными в базовом классе (но могут в производном)**
```cpp
class Base {
private:
    virtual void secret() { } // Допустимо, но бесполезно для полиморфизма
};

class Derived : public Base {
public:
    void secret() override { } // ОШИБКА: нельзя переопределить private метод
};
```

### 9. **Требуют наличия определения в базовом классе (кроме pure virtual)**
```cpp
class Base {
public:
    virtual void func() = 0; // pure virtual - ОК, без определения
    virtual void regular(); // ОШИБКА: не-pure virtual без определения
};
```

### 10. **Не могут быть вызваны из конструктора/деструктора базового класса полиморфно**
```cpp
class Base {
public:
    Base() {
        func(); // Вызовет Base::func(), а не переопределённую версию
    }
    virtual void func() { cout << "Base" << endl; }
};

class Derived : public Base {
public:
    void func() override { cout << "Derived" << endl; }
};

int main() {
    Derived d; // Выведет "Base", а не "Derived"
}
```

### 11. **Накладывают накладные расходы**
- Каждый объект класса с виртуальными методами содержит указатель на vtable
- Вызов виртуального метода требует двойного разыменования (объект → vtable → метод)

### 12. **Не работают с обычными (не указателями/не ссылками) объектами**
```cpp
Derived derived;
Animal animal = derived; // Обрезка (slicing)
animal.speak(); // Вызовет Animal::speak(), а не Derived::speak()
```

### 13. **Модификаторы доступа в переопределении**
```cpp
class Base {
protected:
    virtual void func() {}
};

class Derived : public Base {
private:
    void func() override {} // Можно изменить доступ при переопределении
};
```

## Исключения

### Виртуальные методы могут:
1. Иметь параметры по умолчанию (но не рекомендуется)
2. Быть перегружены (overloaded)
3. Иметь любой модификатор доступа (public, protected, private)
4. Быть pure virtual (абстрактными)

```cpp
class Abstract {
public:
    virtual void pure() = 0; // pure virtual метод
    virtual ~Abstract() {} // Виртуальный деструктор (рекомендуется)
};
```

**Итог**: Виртуальные методы обеспечивают динамический полиморфизм, но имеют ограничения, связанные с их реализацией через vtable и особенностями работы в C++.