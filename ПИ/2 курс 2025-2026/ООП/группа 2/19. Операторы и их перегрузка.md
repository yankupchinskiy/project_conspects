**Оператор** — это символ, представляющий операцию. Виды:

- Арифметические: `+`, `-`, `*`, `/`
    
- Сравнения: `==`, `!=`, `<`, `>`
    
- Логические: `&&`, `||`, `!`
    
- Присваивания: `=`, `+=`, `-=`
    
- Инкремент/декремент: `++`, `--`
    
- Индексации: `[]`
    
- Вызова функции: `()`
    
- Приведения типа: `(type)`
    
- Разыменования: `*`, `->`
    
- new/delete: `new`, `delete`


## Операторы и их перегрузка в C++

### **Что такое перегрузка операторов?**
Перегрузка операторов позволяет определить собственное поведение операторов для пользовательских типов. Это форма **ad-hoc полиморфизма**.

```cpp
class Vector {
    double x, y;
public:
    // Перегрузка оператора сложения
    Vector operator+(const Vector& other) const {
        return Vector(x + other.x, y + other.y);
    }
};
```

### **Категории операторов**

#### 1. **Операторы, которые можно перегружать как члены класса или как свободные функции:**
- `+ - * / %` (бинарные)
- `+= -= *= /= %=`
- `== != < > <= >=`
- `<< >>` (потоковые)
- `& | ^ ~`
- `! && ||`
- `++ --` (префиксные и постфиксные)
- `,` (запятая)

#### 2. **Операторы, которые МОГУТ быть перегружены только как члены класса:**
- `=` (присваивание)
- `[]` (индексация)
- `()` (вызов функции)
- `->` (доступ к члену через указатель)
- `->*` (доступ к указателю на член)
- **Приведение типов** (`operator type()`)

#### 3. **Операторы, которые НЕЛЬЗЯ перегружать:**
- `.` (доступ к члену)
- `.*` (доступ к члену через указатель на член)
- `::` (разрешение области видимости)
- `?:` (тернарный оператор)
- `sizeof`
- `typeid`
- `alignof` (C++11)
- `noexcept` (C++11)

### **Основные правила перегрузки**

#### 1. **Сохранение семантики**
Оператор должен вести себя интуитивно понятно. Например, `+` не должен изменять операнды.

#### 2. **Нельзя изменить приоритет и ассоциативность**
```cpp
a + b * c; // Всегда сначала b*c, затем +, независимо от перегрузки
```

#### 3. **Нельзя изменить арность**
Унарный оператор остаётся унарным, бинарный — бинарным.

### **Способы перегрузки**

#### **Как член класса** (имеет доступ к `this`)
```cpp
class Complex {
    double re, im;
public:
    // Унарный минус (член класса)
    Complex operator-() const {
        return Complex(-re, -im);
    }
    
    // Сложение (член класса)
    Complex operator+(const Complex& other) const {
        return Complex(re + other.re, im + other.im);
    }
    
    // Присваивание (обязательно член класса)
    Complex& operator=(const Complex& other) {
        if (this != &other) {
            re = other.re;
            im = other.im;
        }
        return *this;
    }
};
```

#### **Как свободная функция** (часто требует `friend`)
```cpp
class Complex {
    double re, im;
public:
    // Декларация дружественной функции
    friend Complex operator*(const Complex& a, const Complex& b);
};

// Определение свободной функции
Complex operator*(const Complex& a, const Complex& b) {
    return Complex(a.re * b.re - a.im * b.im, 
                   a.re * b.im + a.im * b.re);
}
```

### **Особенности конкретных операторов**

#### 1. **Инкремент/декремент**
```cpp
class Iterator {
    int pos;
public:
    // Префиксный (++it)
    Iterator& operator++() {
        ++pos;
        return *this;
    }
    
    // Постфиксный (it++)
    Iterator operator++(int) { // Фиктивный параметр int
        Iterator temp = *this;
        ++(*this); // Используем префиксную версию
        return temp;
    }
};
```

#### 2. **Оператор индексации []**
```cpp
class SafeArray {
    int data[100];
public:
    // Для неконстантных объектов
    int& operator[](size_t index) {
        if (index >= 100) throw out_of_range("Index out of range");
        return data[index];
    }
    
    // Для константных объектов
    const int& operator[](size_t index) const {
        if (index >= 100) throw out_of_range("Index out of range");
        return data[index];
    }
};
```

#### 3. **Оператор вызова функции ()**
```cpp
class Multiplier {
    int factor;
public:
    Multiplier(int f) : factor(f) {}
    
    // Позволяет использовать объект как функцию
    int operator()(int x) const {
        return x * factor;
    }
    
    int operator()(int x, int y) const { // Перегрузка
        return x * y * factor;
    }
};

Multiplier times2(2);
cout << times2(5);    // 10
cout << times2(3, 4); // 24
```

#### 4. **Оператор приведения типа**
```cpp
class SmartPointer {
    int* ptr;
public:
    // Явное приведение к bool
    explicit operator bool() const {
        return ptr != nullptr;
    }
    
    // Приведение к int*
    explicit operator int*() const {
        return ptr;
    }
};

SmartPointer p(new int(42));
if (p) { // Использует operator bool()
    int* raw = static_cast<int*>(p); // Использует operator int*()
}
```

#### 5. **Оператор доступа через указатель ->**
```cpp
class PointerWrapper {
    std::string* ptr;
public:
    PointerWrapper(std::string* p) : ptr(p) {}
    
    // Должен возвращать указатель или объект с перегруженным ->
    std::string* operator->() {
        return ptr;
    }
    
    const std::string* operator->() const {
        return ptr;
    }
};

PointerWrapper wrapper(new std::string("Hello"));
cout << wrapper->size(); // Вызывает operator->, затем size()
```

#### 6. **Операторы сравнения (C++20 с spaceship operator)**
```cpp
// До C++20
class Point {
    int x, y;
public:
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
    
    bool operator!=(const Point& other) const {
        return !(*this == other);
    }
    
    bool operator<(const Point& other) const {
        return x < other.x || (x == other.x && y < other.y);
    }
};

// C++20 с spaceship operator
class ModernPoint {
    int x, y;
public:
    auto operator<=>(const ModernPoint&) const = default;
    // Автоматически генерирует: ==, !=, <, <=, >, >=
};
```

#### 7. **Потоковые операторы << и >>**
```cpp
class Person {
    std::string name;
    int age;
public:
    friend std::ostream& operator<<(std::ostream& os, const Person& p) {
        return os << p.name << " (" << p.age << ")";
    }
    
    friend std::istream& operator>>(std::istream& is, Person& p) {
        return is >> p.name >> p.age;
    }
};

Person p;
cin >> p;  // Использует operator>>
cout << p; // Использует operator<<
```

#### 8. **Оператор присваивания с перемещением (C++11)**
```cpp
class Buffer {
    char* data;
    size_t size;
public:
    // Перемещающее присваивание
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }
};
```

#### 9. **Оператор запятой ,**
```cpp
class CommaExample {
    int value;
public:
    CommaExample& operator,(const CommaExample& other) {
        value = other.value; // Обычно не рекомендуется
        return *this;
    }
};
```

### **Правила выбора способа перегрузки**

#### **Перегружать как член класса, если:**
1. Оператор изменяет левый операнд (`+=`, `-=`)
2. Оператор требует доступ к приватным членам
3. Оператор должен быть виртуальным
4. Обязательные операторы (`=`, `[]`, `()`, `->`, `->*`, приведения)

#### **Перегружать как свободную функцию, если:**
1. Нужна симметрия (например, `1 + obj` и `obj + 1`)
2. Оператор не изменяет операнды (`+`, `-`, `==`)
3. Левым операндом является встроенный тип

```cpp
// Свободная функция позволяет 1 + obj
Complex operator+(int scalar, const Complex& c) {
    return Complex(scalar + c.re, c.im);
}
```

### **Особенности для шаблонных классов**
```cpp
template<typename T>
class Container {
    T* data;
public:
    // Шаблонный оператор сравнения
    template<typename U>
    bool operator==(const Container<U>& other) const {
        // Сравнение контейнеров разных типов
    }
};
```

### **Рекомендации по перегрузке операторов**

1. **Следуйте ожидаемой семантике**: `+` не должен вычитать
2. **Поддерживайте симметрию**: если `a == b`, то `b == a`
3. **Обеспечьте полноту**: если перегружаете `==`, перегрузите и `!=`
4. **Возвращайте ссылки из составных присваиваний**: `a += b` должен возвращать `a&`
5. **Делайте унарные операторы const**: они не должны менять объект
6. **Используйте `explicit` для операторов приведения**: чтобы избежать неявных преобразований
7. **Перегружайте операторы ввода/вывода как свободные функции**
8. **Рассмотрите `noexcept` для операторов, которые не бросают исключения**
9. **Используйте идиому copy-and-swap для оператора присваивания**
10. **В C++20 используйте spaceship operator для сравнений**

### **Пример комплексного класса с перегрузкой**
```cpp
class Rational {
    int numerator, denominator;
    
    void normalize(); // Приведение к несократимой дроби
    
public:
    // Конструкторы
    
    // Арифметические операторы
    Rational operator+(const Rational&) const;
    Rational operator-(const Rational&) const;
    Rational operator*(const Rational&) const;
    Rational operator/(const Rational&) const;
    
    // Составные присваивания
    Rational& operator+=(const Rational&);
    Rational& operator-=(const Rational&);
    Rational& operator*=(const Rational&);
    Rational& operator/=(const Rational&);
    
    // Инкремент/декремент
    Rational& operator++();    // Префиксный
    Rational operator++(int); // Постфиксный
    
    // Унарные операторы
    Rational operator+() const;
    Rational operator-() const;
    
    // Операторы сравнения
    bool operator==(const Rational&) const;
    bool operator!=(const Rational&) const;
    bool operator<(const Rational&) const;
    bool operator>(const Rational&) const;
    bool operator<=(const Rational&) const;
    bool operator>=(const Rational&) const;
    
    // Приведение к double
    explicit operator double() const;
    
    // Потоковые операторы
    friend std::ostream& operator<<(std::ostream&, const Rational&);
    friend std::istream& operator>>(std::istream&, Rational&);
};
```

### **Распространённые ошибки**
1. **Не возвращают ссылку из составных присваиваний**
2. **Забывают проверку на самоприсваивание в `operator=`**
3. **Не перегружают оба варианта `++` и `--`**
4. **Не обеспечивают константную корректность**
5. **Создают несимметричные операторы сравнения**
6. **Разрешают неявные приведения через операторы преобразования**

**Итог**: Перегрузка операторов — мощный инструмент для создания интуитивно понятных пользовательских типов, но требует внимательного следования соглашениям и ожиданиям. Правильно перегруженные операторы делают код более читаемым и естественным.