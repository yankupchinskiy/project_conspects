## Дружественная функция и класс

**Дружественная функция** — это функция, не являющаяся членом класса, но имеющая доступ к его закрытым (private) и защищённым (protected) членам.

**Дружественный класс** — это класс, все методы которого имеют доступ к закрытым и защищённым членам другого класса.

```cpp
class Secret {
private:
    int secret_code = 42;
    
    // Объявление дружественной функции
    friend void revealSecret(const Secret& s);
    
    // Объявление дружественного класса
    friend class Hacker;
};

// Дружественная функция (не член класса)
void revealSecret(const Secret& s) {
    cout << "Secret code: " << s.secret_code << endl; // Доступ к private!
}

// Дружественный класс
class Hacker {
public:
    void modifySecret(Secret& s, int new_code) {
        s.secret_code = new_code; // Доступ к private!
    }
};
```

## Особенности дружественных отношений

### 1. **Односторонние отношения**
Дружественность не симметрична. Если класс A объявляет класс B другом, это не делает A другом B.

```cpp
class A {
    int secret = 1;
    friend class B; // B - друг A
};

class B {
    int secret = 2;
    // A НЕ имеет доступа к secret в B
public:
    void peekA(A& a) {
        cout << a.secret; // OK: B имеет доступ к A
    }
};

class C {
    void tryPeek(A& a) {
        // cout << a.secret; // ОШИБКА: C не друг A
    }
};
```

### 2. **Нарушение инкапсуляции**
Дружественные функции/классы нарушают принцип инкапсуляции. Это осознанное решение, позволяющее реализовать тесную связь там, где это необходимо.

### 3. **Дружественность не наследуется**
Если класс B — друг класса A, то классы-наследники B НЕ являются автоматически друзьями A.

```cpp
class BaseFriend {
    // Не имеет доступа к Secret
};

class Hacker : public BaseFriend {
    // Не имеет доступа к Secret, даже если BaseFriend друг
};
```

### 4. **Дружественность не транзитивна**
Если A друг B, и B друг C, то A не становится автоматически другом C.

```cpp
class A {
    friend class B;
    int a_secret = 1;
};

class B {
    friend class C;
    int b_secret = 2;
    
    void accessA(A& obj) {
        cout << obj.a_secret; // OK: B друг A
    }
};

class C {
    void tryAccess(A& obj) {
        // cout << obj.a_secret; // ОШИБКА: C не друг A
    }
    void accessB(B& obj) {
        cout << obj.b_secret; // OK: C друг B
    }
};
```

### 5. **Дружественные функции могут быть определены внутри класса**
```cpp
class Container {
    int data[100];
    int size = 0;
public:
    // Дружественная функция, определённая внутри класса
    friend void printSize(const Container& c) {
        cout << "Size: " << c.size; // Доступ к private
    }
};

// Не нужно определять функцию отдельно
```

### 6. **Шаблонные дружественные функции и классы**
```cpp
template<typename T>
class Box {
    T value;
public:
    // Дружественная функция для конкретного типа
    friend void peekValue(const Box<int>& box) {
        cout << box.value; // Только для Box<int>
    }
    
    // Дружественная функция для всех инстанциаций шаблона
    template<typename U>
    friend void universalPeek(const Box<U>& box);
};

template<typename U>
void universalPeek(const Box<U>& box) {
    cout << box.value; // Работает для любого Box<T>
}
```

### 7. **Дружественность может быть ограничена конкретными методами**
```cpp
class Database {
    string password = "admin123";
    
    // Только метод authenticate класса SecuritySystem - друг
    friend bool SecuritySystem::authenticate(const Database& db, string input);
};

class SecuritySystem {
public:
    bool authenticate(const Database& db, string input) {
        return db.password == input; // OK: конкретный метод - друг
    }
    
    void hack(const Database& db) {
        // cout << db.password; // ОШИБКА: этот метод не друг
    }
};
```

## Поведение при наследовании

### 1. **Дружественность НЕ наследуется**
```cpp
class Base {
private:
    int base_secret = 10;
    friend class BaseFriend;
};

class Derived : public Base {
private:
    int derived_secret = 20;
    // BaseFriend НЕ имеет доступа к derived_secret
};

class BaseFriend {
public:
    void accessBase(Base& b) {
        cout << b.base_secret; // OK
    }
    
    void accessDerived(Derived& d) {
        cout << d.base_secret;  // OK: унаследованный член
        // cout << d.derived_secret; // ОШИБКА: не друг Derived
    }
};
```

### 2. **Производный класс не становится автоматически другом**
```cpp
class SecretKeeper {
    int secret = 999;
    friend class Trusted;
};

class Trusted {
    // Имеет доступ к SecretKeeper
};

class Untrusted : public Trusted {
    // НЕ имеет доступа к SecretKeeper
    void tryAccess(SecretKeeper& sk) {
        // cout << sk.secret; // ОШИБКА
    }
};
```

### 3. **Наследование дружественного доступа к базовым членам**
Друг базового класса имеет доступ к унаследованным private членам базового класса через объект производного класса.

```cpp
class Base {
private:
    int inherited_secret = 100;
    friend class Friend;
};

class Derived : public Base {
private:
    int own_secret = 200;
};

class Friend {
public:
    void checkDerived(Derived& d) {
        cout << d.inherited_secret; // OK: доступ к унаследованному private
        // cout << d.own_secret; // ОШИБКА: не друг Derived
    }
};
```

### 4. **Virtual функции и дружественность**
Дружественные функции не могут быть virtual, так как они не члены класса.

```cpp
class Base {
public:
    // Невозможно объявить дружественную virtual функцию
    // friend virtual void func(); // ОШИБКА
};
```

### 5. **Дружественность для protected членов**
```cpp
class Base {
protected:
    int protected_data = 50;
    friend class Protector;
};

class Protector {
public:
    void useProtected(Base& b) {
        cout << b.protected_data; // OK: доступ к protected
    }
};

class Derived : public Base {
    // Protector имеет доступ к protected_data только через Base
    // но не к дополнительным protected членам Derived
};
```

## Практические примеры использования

### 1. **Перегрузка операторов**
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r, double i) : real(r), imag(i) {}
    
    // Дружественная функция для перегрузки оператора
    friend Complex operator+(const Complex& a, const Complex& b);
};

Complex operator+(const Complex& a, const Complex& b) {
    return Complex(a.real + b.real, a.imag + b.imag);
}
```

### 2. **Фабричные функции**
```cpp
class Product {
private:
    Product() {} // Приватный конструктор
    friend class ProductFactory;
};

class ProductFactory {
public:
    static Product* create() {
        return new Product(); // Может вызывать приватный конструктор
    }
};
```

### 3. **Unit-тестирование**
```cpp
class BankAccount {
private:
    double balance;
    void applyInterest() { balance *= 1.05; }
    
    // Только для тестирования
    friend class BankAccountTest;
};

class BankAccountTest {
public:
    static void testApplyInterest(BankAccount& acc) {
        acc.applyInterest(); // Тестируем приватный метод
    }
};
```

## Рекомендации

1. **Используйте умеренно**: Дружественность нарушает инкапсуляцию
2. **Лучшая альтернатива**: Публичные методы доступа (getters/setters)
3. **Исключения**:
   - Перегрузка операторов
   - Фабричные паттерны
   - Unit-тестирование приватных методов
   - Реализация тесно связанных классов

4. **Документируйте**: Всегда объясняйте, почему используется дружественность

```cpp
// Хороший пример: перегрузка оператора вывода
class Report {
    string data;
public:
    friend ostream& operator<<(ostream& os, const Report& r) {
        return os << "Report: " << r.data;
    }
};
```

**Итог**: Дружественные функции и классы — мощный механизм для предоставления избирательного доступа, но они нарушают инкапсуляцию и требуют осторожного использования. Дружественность не наследуется и не транзитивна, что нужно учитывать при проектировании иерархий классов.