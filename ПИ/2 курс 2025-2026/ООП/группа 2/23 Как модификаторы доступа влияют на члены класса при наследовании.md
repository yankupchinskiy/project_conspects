

## **Основные модификаторы доступа**

### **1. Public наследование**
```cpp
#include <iostream>

class Base {
public:
    int public_var;
    void public_method() { std::cout << "Base::public_method()" << std::endl; }
    
protected:
    int protected_var;
    void protected_method() { std::cout << "Base::protected_method()" << std::endl; }
    
private:
    int private_var;
    void private_method() { std::cout << "Base::private_method()" << std::endl; }
};

class DerivedPublic : public Base {
public:
    void test_access() {
        // Public-члены Base - доступны как public
        public_var = 10;
        public_method();
        
        // Protected-члены Base - доступны как protected
        protected_var = 20;
        protected_method();
        
        // Private-члены Base - НЕ доступны
        // private_var = 30;       // Ошибка
        // private_method();       // Ошибка
    }
};

int main() {
    DerivedPublic d;
    
    // Извне класса:
    d.public_var = 100;        // OK: public в DerivedPublic
    d.public_method();         // OK: public в DerivedPublic
    
    // d.protected_var = 200;   // Ошибка: protected в DerivedPublic
    // d.protected_method();    // Ошибка: protected в DerivedPublic
    // d.private_var = 300;     // Ошибка: private в Base
    
    Base* b = &d;             // OK: public наследование
    return 0;
}
```

### **2. Protected наследование**
```cpp
#include <iostream>

class Base {
public:
    int public_var;
    void public_method() { std::cout << "Base::public_method()" << std::endl; }
    
protected:
    int protected_var;
    void protected_method() { std::cout << "Base::protected_method()" << std::endl; }
    
private:
    int private_var;
    void private_method() { std::cout << "Base::private_method()" << std::endl; }
};

class DerivedProtected : protected Base {
public:
    void test_access() {
        // Public-члены Base - становятся protected в DerivedProtected
        public_var = 10;
        public_method();
        
        // Protected-члены Base - остаются protected
        protected_var = 20;
        protected_method();
        
        // Private-члены Base - НЕ доступны
        // private_var = 30;       // Ошибка
        // private_method();       // Ошибка
    }
    
    // Можно сделать public методы для доступа к унаследованным protected членам
    int get_public_var() const { return public_var; }
    void call_public_method() { public_method(); }
};

class FurtherDerived : public DerivedProtected {
public:
    void further_test() {
        // Внутри производного от DerivedProtected:
        public_var = 100;       // OK: protected в DerivedProtected
        public_method();        // OK: protected в DerivedProtected
        protected_var = 200;    // OK: protected
        protected_method();     // OK: protected
    }
};

int main() {
    DerivedProtected d;
    
    // Извне класса:
    // d.public_var = 100;        // Ошибка: теперь protected
    // d.public_method();         // Ошибка: теперь protected
    // d.protected_var = 200;     // Ошибка: protected
    // d.protected_method();      // Ошибка: protected
    
    // Но можно использовать public методы-обертки
    d.call_public_method();
    
    // Base* b = &d;             // Ошибка: protected наследование
    // Нужно явное приведение
    Base* b = static_cast<Base*>(&d);  // Опасно!
    
    return 0;
}
```

### **3. Private наследование**
```cpp
#include <iostream>

class Base {
public:
    int public_var;
    void public_method() { std::cout << "Base::public_method()" << std::endl; }
    
protected:
    int protected_var;
    void protected_method() { std::cout << "Base::protected_method()" << std::endl; }
    
private:
    int private_var;
    void private_method() { std::cout << "Base::private_method()" << std::endl; }
};

class DerivedPrivate : private Base {
public:
    void test_access() {
        // Public-члены Base - становятся private в DerivedPrivate
        public_var = 10;
        public_method();
        
        // Protected-члены Base - становятся private в DerivedPrivate
        protected_var = 20;
        protected_method();
        
        // Private-члены Base - НЕ доступны
        // private_var = 30;       // Ошибка
        // private_method();       // Ошибка
    }
    
    // Можно сделать public методы для доступа
    int get_public_var() const { return public_var; }
    void expose_public_method() { public_method(); }
};

class FurtherDerivedFromPrivate : public DerivedPrivate {
public:
    void further_test() {
        // НЕ имеем доступа к членам Base
        // public_var = 100;       // Ошибка: private в DerivedPrivate
        // public_method();        // Ошибка: private в DerivedPrivate
        // protected_var = 200;    // Ошибка: private в DerivedPrivate
        // protected_method();     // Ошибка: private в DerivedPrivate
        
        // Но можем использовать public методы DerivedPrivate
        get_public_var();
        expose_public_method();
    }
};

int main() {
    DerivedPrivate d;
    
    // Извне класса:
    // d.public_var = 100;        // Ошибка: теперь private
    // d.public_method();         // Ошибка: теперь private
    // d.protected_var = 200;     // Ошибка: private
    // d.protected_method();      // Ошибка: private
    
    d.expose_public_method();     // OK: через public метод
    
    // Base* b = &d;             // Ошибка: private наследование
    // Невозможно преобразовать даже с static_cast
    
    return 0;
}
```

## **Сводная таблица влияния**

| Наследование \ Член в Base | `public` в Base | `protected` в Base | `private` в Base |
|---------------------------|-----------------|-------------------|-----------------|
| **`public` наследование** | `public` в Derived | `protected` в Derived | Недоступен |
| **`protected` наследование** | `protected` в Derived | `protected` в Derived | Недоступен |
| **`private` наследование** | `private` в Derived | `private` в Derived | Недоступен |

## **Особые случаи и нюансы**

### **1. Изменение уровня доступа с помощью `using`**
```cpp
#include <iostream>

class Base {
public:
    void public_method() { std::cout << "Base::public_method()" << std::endl; }
    
protected:
    void protected_method() { std::cout << "Base::protected_method()" << std::endl; }
    
private:
    void private_method() { std::cout << "Base::private_method()" << std::endl; }
};

class DerivedPrivate : private Base {
public:
    // Делаем protected_method снова public
    using Base::protected_method;  // Теперь protected_method - public в DerivedPrivate
    
    // Нельзя сделать private метод public
    // using Base::private_method;  // Ошибка: private в Base
    
    // Можно изменить уровень доступа public метода
    using Base::public_method;     // Остается доступным (private -> ?)
    // На самом деле: public_method был public в Base,
    // но из-за private наследования стал private в DerivedPrivate.
    // using делает его public в DerivedPrivate.
};

int main() {
    DerivedPrivate d;
    d.public_method();      // OK: using сделал public
    d.protected_method();   // OK: using сделал public
    
    return 0;
}
```

### **2. Дружественные классы и наследование**
```cpp
#include <iostream>

class Base {
private:
    int private_var;
    
    // Дружественный класс
    friend class FriendClass;
    
protected:
    void protected_method() { 
        std::cout << "Base::protected_method(), private_var = " << private_var << std::endl; 
    }
};

class FriendClass {
public:
    void access_base(Base& b) {
        b.private_var = 42;  // OK: дружественный класс
        // Но нельзя унаследовать дружбу!
    }
};

class Derived : public Base {
public:
    void test() {
        // private_var = 10;  // Ошибка: не дружественный
        protected_method();   // OK: protected
    }
};

class NotFriend {
public:
    void access_base(Base& b) {
        // b.private_var = 42;  // Ошибка: не дружественный
    }
};

int main() {
    Base b;
    FriendClass f;
    f.access_base(b);
    
    Derived d;
    d.test();
    
    return 0;
}
```

### **3. Множественное наследование с разными модификаторами**
```cpp
#include <iostream>

class Base1 {
public:
    void base1_public() { std::cout << "Base1::public" << std::endl; }
protected:
    void base1_protected() { std::cout << "Base1::protected" << std::endl; }
};

class Base2 {
public:
    void base2_public() { std::cout << "Base2::public" << std::endl; }
protected:
    void base2_protected() { std::cout << "Base2::protected" << std::endl; }
};

class Derived : public Base1, private Base2 {
public:
    void test() {
        base1_public();      // OK: public наследование
        base1_protected();   // OK: protected в Base1
        
        base2_public();      // OK: private в Derived, но доступно внутри
        base2_protected();   // OK: private в Derived, но доступно внутри
    }
    
    // Делаем base2_public доступным снаружи
    using Base2::base2_public;
};

class FurtherDerived : public Derived {
public:
    void further_test() {
        base1_public();      // OK: public в Derived
        base1_protected();   // OK: protected в Derived
        
        // base2_public();    // Ошибка: private в Derived
        // Но если бы Derived сделал using, то было бы OK
        base2_public();      // OK: using в Derived сделал его public
    }
};

int main() {
    Derived d;
    d.base1_public();        // OK: public
    // d.base1_protected();   // Ошибка: protected
    d.base2_public();        // OK: using сделал public
    
    return 0;
}
```

## **Практические примеры использования**

### **Пример 1: Интерфейсы (чисто public наследование)**
```cpp
#include <iostream>

// Интерфейс (абстрактный класс с чисто виртуальными функциями)
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() = default;
    
    // Public методы интерфейса
    void print_info() const {
        std::cout << "Drawable object" << std::endl;
    }
};

// Реализация интерфейса
class Circle : public Drawable {  // Всегда public наследование
    double radius;
protected:
    // Вспомогательный protected метод
    double calculate_area() const {
        return 3.14159 * radius * radius;
    }
    
public:
    Circle(double r) : radius(r) {}
    
    void draw() const override {
        std::cout << "Drawing circle with radius " << radius 
                  << ", area = " << calculate_area() << std::endl;
    }
};

int main() {
    Circle c(5.0);
    c.draw();
    c.print_info();  // Унаследованный public метод
    
    Drawable* d = &c;  // OK: public наследование
    d->draw();
    
    return 0;
}
```

### **Пример 2: Реализация через private наследование (композиция)**
```cpp
#include <iostream>
#include <vector>

// Класс, реализующий функциональность стека
class StackImpl {
private:
    std::vector<int> data;
    
public:
    void push(int value) { 
        data.push_back(value); 
        std::cout << "Pushed: " << value << std::endl;
    }
    
    int pop() {
        if (data.empty()) throw std::runtime_error("Stack is empty");
        int value = data.back();
        data.pop_back();
        std::cout << "Popped: " << value << std::endl;
        return value;
    }
    
    bool empty() const { return data.empty(); }
    
protected:
    // Protected метод для внутреннего использования
    size_t size() const { return data.size(); }
};

// Публичный интерфейс стека с ограниченным доступом
class Stack : private StackImpl {  // Private наследование = реализация
public:
    // Открываем только нужные методы
    using StackImpl::push;
    using StackImpl::pop;
    using StackImpl::empty;
    
    // Добавляем свою функциональность
    int top() const {
        if (empty()) throw std::runtime_error("Stack is empty");
        // Не можем напрямую использовать data, но можем добавить friend
        // или изменить StackImpl
        return 42; // Упрощенный пример
    }
    
    void clear() {
        while (!empty()) {
            pop();
        }
    }
};

int main() {
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
    
    std::cout << "Stack empty? " << (s.empty() ? "Yes" : "No") << std::endl;
    
    s.pop();
    s.clear();
    
    // Недоступно: s.size() - protected в StackImpl
    
    return 0;
}
```

### **Пример 3: Protected наследование для фреймворков**
```cpp
#include <iostream>

// Базовый класс фреймворка
class FrameworkBase {
protected:
    // Protected методы для переопределения
    virtual void initialize() = 0;
    virtual void process() = 0;
    virtual void cleanup() = 0;
    
    // Protected вспомогательные методы
    void log(const std::string& message) {
        std::cout << "[LOG] " << message << std::endl;
    }
    
public:
    // Public интерфейс для запуска
    void run() {
        log("Starting framework...");
        initialize();
        process();
        cleanup();
        log("Framework finished.");
    }
    
    virtual ~FrameworkBase() = default;
};

// Пользовательское приложение
class MyApp : protected FrameworkBase {  // Protected наследование
protected:
    // Реализация protected методов фреймворка
    void initialize() override {
        log("MyApp initializing...");
        app_specific_setup();
    }
    
    void process() override {
        log("MyApp processing...");
        for (int i = 0; i < 3; ++i) {
            log("Processing iteration " + std::to_string(i));
        }
    }
    
    void cleanup() override {
        log("MyApp cleaning up...");
        app_specific_cleanup();
    }
    
private:
    // Специфичные для приложения методы
    void app_specific_setup() {
        log("App-specific setup");
    }
    
    void app_specific_cleanup() {
        log("App-specific cleanup");
    }
    
public:
    // Публичный интерфейс приложения
    void start() {
        run();  // Вызываем protected метод базового класса
    }
};

int main() {
    MyApp app;
    app.start();  // Запускаем приложение
    
    // Нельзя напрямую вызвать run()
    // app.run();  // Ошибка: run() теперь protected
    
    return 0;
}
```

### **Пример 4: Контроль доступа в иерархии классов**
```cpp
#include <iostream>
#include <string>

class Employee {
private:
    std::string name;
    double salary;  // Приватно - нельзя менять напрямую
    
protected:
    int employee_id;
    
    // Protected метод для доступа к salary в производных классах
    void set_salary(double new_salary) {
        if (new_salary >= 0) {
            salary = new_salary;
        }
    }
    
    double get_salary() const { return salary; }
    
public:
    Employee(const std::string& n, int id, double sal) 
        : name(n), employee_id(id), salary(sal) {}
    
    const std::string& get_name() const { return name; }
    int get_id() const { return employee_id; }
    
    virtual void print_info() const {
        std::cout << "Employee: " << name 
                  << " (ID: " << employee_id 
                  << ", Salary: " << salary << ")" << std::endl;
    }
};

class Manager : public Employee {
private:
    int team_size;
    
public:
    Manager(const std::string& n, int id, double sal, int team) 
        : Employee(n, id, sal), team_size(team) {}
    
    // Может изменять salary через protected метод
    void increase_salary(double amount) {
        set_salary(get_salary() + amount);
    }
    
    void print_info() const override {
        std::cout << "Manager: " << get_name() 
                  << " (ID: " << get_id() 
                  << ", Salary: " << get_salary() 
                  << ", Team size: " << team_size << ")" << std::endl;
    }
};

class HR : private Employee {  // Private наследование - реализация деталь
public:
    HR(const std::string& n, int id, double sal) 
        : Employee(n, id, sal) {}
    
    // Публичный интерфейс HR
    void process_payroll(const Manager& m) {
        std::cout << "Processing payroll for manager: " 
                  << m.get_name() << std::endl;
        // HR имеет доступ к защищенным методам Employee
        // через private наследование
    }
    
    // Открываем нужные методы
    using Employee::get_name;
    using Employee::get_id;
};

int main() {
    Manager mgr("Alice", 101, 50000, 5);
    mgr.print_info();
    mgr.increase_salary(5000);
    mgr.print_info();
    
    HR hr("Bob", 102, 45000);
    hr.process_payroll(mgr);
    std::cout << "HR name: " << hr.get_name() << std::endl;
    
    // Нельзя получить доступ к salary извне
    // mgr.get_salary();  // Ошибка: protected
    // hr.get_salary();   // Ошибка: private наследование
    
    return 0;
}
```

## **Рекомендации по использованию**

### **Когда использовать каждый тип наследования:**

1. **Public наследование**:
   - Для отношений "является" (is-a)
   - Для интерфейсов и абстрактных классов
   - Когда нужно полиморфное поведение

2. **Protected наследование**:
   - Для фреймворков и библиотек
   - Когда нужно скрыть публичный интерфейс базового класса
   - Для реализации "реализуется посредством" (implemented-in-terms-of)

3. **Private наследование**:
   - Для отношений "реализован посредством" (implemented-in-terms-of)
   - Когда нужно переопределить виртуальные функции
   - Как альтернатива композиции с дополнительными возможностями

### **Золотые правила:**

1. **По умолчанию используйте public наследование** для полиморфизма
2. **Private наследование предпочитайте композиции**, кроме случаев, когда нужно:
   - Переопределить виртуальную функцию
   - Получить доступ к protected членам
   - Контролировать время жизни базового подобъекта
3. **Protected наследование** используйте в библиотеках для предоставления расширяемой функциональности
4. **Не злоупотребляйте изменением уровня доступа** через `using` - это может запутать

## **Вывод**

**Модификаторы доступа при наследовании** определяют, как члены базового класса будут видны в производном классе и извне:

1. **Public наследование**:
   - Сохраняет уровни доступа
   - Поддерживает полиморфизм
   - Используется для интерфейсов

2. **Protected наследование**:
   - Понижает public члены до protected
   - Скрывает интерфейс базового класса
   - Используется в фреймворках

3. **Private наследование**:
   - Делает все унаследованные члены private
   - Реализует отношение "реализован посредством"
   - Альтернатива композиции

**Ключевое отличие** от композиции: при наследовании можно переопределять виртуальные функции и иметь доступ к protected членам базового класса, что невозможно при обычной композиции.