**Особенность:** Может использоваться для неявного преобразования типов:

``` c++
class String {
public:
    String(const char* str) { /* ... */ } // Конструктор от одного аргумента
};


void printString(const String& s) { /* ... */ }

printString("Hello"); // Неявно вызывает String("Hello")
```


**Запрет неявного преобразования:**


``` c++
explicit String(const char* str); // Теперь printString("Hello") вызовет ошибку
```
## Конструктор от одного аргумента

**Конструктор от одного аргумента** — это конструктор, который может быть вызван с одним параметром (не считая параметров по умолчанию). Такой конструктор позволяет **неявное преобразование** из типа параметра в тип класса.

### Базовый пример

```cpp
class String {
    char* data;
public:
    // Конструктор от одного аргумента (const char*)
    String(const char* str) {  // Может использоваться для неявного преобразования
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
};

void printString(const String& s) {
    cout << s << endl;
}

int main() {
    String s1("Hello");         // Прямой вызов конструктора
    String s2 = "World";        // Копирующая инициализация (неявное преобразование)
    printString("Implicit!");   // Неявное преобразование const char* → String
}
```

### Ключевое слово `explicit`

Чтобы запретить **неявное преобразование**, используют `explicit`:

```cpp
class ExplicitString {
    char* data;
public:
    explicit ExplicitString(const char* str) {  // Запрещает неявное преобразование
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }
};

void printExplicit(const ExplicitString& s) {
    cout << s << endl;
}

int main() {
    ExplicitString es1("Hello");      // OK: прямой вызов
    // ExplicitString es2 = "World";  // ОШИБКА: неявное преобразование запрещено
    // printExplicit("Error!");       // ОШИБКА: неявное преобразование запрещено
    printExplicit(ExplicitString("OK")); // OK: явное преобразование
}
```

### Особенности и применения

#### 1. **Конструкторы преобразования**
```cpp
class Complex {
    double real, imag;
public:
    // Конструктор от одного double (преобразование double → Complex)
    Complex(double r) : real(r), imag(0) {}
    
    // Конструктор от двух double (НЕ конструктор от одного аргумента!)
    Complex(double r, double i) : real(r), imag(i) {}
};

Complex c1 = 3.14;  // Неявное преобразование: Complex(3.14)
```

#### 2. **Конструкторы с параметрами по умолчанию**
```cpp
class Point {
    int x, y, z;
public:
    // Конструктор от одного аргумента (если вызывается с одним параметром)
    Point(int x = 0, int y = 0, int z = 0) : x(x), y(y), z(z) {}
};

Point p1;          // OK: все параметры по умолчанию
Point p2(5);       // OK: x=5, y=0, z=0 (конструктор от одного аргумента)
Point p3 = 10;     // OK: неявное преобразование int → Point
```

#### 3. **Проблемы неявных преобразований**
```cpp
class Array {
    int size;
    int* data;
public:
    Array(int sz) : size(sz), data(new int[sz]) {}
    bool operator==(const Array& other) const {
        return size == other.size;
    }
};

Array arr(10);
if (arr == 5) {  // Неожиданно! Сравнивается Array(5) с arr
    // Возможная ошибка: создаётся временный объект Array(5)
}
```

#### 4. **Использование в шаблонах**
```cpp
template<typename T>
class Container {
    T value;
public:
    Container(const T& val) : value(val) {}  // Конструктор от одного аргумента
    // explicit Container(const T& val) : value(val) {}  // Для запрета неявного преобразования
};

Container<int> c1 = 42;      // Неявное преобразование
Container<std::string> c2 = "text";  // const char* → std::string → Container
```

#### 5. **Конструкторы копирования и перемещения**
**Не являются** конструкторами от одного аргумента в контексте преобразований:

```cpp
class MyClass {
public:
    MyClass(const MyClass& other);  // Конструктор копирования
    MyClass(MyClass&& other);       // Конструктор перемещения
    // Это конструкторы от одного аргумента, но они не рассматриваются
    // как преобразования из MyClass в MyClass
};
```

#### 6. **Конструкторы с несколькими параметрами (C++11)**
В C++11 появилась **uniform initialization**, которая меняет поведение:

```cpp
class Widget {
    int x, y;
public:
    Widget(int a, int b = 0) : x(a), y(b) {}  // Конструктор от одного аргумента
};

Widget w1 = 5;     // C++98: OK (неявное преобразование)
Widget w2{5};      // C++11: OK (прямая инициализация)
Widget w3 = {5};   // C++11: ошибка, если конструктор explicit
```

#### 7. **Правило одного аргумента в стандартной библиотеке**
```cpp
#include <vector>
#include <string>

std::vector<int> v1 = 10;     // ОШИБКА: explicit конструктор
std::vector<int> v2(10);      // OK: вектор из 10 элементов
std::vector<int> v3{10};      // OK: вектор с одним элементом 10

std::string s1 = "hello";     // OK: неявное преобразование
std::string s2("hello");      // OK: прямая инициализация
```

#### 8. **Конструкторы с `std::initializer_list`**
```cpp
class InitializerExample {
    std::vector<int> data;
public:
    // Конструктор от одного аргумента std::initializer_list
    InitializerExample(std::initializer_list<int> list) : data(list) {}
    
    // Конструктор от одного int
    explicit InitializerExample(int size) : data(size) {}
};

InitializerExample ie1 = {1, 2, 3};  // OK: использует initializer_list
InitializerExample ie2(10);          // OK: explicit конструктор от int
// InitializerExample ie3 = 10;      // ОШИБКА: explicit запрещает неявное преобразование
```

### Рекомендации по использованию

#### Когда использовать `explicit`:
1. **Почти всегда** для конструкторов от одного аргумента
2. Когда нежелательны неявные преобразования
3. Для классов, которые не являются "естественными" числовыми типами

#### Когда НЕ использовать `explicit`:
1. Для классов, которые должны вести себя как встроенные типы
2. Для "обёрточных" классов (например, `std::string` из `const char*`)
3. Когда неявные преобразования являются частью дизайна

### Сравнение с операторами преобразования

```cpp
class Rational {
    int num, den;
public:
    // Конструктор преобразования: int → Rational
    Rational(int n) : num(n), den(1) {}
    
    // Оператор преобразования: Rational → double
    operator double() const {
        return static_cast<double>(num) / den;
    }
};

Rational r = 3;     // Неявное преобразование: использует конструктор
double d = r;       // Неявное преобразование: использует operator double()
```

### Особенности в иерархиях классов

```cpp
class Base {
public:
    Base(int x) { /* ... */ }
};

class Derived : public Base {
public:
    // Конструктор Derived должен вызвать конструктор Base
    Derived(int x) : Base(x) { /* ... */ }
    
    // Если Base имеет explicit конструктор:
    // Derived(int x) : Base(x) {} // OK
    // Derived d = 5; // ОШИБКА, если Base(int) explicit
};
```

### Полный пример с `explicit`

```cpp
class SmartInt {
    int value;
public:
    // explicit конструктор от одного аргумента
    explicit SmartInt(int v) : value(v) {}
    
    // Не-explicit конструктор от другого типа
    SmartInt(const std::string& str) : value(std::stoi(str)) {}
    
    int get() const { return value; }
};

void processSmartInt(const SmartInt& si) {
    cout << si.get() << endl;
}

int main() {
    SmartInt si1(42);           // OK: прямая инициализация
    SmartInt si2 = 42;          // ОШИБКА: неявное преобразование запрещено
    SmartInt si3 = "123";       // OK: неявное преобразование string → SmartInt
    SmartInt si4("456");        // OK: прямая инициализация
    
    processSmartInt(si1);       // OK
    // processSmartInt(42);     // ОШИБКА: неявное преобразование запрещено
    processSmartInt(SmartInt(42)); // OK: явное преобразование
    processSmartInt("789");     // OK: string → SmartInt (неявно)
}
```

### Выводы

1. **Конструктор от одного аргумента** позволяет неявное преобразование
2. Ключевое слово **`explicit`** запрещает неявное преобразование
3. **Рекомендуется** использовать `explicit` по умолчанию для таких конструкторов
4. **Исключения**: когда класс должен вести себя как встроенный тип
5. В **C++11** `explicit` можно использовать также для операторов преобразования

Правильное использование `explicit` предотвращает неожиданные преобразования и делает код более безопасным и читаемым.