## Переопределение метода

**Переопределение метода (method overriding)** — это замена реализации метода базового класса в производном классе с сохранением той же сигнатуры (имени, параметров, возвращаемого типа). Это ключевой механизм динамического полиморфизма в C++.

```cpp
class Animal {
public:
    virtual void speak() {          // Виртуальный метод базового класса
        cout << "Some sound" << endl;
    }
};

class Dog : public Animal {
public:
    void speak() override {         // Переопределение метода
        cout << "Woof!" << endl;
    }
};

class Cat : public Animal {
public:
    void speak() override {         // Другое переопределение
        cout << "Meow!" << endl;
    }
};
```

## Особенности вызова переопределенного метода

### 1. **Динамическое связывание (позднее связывание)**
Выбор метода происходит во время выполнения на основе фактического типа объекта.

```cpp
Animal* animal1 = new Dog();
Animal* animal2 = new Cat();

animal1->speak();  // Вызовет Dog::speak() - "Woof!"
animal2->speak();  // Вызовет Cat::speak() - "Meow!"
```

### 2. **Зависимость от типа указателя/ссылки**
```cpp
Dog dog;
Animal& ref = dog;
Animal* ptr = &dog;

dog.speak();    // Статически: Dog::speak()
ref.speak();    // Динамически: Dog::speak() (через ссылку)
ptr->speak();   // Динамически: Dog::speak() (через указатель)

Animal animal = dog;  // Срезка!
animal.speak();       // Статически: Animal::speak() (не переопределение!)
```

### 3. **Поведение в конструкторах и деструкторах**
В конструкторах и деструкторах виртуальные методы вызываются статически, а не динамически.

```cpp
class Base {
public:
    Base() { 
        create();  // Всегда вызовет Base::create(), даже если объект Derived
    }
    virtual ~Base() {
        destroy(); // Всегда вызовет Base::destroy()
    }
    virtual void create() { cout << "Base create\n"; }
    virtual void destroy() { cout << "Base destroy\n"; }
};

class Derived : public Base {
public:
    void create() override { cout << "Derived create\n"; }
    void destroy() override { cout << "Derived destroy\n"; }
};

Derived d;  
// Вывод: "Base create" (в конструкторе Base виртуальность не работает)
// При уничтожении: "Base destroy" (в деструкторе Base виртуальность не работает)
```

### 4. **Явный вызов метода базового класса**
```cpp
class Derived : public Base {
public:
    void speak() override {
        Base::speak();  // Явный вызов метода базового класса
        cout << "Additional message from Derived" << endl;
    }
};
```

### 5. **Модификаторы доступа могут отличаться**
```cpp
class Base {
protected:
    virtual void internal() { cout << "Base internal\n"; }
};

class Derived : public Base {
public:
    void internal() override {  // Изменили доступ с protected на public
        cout << "Derived internal\n";
    }
};

Base* b = new Derived();
// b->internal();  // ОШИБКА: Base::internal() protected
Derived* d = new Derived();
d->internal();     // OK: теперь public
```

### 6. **Ковариантность возвращаемых типов**
Возвращаемый тип может быть указателем/ссылкой на производный класс.

```cpp
class Base {
public:
    virtual Base* clone() { return new Base(*this); }
};

class Derived : public Base {
public:
    Derived* clone() override {  // Ковариантный возвращаемый тип
        return new Derived(*this);
    }
};

Derived d;
Base* b1 = d.clone();   // Возвращает Derived*, но приводится к Base*
Derived* d1 = d.clone(); // Возвращает Derived* напрямую
```

### 7. **Исключения в спецификациях**
```cpp
class Base {
public:
    virtual void risky() throw(std::exception) { }  // Может бросать exception
};

class Derived : public Base {
public:
    void risky() throw(std::exception, std::runtime_error) override {
        // Может бросать exception и runtime_error (правило нестрогое в C++)
    }
};
```

### 8. **Использование final для запрета дальнейшего переопределения**
```cpp
class Base {
public:
    virtual void action() { }
};

class Derived : public Base {
public:
    void action() override final {  // final запрещает дальнейшее переопределение
        cout << "Final implementation" << endl;
    }
};

class Further : public Derived {
public:
    // void action() override { }  // ОШИБКА: метод final в Derived
};
```

### 9. **Перегрузка vs Переопределение**
```cpp
class Base {
public:
    virtual void func(int) { }    // #1
    virtual void func(double) { } // #2
};

class Derived : public Base {
public:
    void func(int) override { }   // Переопределяет только #1
    // #2 из Base тоже доступна, но не переопределена
};

Derived d;
d.func(5);     // Вызовет Derived::func(int)
d.func(3.14);  // Вызовет Base::func(double) (не переопределена)
```

### 10. **Разрешение перегрузки происходит статически**
```cpp
class Base {
public:
    virtual void process(int) { cout << "Base int\n"; }
    virtual void process(double) { cout << "Base double\n"; }
};

class Derived : public Base {
public:
    void process(int) override { cout << "Derived int\n"; }
    // process(double) не переопределён
};

Derived d;
Base& b = d;

d.process(10);    // Derived::process(int)
d.process(10.5);  // Base::process(double) - разрешение перегрузки статически
b.process(10);    // Derived::process(int) - динамически через виртуальность
b.process(10.5);  // Base::process(double) - перегрузка разрешается для типа Base
```

### 11. **Множественное наследование и переопределение**
```cpp
class Interface1 {
public:
    virtual void method() = 0;
};

class Interface2 {
public:
    virtual void method() = 0;
};

class Implementation : public Interface1, public Interface2 {
public:
    void method() override {  // Переопределяет оба метода
        cout << "Single implementation for both interfaces" << endl;
    }
};

Implementation impl;
Interface1* i1 = &impl;
Interface2* i2 = &impl;

i1->method();  // Вызовет Implementation::method()
i2->method();  // Вызовет Implementation::method()
```

### 12. **Виртуальность и оператор разрешения области видимости**
```cpp
class Base {
public:
    virtual void show() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    void show() override { 
        cout << "Derived\n";
    }
    
    void demo() {
        show();               // Derived::show()
        this->show();         // Derived::show()
        Base::show();         // Явно Base::show()
        this->Base::show();   // Явно Base::show()
    }
};

Derived d;
d.demo();
// Вывод:
// Derived
// Derived  
// Base
// Base
```

## Практические рекомендации

1. **Всегда используйте `override`** (C++11 и выше) для явного указания переопределения
2. **Объявляйте деструкторы виртуальными** в базовых классах
3. **Избегайте вызовов виртуальных методов** в конструкторах и деструкторах
4. **Используйте `final`** когда дальнейшее переопределение нежелательно
5. **Помните о срезке объектов** — используйте указатели/ссылки для полиморфизма

```cpp
// Правильный паттерн
class Base {
public:
    virtual ~Base() = default;  // Виртуальный деструктор
    virtual void execute() = 0; // Чисто виртуальный метод
};

class Derived : public Base {
public:
    void execute() override {   // Явное переопределение
        // Реализация
    }
};
```

**Итог**: Переопределение методов — основа динамического полиморфизма в C++. Понимание особенностей вызова переопределенных методов критически важно для создания корректных иерархий классов и избежания распространенных ошибок.