### 1. Полиморфный класс

**Полиморфный класс** — это класс, объекты которого могут использоваться через интерфейс (или ссылку) своего родительского класса, но при этом вести себя по-разному (выполнять одни и те же операции по-своему) в зависимости от своей реальной (производной) сущности.

**Суть полиморфизма:** "Один интерфейс — множество реализаций".

**Как достигается?** Через **переопределение (override)** виртуальных методов базового класса в классах-наследниках.

**Простой пример:**
```cpp
// Базовый полиморфный класс
class Shape {
public:
    virtual void draw() { // Виртуальный метод
        cout << "Рисую фигуру" << endl;
    }
};

// Классы-наследники
class Circle : public Shape {
public:
    void draw() override { // Переопределение метода
        cout << "Рисую круг" << endl;
    }
};

class Square : public Shape {
public:
    void draw() override {
        cout << "Рисую квадрат" << endl;
    }
};

int main() {
    Shape* shapes[3];
    shapes[0] = new Circle();
    shapes[1] = new Square();
    shapes[2] = new Shape();

    for (int i = 0; i < 3; ++i) {
        shapes[i]->draw(); // Вызывается разная реализация для каждого типа
    }
    // Вывод:
    // Рисую круг
    // Рисую квадрат
    // Рисую фигуру
}
```
**Главное:** Полиморфизм позволяет работать с разными типами объектов единообразно, что делает код гибким и расширяемым.

---

### 2. Абстрактный класс

**Абстрактный класс** — это класс, который **не предназначен для создания экземпляров (объектов)**. Он существует только для того, чтобы быть родительским классом для других классов.

**Его цель:** Определить общий интерфейс (набор методов) и, возможно, часть общей реализации для группы родственных классов.

**Как создается?** Класс становится абстрактным, если в нем объявлен **хотя бы один чисто виртуальный метод** (pure virtual).

**Чисто виртуальный метод** — это метод, у которого нет реализации в базовом классе. Он обязывает все *конкретные* (не абстрактные) классы-наследники предоставить свою реализацию.

**Пример:**
```cpp
// Абстрактный класс
class Animal {
public:
    virtual void makeSound() = 0; // Чисто виртуальный метод. "= 0"
    void breathe() {              // Обычный метод с реализацией
        cout << "Дышу" << endl;
    }
};

// Конкретные классы-наследники
class Dog : public Animal {
public:
    void makeSound() override {
        cout << "Гав!" << endl;
    }
};

class Cat : public Animal {
public:
    void makeSound() override {
        cout << "Мяу!" << endl;
    }
};

// Animal a; // Ошибка! Нельзя создать объект абстрактного класса
Dog d;
d.makeSound(); // Гав!
d.breathe();   // Дышу (используется реализация из базового класса)
```

**Ключевые пункты:**
*   Нельзя создать объект абстрактного класса.
*   Может содержать как чисто виртуальные методы (контракт), так и обычные методы с реализацией (повторно используемый код).
*   Если класс-наследник не реализует все чисто виртуальные методы, он тоже становится абстрактным.

---

### 3. Класс-интерфейс (Интерфейс)

**Интерфейс** — это *частный случай абстрактного класса*. Это полностью абстрактный класс, который **не содержит реализации и данных (состояния)**.

**Его цель:** Четко определить **контракт** или набор обязательств, которые должен выполнить класс, который его реализует. Интерфейс отвечает на вопрос "Что объект должен уметь делать?", а не "Как он это делает?" или "Из чего он состоит?".

**Как создается?** В C++ интерфейс — это класс, в котором **все методы являются чисто виртуальными**, и обычно нет полей данных (кроме, возможно, статических констант).

**Пример:**
```cpp
// Класс-интерфейс
class Drawable {
public:
    virtual void draw() const = 0;
    virtual ~Drawable() {} // Виртуальный деструктор - обязателен для полиморфного удаления
};

// Другой интерфейс
class Clickable {
public:
    virtual void onClick() = 0;
};

// Класс, реализующий несколько интерфейсов (множественное наследование)
class Button : public Drawable, public Clickable {
public:
    void draw() const override {
        cout << "Рисую кнопку на экране" << endl;
    }
    void onClick() override {
        cout << "Кнопка нажата!" << endl;
    }
};

// Использование
Button btn;
Drawable* d = &btn;
d->draw(); // Рисую кнопку на экране

Clickable* c = &btn;
c->onClick(); // Кнопка нажата!
```

**Ключевые пункты:**
*   Служит для определения **чистого контракта**.
*   Позволяет реализовать **множественное наследование** в C++ (класс может реализовывать много интерфейсов), что безопасно, в отличие от наследования реализаций от нескольких классов.
*   Основной механизм для достижения **слабого зацепления (loose coupling)** между компонентами системы.

---

### Сравнительная таблица

| Признак | Полиморфный класс | Абстрактный класс | Класс-интерфейс |
| :--- | :--- | :--- | :--- |
| **Можно создать объект?** | Да | Нет | Нет |
| **Содержит реализацию методов?** | Да | **Может содержать** (обычные методы) | **Нет** (только чисто виртуальные) |
| **Содержит данные (поля)?** | Да | Да | **Обычно нет** (только константы) |
| **Цель** | Дать базовую реализацию, которую можно изменить | Задать частичный контракт + общую реализацию | Задать **полный контракт** без реализации |
| **Наследование** | Одиночное | Одиночное | **Множественное** (в C++) |
| **Ключевое слово** | `virtual` | `virtual ... = 0` | `virtual ... = 0` для всех методов |

### Как они работают вместе?

В хорошо спроектированной системе:
1.  **Интерфейсы** (`Drawable`, `Clickable`) определяют контракты.
2.  **Абстрактные классы** (`AbstractButton`) могут предоставлять частичную реализацию для этих интерфейсов, уменьшая дублирование кода.
3.  **Конкретные полиморфные классы** (`ImageButton`, `TextButton`) наследуются от абстрактных классов и реализуют оставшиеся методы, предоставляя конечную функциональность.

Это позволяет писать гибкий, расширяемый и легко поддерживаемый код.