При обычном наследовании:

1. Сначала располагаются поля базового класса
    
2. Затем поля производного класса
    

При множественном наследовании:

- Поля базовых классов располагаются в порядке их объявления
## Расположение полей классов в памяти при наследовании

### 1. **Единичное наследование**

```cpp
class Base {
public:
    int a = 1;    // offset 0
    int b = 2;    // offset 4
};

class Derived : public Base {
public:
    int c = 3;    // offset 8
    int d = 4;    // offset 12
};

// Расположение в памяти:
// [Base::a][Base::b][Derived::c][Derived::d]
//   0-3      4-7       8-11        12-15
```

### 2. **Множественное наследование**

```cpp
class Base1 {
public:
    int a = 1;    // offset 0
    int b = 2;    // offset 4
};

class Base2 {
public:
    int x = 10;   // offset 0 (в своём подобъекте)
    int y = 20;   // offset 4
};

class Derived : public Base1, public Base2 {
public:
    int c = 3;    // offset 16 (после Base1 и Base2)
};

// Расположение в памяти:
// [Base1::a][Base1::b][Base2::x][Base2::y][Derived::c]
//   0-3      4-7       8-11      12-15     16-19
```

### 3. **Виртуальные методы и vptr**

```cpp
class Base {
public:
    virtual void foo() {}   // Добавляет vptr
    int a = 1;              // offset 8 (если vptr занимает 8 байт)
};

class Derived : public Base {
public:
    int b = 2;              // offset 12
};

// Расположение (64-bit system):
// [vptr][Base::a][Derived::b]
//  0-7    8-11     12-15
```

### 4. **Виртуальное наследование (diamond problem)**

```cpp
class Base {
public:
    int a = 1;    // offset в общем подобъекте Base
};

class Left : virtual public Base {
public:
    int b = 2;    // offset 0
    // + указатель на виртуальную базу
};

class Right : virtual public Base {
public:
    int c = 3;    // offset 0
    // + указатель на виртуальную базу
};

class Derived : public Left, public Right {
public:
    int d = 4;    // offset после Left и Right
};

// Расположение в памяти (примерное):
// [Left::b][Left::vptr][Right::c][Right::vptr][Derived::d][Base::a]
// Объект Base размещается ОДИН раз, а Left и Right содержат указатели на него
```

### 5. **Порядок размещения при разных типах наследования**

```cpp
class A { int a; };
class B { int b; };
class C { int c; };

// 1. Порядок в памяти: поля в порядке объявления в классе
// 2. Базовые классы: в порядке наследования

class Derived : public A, public B, public C {
    int d;
    int e;
};

// Расположение:
// [A::a][B::b][C::c][Derived::d][Derived::e]
```

### 6. **Выравнивание (alignment)**

```cpp
class Base {
    char ch;      // offset 0
    // 3 байта padding для выравнивания int
    int num;      // offset 4
};

class Derived : public Base {
    char ch2;     // offset 8
    // 7 байт padding (если выравнивание 8)
};

// Размеры (при выравнивании 4):
// Base: 8 байт (1 + 3pad + 4)
// Derived: 12 байт (8 + 1 + 3pad)
```

### 7. **Пустой базовый класс (Empty Base Optimization - EBO)**

```cpp
class Empty {
    // Нет полей данных
};

class NotEmpty {
    int x;
};

class Derived1 : public Empty {
    int y;
    // Размер может быть = sizeof(int), если компилятор использует EBO
};

class Derived2 : public NotEmpty {
    int y;
    // Размер = sizeof(NotEmpty) + sizeof(int) (+ возможное выравнивание)
};
```

### 8. **Доступ через указатели и смещения**

```cpp
class Base {
public:
    int a = 100;
};

class Derived : public Base {
public:
    int b = 200;
};

Derived d;
Base* pb = &d;  // pb указывает на начало Base подобъекта

// Смещения можно проверить:
cout << "&d: " << &d << endl;
cout << "pb: " << pb << endl;  // Тот же адрес
cout << "&d.b: " << &d.b << endl;  // Смещение sizeof(Base) байт

// Преобразование указателей:
Derived* pd = static_cast<Derived*>(pb);  // Обратно к Derived
```

### 9. **Таблицы виртуальных методов (vtable)**

```cpp
class Base {
public:
    virtual void f1() {}
    virtual void f2() {}
    int a;
};

class Derived : public Base {
public:
    virtual void f1() override {}  // Переопределяет
    virtual void f3() {}           // Новая виртуальная
    int b;
};

// Vtable для Base:
// [&Base::f1][&Base::f2]

// Vtable для Derived:
// [&Derived::f1][&Base::f2][&Derived::f3]
```

### 10. **Множественное наследование с виртуальными функциями**

```cpp
class Base1 {
public:
    virtual void f1() {}
    int a;
};

class Base2 {
public:
    virtual void f2() {}
    int b;
};

class Derived : public Base1, public Base2 {
public:
    virtual void f1() override {}
    virtual void f2() override {}
    virtual void f3() {}
    int c;
};

// Расположение:
// [vptr1][Base1::a][vptr2][Base2::b][Derived::c]
// Две разные vtable:
// vptr1: &Derived::f1, &Base1::f2?
// vptr2: &Derived::f2 (возможно с thunk)
```

### 11. **Изменение уровня доступа и расположение**

```cpp
class Base {
private:
    int private_data;  // Все равно занимает место в памяти
public:
    int public_data;
};

class Derived : public Base {
    // Не имеет доступа к private_data, но он всё равно есть в памяти
    int extra_data;
};
```

### 12. **Проверка смещений через offsetof**

```cpp
#include <cstddef>

class Base {
public:
    int x;
    char c;
};

class Derived : public Base {
public:
    double d;
    int y;
};

cout << "offset of Base::x: " << offsetof(Base, x) << endl;      // 0
cout << "offset of Base::c: " << offsetof(Base, c) << endl;      // 4
cout << "offset of Derived::d: " << offsetof(Derived, d) << endl; // 8 (после Base)
```

### 13. **Влияние спецификаторов упаковки (packing)**

```cpp
#pragma pack(push, 1)  // Без выравнивания
class PackedBase {
    char a;
    int b;
};  // Размер = 5 байт

class PackedDerived : public PackedBase {
    char c;
};  // Размер = 6 байт
#pragma pack(pop)

// Без pragma pack размер был бы 8 и 12 байт
```

## Ключевые принципы:

1. **Порядок размещения**: базовые классы в порядке наследования, затем поля производного класса в порядке объявления
2. **Выравнивание**: компилятор добавляет padding для выравнивания полей
3. **Виртуальные функции**: добавляют vptr (обычно в начале объекта)
4. **Виртуальное наследование**: добавляет указатели на общие базовые классы
5. **Множественное наследование**: каждый базовый класс имеет свой подобъект
6. **EBO**: компилятор может оптимизировать пустые базовые классы
7. **Доступ через указатели**: приведение типов может менять значение указателя

## Практический пример анализа:

```cpp
#include <iostream>

class A {
public:
    int a1;
    char a2;
};

class B {
public:
    int b1;
    virtual void foo() {}
};

class C : public A, public B {
public:
    int c1;
    char c2;
};

int main() {
    std::cout << "sizeof(A): " << sizeof(A) << std::endl;  // 8 (4 + 1 + 3padding)
    std::cout << "sizeof(B): " << sizeof(B) << std::endl;  // 16 (8vptr + 4 + 4padding)
    std::cout << "sizeof(C): " << sizeof(C) << std::endl;  // 32 (8 + 16 + 8)
    
    C obj;
    std::cout << "Адреса:\n";
    std::cout << "&obj: " << &obj << std::endl;
    std::cout << "&obj.a1: " << &obj.a1 << std::endl;
    std::cout << "&obj.b1: " << &obj.b1 << std::endl;
    std::cout << "&obj.c1: " << &obj.c1 << std::endl;
}
```

## Важные замечания:

1. **Порядок в памяти зависит от компилятора** (но обычно следует описанным правилам)
2. **Выравнивание зависит от платформы** (4 байта для x86, 8 для x64)
3. **Виртуальные таблицы** - реализационная деталь, но общая концепция
4. **Для точного контроля** используйте `#pragma pack` или атрибуты выравнивания
5. **Избегайте предположений** о точном расположении в кроссплатформенном коде