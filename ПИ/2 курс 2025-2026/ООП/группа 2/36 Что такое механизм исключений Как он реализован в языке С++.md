**Механизм исключений (exception handling)** — это система обработки ошибок в языках программирования, позволяющая отделить нормальный поток выполнения программы от кода обработки аварийных ситуаций. В C++ он реализован через три ключевых слова: `try`, `catch` и `throw`.

## **Как это работает в C++**

### **Базовый механизм**

```cpp
try {
    // Код, который МОЖЕТ выбросить исключение
    throw SomeException("Ошибка!");  // 1. Бросок исключения
}
catch (SomeException& e) {
    // 2. Обработка исключения типа SomeException
}
catch (const std::exception& e) {
    // 3. Обработка всех исключений-наследников std::exception
}
catch (...) {
    // 4. Обработка ЛЮБОГО исключения (перехват "всего")
}
```

## **Три составляющих механизма**

### **1. `throw` — бросок исключения**
```cpp
// Можно бросать любой тип
throw 42;  // int
throw "Error!";  // const char*
throw std::string("Error string");

// Но лучше использовать стандартные или пользовательские классы исключений
throw std::runtime_error("File not found");
throw MyCustomException("Custom error", error_code);
```

### **2. `try` — блок наблюдения**
```cpp
try {
    // Любой код, который может выбросить исключение
    function_that_may_throw();
    another_risky_function();
}
```

### **3. `catch` — блоки обработки**
```cpp
catch (const std::exception& e) {
    // Константная ссылка - оптимально (избегаем копирования)
    std::cerr << "Error: " << e.what() << std::endl;
}

catch (int error_code) {
    // Перехват по значению
    std::cerr << "Error code: " << error_code << std::endl;
}

catch (...) {  // Catch-all handler
    // Не знаем, что поймали, но нужно аварийно завершить операцию
    cleanup_resources();
    throw;  // Пробрасываем исключение дальше
}
```

## **Стандартная иерархия исключений C++**

```
std::exception
├── std::logic_error        (ошибки логики, можно обнаружить до выполнения)
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   └── std::out_of_range
├── std::runtime_error      (ошибки времени выполнения)
│   ├── std::range_error
│   ├── std::overflow_error
│   ├── std::underflow_error
│   └── std::system_error
└── std::bad_alloc          (неудачное выделение памяти)
```

## **Пользовательские исключения**

```cpp
#include <stdexcept>
#include <string>

class FileOpenException : public std::runtime_error {
private:
    std::string filename;
    int error_code;
    
public:
    FileOpenException(const std::string& fname, int code)
        : std::runtime_error("Cannot open file: " + fname),
          filename(fname), error_code(code) {}
    
    const std::string& get_filename() const { return filename; }
    int get_error_code() const { return error_code; }
};

// Использование
void open_file(const std::string& name) {
    if (!file_exists(name)) {
        throw FileOpenException(name, 2);  // ERROR_FILE_NOT_FOUND
    }
    // ...
}
```

## **Что происходит при выбросе исключения?**

### **Раскрутка стека (Stack Unwinding)**
```cpp
void function3() {
    throw std::runtime_error("Error in function3");
    // 1. Поиск обработчика в function3 - не найден
}

void function2() {
    SomeResource resource;  // RAII объект
    function3();
    // 2. function2 завершается, resource.~SomeResource() ВЫЗЫВАЕТСЯ
    // 3. Поиск обработчика в function2 - не найден
}

void function1() {
    try {
        function2();
    }
    catch (const std::exception& e) {
        // 4. Обработчик НАЙДЕН здесь
        std::cout << "Caught: " << e.what() << std::endl;
    }
}

// При вызове function1() произойдет:
// 1. Бросок исключения в function3
// 2. Выход из function3
// 3. Выход из function2 с вызовом деструктора resource
// 4. Переход к catch-блоку в function1
```

### **Гарантии безопасности исключений**

1. **Базовая гарантия (Basic guarantee)** — при выбросе исключения программа остается в консистентном состоянии, нет утечек ресурсов.
2. **Строгая гарантия (Strong guarantee)** — операция либо выполняется полностью, либо откатывается (транзакционность).
3. **Гарантия отсутствия исключений (No-throw guarantee)** — функция никогда не выбрасывает исключений (помечается `noexcept`).

## **Ключевое слово `noexcept` (C++11 и выше)**

```cpp
// Функция, которая НИКОГДА не выбрасывает исключений
void safe_function() noexcept {
    // Если здесь выбросить исключение - вызовется std::terminate()
}

// Условный noexcept
template<typename T>
void swap(T& a, T& b) noexcept(noexcept(T(std::move(a))) && 
                                 noexcept(a.operator=(std::move(b)))) {
    // Реализация swap
}

// Преимущества:
// 1. Компилятор может лучше оптимизировать
// 2. Явный контракт для пользователей
// 3. Используется в move-конструкторах для оптимизации
```

## **Особенности и нюансы**

### **1. Работа с конструкторами и деструкторами**
```cpp
class ResourceHolder {
    int* resource;
    
public:
    ResourceHolder() : resource(new int[100]) {
        // Если здесь выбросить исключение - деструктор НЕ вызывается
        // Но память, выделенная в списке инициализации, освобождается
    }
    
    ~ResourceHolder() noexcept {  // Деструкторы должны быть noexcept!
        delete[] resource;
        // В деструкторах НЕЛЬЗЯ бросать исключения!
        // Иначе вызовется std::terminate()
    }
};
```

### **2. Неперехваченные исключения**
```cpp
void dangerous() {
    throw std::runtime_error("Не будет перехвачено!");
}

int main() {
    dangerous();  // Исключение не перехвачено
    return 0;     // Вызовется std::terminate()
}
```

### **3. Повторный бросок исключения**
```cpp
try {
    // ...
}
catch (const std::exception& e) {
    // Частичная обработка
    log_error(e.what());
    throw;  // Пробрасываем то же исключение дальше
    // НЕ throw e; (это создаст копию и потеряет полиморфизм)
}
```

### **4. Исключения и наследование**
```cpp
class Base {
public:
    virtual void foo() { /* может бросать */ }
    virtual ~Base() = default;
};

class Derived : public Base {
public:
    void foo() noexcept override {  // Уже нельзя бросать!
        // Не может бросать исключения
    }
};
```

## **Реализация под капотом**

### **Таблицы исключений (Exception Tables)**
Компилятор генерирует специальные таблицы для каждой функции:
- Какие исключения могут быть выброшены
- Где находятся обработчики `catch`
- Какие деструкторы нужно вызвать при раскрутке стека

### **Пример низкоуровневой реализации**
```cpp
// Упрощенное представление того, что генерирует компилятор
void function() {
    // Компилятор создает структуру:
    struct ExceptionFrame {
        void* cleanup_routine;  // Функция очистки
        ExceptionFrame* prev;    // Предыдущий фрейм
        int handler_table;       // Таблица обработчиков
    };
    
    // При входе в функцию фрейм помещается в стек
    // При throw - ищется подходящий handler по таблицам
    // При нахождении - вызываются все cleanup_routine по цепочке
}
```

### **Стоимость исключений**
1. **Время выполнения**: даже когда исключения не выбрасываются, есть небольшие накладные расходы
2. **Размер исполняемого файла**: увеличивается из-за таблиц исключений
3. **Производительность при выбросе**: дорогая операция (раскрутка стека, поиск обработчика)

## **Лучшие практики**

```cpp
// 1. Бросайте по значению, ловите по константной ссылке
catch (const std::exception& e)  // ✓ Правильно
catch (std::exception e)         // ✗ Копирование (медленно)

// 2. Порядок catch-блоков: от специфичных к общим
catch (const FileOpenException& e)  // Сначала специфичные
catch (const std::runtime_error& e) // Потом более общие
catch (const std::exception& e)     // Затем самые общие
catch (...)                         // В самом конце

// 3. Используйте RAII для управления ресурсами
{
    std::ofstream file("data.txt");  // Закроется автоматически
    throw std::runtime_error("Oops"); // Деструктор file вызовется!
}

// 4. Не злоупотребляйте исключениями для контроля потока
// ✗ Плохо: исключения для нормальной логики
// ✓ Хорошо: исключения только для исключительных ситуаций

// 5. Помечайте функции noexcept когда возможно
void simple_calculation() noexcept { ... }
```

## **Сравнение с другими языками**

| Язык | Механизм | Особенности |
|------|----------|-------------|
| **C++** | `try`/`catch`/`throw` | Раскрутка стека, RAII, дорогой `throw` |
| **Java** | `try`/`catch`/`finally` | Checked/unchecked исключения, всегда есть стек-трейс |
| **Python** | `try`/`except`/`finally` | Легковесные, часть нормального потока (EAFP) |
| **Go** | `panic()`/`recover()` | Только для фатальных ошибок, не для контроля потока |
| **Rust** | `panic!()`/`Result<T,E>` | Два механизма: невосстановимые и обрабатываемые ошибки |

**Исключения в C++** — мощный, но дорогой механизм. Они идеально подходят для обработки редких, серьезных ошибок, когда нужно гарантировать освобождение ресурсов через RAII. Для ожидаемых ошибок (валидация ввода, поиск элементов) часто лучше использовать `std::optional`, `std::expected` или коды возврата.