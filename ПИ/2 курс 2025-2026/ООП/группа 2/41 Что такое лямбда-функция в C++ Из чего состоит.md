# **Лямбда-функции в C++**

## **Что такое лямбда-функция?**

**Лямбда-функция (лямбда-выражение, лямбда)** — это анонимная (безымянная) функция, определяемая в месте использования. Это удобный способ создать функциональный объект (функтор) на лету без объявления отдельного класса или функции.

### **Исторический контекст**
```cpp
// До C++11: функторы (объекты-функции)
struct Multiply {
    int factor;
    Multiply(int f) : factor(f) {}
    int operator()(int x) const { return x * factor; }
};

// Использование
Multiply multBy2(2);
int result = multBy2(5);  // 10

// C++11 и позже: лямбда
auto lambda = [factor = 2](int x) { return x * factor; };
int result2 = lambda(5);  // 10
```

## **Анатомия лямбда-выражения**

### **Полный синтаксис**
```cpp
[захват] (параметры) -> возвращаемый_тип { тело } (вызов)
  ↑         ↑           ↑              ↑       ↑
  |         |           |              |       Необязательный вызов
  |         |           |              Код функции
  |         |           Явное указание типа возвращаемого значения
  |         Список параметров (может быть пустым)
  Список захвата переменных из внешней области видимости
```

### **Практический пример с разбором**
```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;
    
    // Полная форма лямбды
    auto lambda = [x, &y](int z) -> int {
        // x захвачено по значению, y по ссылке
        return x + y + z;
    };
    
    std::cout << lambda(5) << std::endl;  // 10 + 20 + 5 = 35
    
    // Изменяем y
    y = 30;
    std::cout << lambda(5) << std::endl;  // 10 + 30 + 5 = 45
    // x не изменилось, так как захвачено по значению
    
    return 0;
}
```

## **Компоненты лямбда-выражения**

### **1. Список захвата (Capture Clause)**
Определяет, какие переменные из внешней области видимости доступны внутри лямбды и как они передаются.

#### **Варианты захвата:**
```cpp
int a = 1, b = 2, c = 3;

// [] - ничего не захватывает
auto lambda1 = []() { /* нет доступа к a, b, c */ };

// [=] - захватывает все по значению (скопирует)
auto lambda2 = [=]() { return a + b + c; };

// [&] - захватывает все по ссылке
auto lambda3 = [&]() { a++; b++; c++; };

// [a, &b] - захватывает a по значению, b по ссылке
auto lambda4 = [a, &b]() { b = a + b; };

// [=, &c] - захватывает все по значению, кроме c (по ссылке)
auto lambda5 = [=, &c]() { c = a + b; };

// [&, a] - захватывает все по ссылке, кроме a (по значению)
auto lambda6 = [&, a]() { b = a + c; };

// C++14: захват с инициализацией
auto lambda7 = [value = a + b]() { return value; };
auto lambda8 = [ptr = std::make_unique<int>(42)]() { return *ptr; };
```

#### **mutable для захвата по значению**
```cpp
#include <iostream>

int main() {
    int counter = 0;
    
    // Без mutable - нельзя изменить захваченные по значению переменные
    auto lambda1 = [counter]() mutable {
        counter++;  // Ошибка без mutable!
        std::cout << "Counter inside: " << counter << std::endl;
    };
    
    lambda1();  // Counter inside: 1
    lambda1();  // Counter inside: 2
    std::cout << "Counter outside: " << counter << std::endl;  // 0
    
    // Ссылка всегда позволяет изменение
    auto lambda2 = [&counter]() {
        counter++;
        std::cout << "Counter inside: " << counter << std::endl;
    };
    
    lambda2();  // Counter inside: 1
    lambda2();  // Counter inside: 2
    std::cout << "Counter outside: " << counter << std::endl;  // 2
    
    return 0;
}
```

### **2. Список параметров**
Аналогичен параметрам обычной функции.

```cpp
// Без параметров
auto lambda1 = []() { return 42; };

// С параметрами
auto lambda2 = [](int x, int y) { return x + y; };

// Автовыведение типов параметров (C++14)
auto lambda3 = [](auto x, auto y) { return x + y; };
std::cout << lambda3(1, 2) << std::endl;        // 3
std::cout << lambda3(1.5, 2.5) << std::endl;    // 4.0
std::cout << lambda3(std::string("a"), "b") << std::endl; // "ab"

// Шаблонные лямбды (C++20)
auto lambda4 = []<typename T>(T x, T y) { return x + y; };
auto lambda5 = []<typename T, typename U>(T x, U y) { return x + y; };
```

### **3. Возвращаемый тип**
Может быть указан явно или выведен компилятором автоматически.

```cpp
// Автовыведение типа (return int)
auto lambda1 = [](int x) { return x * 2; };

// Явное указание типа
auto lambda2 = [](int x) -> double { return x / 2.0; };

// Несколько return - должен быть один тип
auto lambda3 = [](int x) {
    if (x > 0) {
        return x * 1.5;  // double
    } else {
        return x * 2;    // int - ОШИБКА: разные типы
    }
};

// Решение - явное указание типа
auto lambda4 = [](int x) -> double {
    if (x > 0) {
        return x * 1.5;
    } else {
        return x * 2.0;
    }
};
```

### **4. Тело функции**
Содержит исполняемый код лямбды.

```cpp
auto complex_lambda = [](const std::vector<int>& v) {
    if (v.empty()) {
        return 0;
    }
    
    int sum = 0;
    for (int x : v) {
        sum += x;
    }
    
    return sum / static_cast<double>(v.size());
};
```

## **Что происходит под капотом?**

### **Компилятор преобразует лямбду в анонимный класс**
```cpp
// Исходный код:
int x = 10;
auto lambda = [x](int y) { return x + y; };

// Преобразуется примерно так:
class __lambda_anonymous {
private:
    int x;  // Захваченная переменная
    
public:
    __lambda_anonymous(int _x) : x(_x) {}
    
    // Оператор вызова функции
    int operator()(int y) const {
        return x + y;
    }
};

// Использование
__lambda_anonymous lambda(x);
int result = lambda(5);  // 15
```

### **Пример с mutable**
```cpp
// mutable лямбда
int counter = 0;
auto lambda = [counter]() mutable {
    counter++;
    return counter;
};

// Преобразуется в:
class __lambda_anonymous {
private:
    int counter;  // Не const!
    
public:
    __lambda_anonymous(int _counter) : counter(_counter) {}
    
    // operator() НЕ const из-за mutable
    int operator()() {
        counter++;
        return counter;
    }
};
```

## **Особенности и версии C++**

### **C++11: базовые лямбды**
```cpp
// Основные возможности
auto sum = [](int a, int b) { return a + b; };

// Захват переменных
int x = 5, y = 10;
auto lambda = [x, &y]() { y += x; };

// Возвращаемый тип
auto get_int = []() -> int { return 42; };
```

### **C++14: улучшения**
```cpp
// Захват с инициализацией
auto lambda1 = [value = 42]() { return value; };

// Обобщенные лямбды (auto параметры)
auto lambda2 = [](auto x, auto y) { return x + y; };

// Возвращаемый тип decltype(auto)
auto lambda3 = [](const auto& x) -> decltype(auto) { 
    return x;  // Сохраняет тип и категорию значения
};
```

### **C++17: constexpr лямбды**
```cpp
// Лямбды могут быть constexpr
constexpr auto square = [](int n) constexpr {
    return n * n;
};

static_assert(square(5) == 25);  // Ошибки компиляции не будет

// Захват *this (все члены объекта по значению)
struct S {
    int value;
    
    auto get_lambda() {
        // C++14: [*this] - захватывает копию объекта
        return [*this]() { return value; };
    }
};
```

### **C++20: шаблонные лямбды и улучшения**
```cpp
// Явные шаблонные параметры
auto lambda1 = []<typename T>(T a, T b) { return a + b; };
auto lambda2 = []<typename T, typename U>(T t, U u) { return t + u; };

// Захват параметр-пакет
template<typename... Args>
auto make_lambda(Args... args) {
    return [...args = std::move(args)] {
        // использовать args...
    };
}

// Лямбды в unevaluated контекстах
using LambdaType = decltype([](int x) { return x * 2; });
```

## **Практическое применение**

### **1. Алгоритмы STL**
```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // Фильтрация: оставить только четные числа
    numbers.erase(
        std::remove_if(numbers.begin(), numbers.end(),
                       [](int n) { return n % 2 != 0; }),
        numbers.end()
    );
    
    // Преобразование: умножить каждый элемент на 2
    std::transform(numbers.begin(), numbers.end(), numbers.begin(),
                   [](int n) { return n * 2; });
    
    // Сортировка по убыванию
    std::sort(numbers.begin(), numbers.end(),
              [](int a, int b) { return a > b; });
    
    // Поиск: найти первый элемент больше 6
    auto it = std::find_if(numbers.begin(), numbers.end(),
                           [](int n) { return n > 6; });
    
    // Вывод
    std::for_each(numbers.begin(), numbers.end(),
                  [](int n) { std::cout << n << " "; });
    
    return 0;
}
```

### **2. Асинхронные операции и callback-и**
```cpp
#include <future>
#include <thread>
#include <iostream>

void async_operation(std::function<void(int)> callback) {
    std::thread([callback]() {
        std::this_thread::sleep_for(std::chrono::seconds(1));
        callback(42);  // Вызываем callback с результатом
    }).detach();
}

int main() {
    // Лямбда как callback
    async_operation([](int result) {
        std::cout << "Результат: " << result << std::endl;
    });
    
    // std::async с лямбдой
    auto future = std::async(std::launch::async, []() {
        return std::string("Hello from async!");
    });
    
    std::cout << future.get() << std::endl;
    
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 0;
}
```

### **3. Создание фабрик функций**
```cpp
#include <functional>
#include <iostream>
#include <memory>

// Фабрика, создающая функции-умножители
auto make_multiplier(int factor) {
    // Возвращаем лямбду, которая запоминает factor
    return [factor](int value) { return value * factor; };
}

// Каррирование (частичное применение)
auto add = [](int a, int b) { return a + b; };
auto add_five = [](int b) { return add(5, b); };

int main() {
    auto double_it = make_multiplier(2);
    auto triple_it = make_multiplier(3);
    
    std::cout << double_it(10) << std::endl;  // 20
    std::cout << triple_it(10) << std::endl;  // 30
    
    std::cout << add_five(10) << std::endl;   // 15
    
    return 0;
}
```

### **4. Обработка событий и GUI**
```cpp
#include <functional>
#include <vector>
#include <iostream>

class Button {
    std::vector<std::function<void()>> click_handlers;
    
public:
    void add_click_handler(std::function<void()> handler) {
        click_handlers.push_back(handler);
    }
    
    void click() {
        for (auto& handler : click_handlers) {
            handler();
        }
    }
};

int main() {
    Button button;
    int click_count = 0;
    
    // Лямбда-обработчики событий
    button.add_click_handler([&click_count]() {
        click_count++;
        std::cout << "Кликов: " << click_count << std::endl;
    });
    
    button.add_click_handler([]() {
        std::cout << "Еще один обработчик!" << std::endl;
    });
    
    button.click();
    button.click();
    
    return 0;
}
```

## **Лямбды и тип возвращаемого значения**

### **decltype с лямбдами**
```cpp
// Каждая лямбда имеет уникальный тип
auto lambda1 = []() { return 1; };
auto lambda2 = []() { return 1; };

// lambda1 и lambda2 имеют РАЗНЫЕ типы!
// static_assert(std::is_same_v<decltype(lambda1), decltype(lambda2)>); // Ошибка

// Но могут быть преобразованы в std::function
std::function<int()> func1 = lambda1;
std::function<int()> func2 = lambda2;
```

### **std::function vs auto**
```cpp
#include <functional>
#include <iostream>

// std::function - полиморфная обертка (имеет накладные расходы)
void process(std::function<int(int)> func) {
    std::cout << func(10) << std::endl;
}

// Шаблонная функция - нет накладных расходов
template<typename Func>
void process_template(Func func) {
    std::cout << func(10) << std::endl;
}

int main() {
    // Быстро: тип выводится автоматически
    auto lambda = [](int x) { return x * 2; };
    
    // Медленнее: преобразование в std::function
    process(lambda);           // Вызов с накладными расходами
    
    // Быстро: инстанцируется под конкретный тип
    process_template(lambda);  // Оптимально
    
    return 0;
}
```

## **Продвинутые техники**

### **Рекурсивные лямбды**
```cpp
#include <iostream>
#include <functional>

int main() {
    // Рекурсивная лямбда через std::function
    std::function<int(int)> factorial = [&factorial](int n) -> int {
        return n <= 1 ? 1 : n * factorial(n - 1);
    };
    
    std::cout << "5! = " << factorial(5) << std::endl;  // 120
    
    // C++14: с auto и явным захватом
    auto fibonacci = [](int n) {
        // Внутренняя лямбда, которая вызывает себя
        std::function<int(int, int, int)> fib_impl = 
            [&fib_impl](int a, int b, int n) -> int {
                return n == 0 ? a : fib_impl(b, a + b, n - 1);
            };
        
        return fib_impl(0, 1, n);
    };
    
    std::cout << "fib(10) = " << fibonacci(10) << std::endl;  // 55
    
    return 0;
}
```

### **Лямбды с переменным числом параметров (C++20)**
```cpp
#include <iostream>
#include <tuple>

template<typename... Args>
auto make_tuple_printer() {
    // Захватываем параметр-пакет
    return [...args = std::tuple<Args...>()](Args... values) {
        ((std::cout << values << " "), ...);
        std::cout << std::endl;
    };
}

int main() {
    auto printer = make_tuple_printer<int, double, std::string>();
    printer(42, 3.14, "Hello");
    
    return 0;
}
```

### **Идиома "немедленно вызываемая лямбда" (IIFE)**
```cpp
#include <iostream>
#include <string>

// IIFE = Immediately Invoked Function Expression
int main() {
    // Инициализация сложной переменной
    std::string message = []() -> std::string {
        if (std::getenv("DEBUG")) {
            return "Debug mode";
        }
        return "Production mode";
    }();  // Вызываем сразу!
    
    std::cout << message << std::endl;
    
    // Создание области видимости
    auto result = [&]() {
        int x = 10;
        int y = 20;
        // Сложные вычисления
        return x * y;
    }();  // x и y уничтожаются после вычисления
    
    std::cout << "Result: " << result << std::endl;
    
    return 0;
}
```

## **Производительность и оптимизация**

### **Захват vs параметры**
```cpp
// Плохо: захват больших объектов по значению
std::vector<int> large_data(1000000);
auto bad_lambda = [large_data]() { /* использует копию */ };

// Лучше: по ссылке (если объект живет дольше лямбды)
auto better_lambda = [&large_data]() { /* использует ссылку */ };

// Или передать как параметр
auto good_lambda = [](const std::vector<int>& data) { /* ... */ };
good_lambda(large_data);
```

### **Сравнение производительности**
```cpp
#include <chrono>
#include <iostream>
#include <functional>

void benchmark() {
    int x = 42;
    int iterations = 100000000;
    
    // 1. Лямбда с auto
    auto start1 = std::chrono::high_resolution_clock::now();
    auto lambda = [x](int y) { return x + y; };
    for (int i = 0; i < iterations; ++i) {
        volatile int result = lambda(i);  // volatile чтобы не оптимизировали
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // 2. std::function
    auto start2 = std::chrono::high_resolution_clock::now();
    std::function<int(int)> func = [x](int y) { return x + y; };
    for (int i = 0; i < iterations; ++i) {
        volatile int result = func(i);
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto duration1 = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "Лямбда с auto: " << duration1.count() << "ms\n";
    std::cout << "std::function: " << duration2.count() << "ms\n";
    std::cout << "Разница: " << static_cast<double>(duration2.count()) / duration1.count() << "x\n";
}
```

## **Золотые правила использования**

### **Когда использовать лямбды:**
1. **Короткие одноразовые операции** в алгоритмах STL
2. **Callback-функции** для асинхронных операций
3. **Инициализация сложных объектов** (IIFE)
4. **Создание замыканий** с захватом контекста

### **Когда НЕ использовать лямбды:**
1. **Сложная логика** (лучше вынести в отдельную функцию)
2. **Код, используемый в нескольких местах**
3. **Когда нужна рекурсия** (std::function имеет накладные расходы)

### **Рекомендации:**
```cpp
// 1. Используйте auto для типа лямбды
auto lambda = [](int x) { return x * 2; };

// 2. Избегайте захвата по умолчанию ([=] или [&])
// Вместо:
auto bad = [&]() { /* использует все по ссылке */ };
// Используйте:
auto good = [&specific_var]() { /* явный захват */ };

// 3. Используйте захват с инициализацией для перемещения
auto ptr = std::make_unique<int>(42);
auto lambda_with_move = [ptr = std::move(ptr)]() { /* ... */ };

// 4. Для алгоритмов STL используйте лямбды на месте
std::sort(vec.begin(), vec.end(), [](auto a, auto b) { return a < b; });

// 5. Помните о времени жизни захваченных по ссылке объектов
std::function<int()> create_lambda() {
    int local = 42;
    // ОПАСНО: local уничтожится при выходе из функции!
    return [&local]() { return local; };  // Висячая ссылка!
    
    // Безопасно: захват по значению
    return [local]() { return local; };
}
```

## **Вывод**

**Лямбда-функции в C++** — это мощный инструмент, который:
1. **Позволяет писать анонимные функции** на месте использования
2. **Автоматически захватывает контекст** через список захвата
3. **Генерирует уникальные типы** для каждой лямбды
4. **Поддерживает шаблоны и constexpr** (в современных стандартах)
5. **Интегрируется со стандартной библиотекой** и алгоритмами STL

**Ключевые преимущества:**
- **Лаконичность** кода
- **Безопасность** (захват контекста явно указан)
- **Производительность** (часто компилируется в оптимальный код)
- **Гибкость** (работает с шаблонами и auto)

**Помните:** Каждая лямбда имеет уникальный тип, и понимание механизма захвата переменных критически важно для написания корректного и эффективного кода.