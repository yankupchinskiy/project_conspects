### **Билет № 1. Наибольший общий делитель. Простые числа. Решето Эратосфена**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Делимость целых чисел. Наибольший общий делитель

### Деление с остатком

Для любых $a,b\in\mathbb Z$, $b\neq 0$, существуют и единственны $q,r\in\mathbb Z$ такие, что  
$$  
a=bq+r,\quad 0\le r<|b|.  
$$  
Число $q$ называется **целой частью** $a/b$, число $r$ — **остатком**.

### Делимость

Говорят, что число $a$ **делится** на $b$ (обозначение $b\mid a$), если в делении с остатком $a=bq+r$ остаток $r=0$.

Основные свойства делимости:

1. **Транзитивность:** если $b\mid a$ и $c\mid b$, то $c\mid a$.
    
2. Если $c\mid a_i$ для всех $i=1,\dots,k$, то $c\mid\sum_{i=1}^k \lambda_i a_i$ при любых $\lambda_i\in\mathbb Z$.
    
3. Из $b\mid a$ следует $\pm b\mid \pm a$.
    

---

### Наибольший общий делитель (НОД)

**Определение.**  
Пусть $a_1,\dots,a_k\in\mathbb N$. Число $d\in\mathbb N$ называется **наибольшим общим делителем** этих чисел, если:

- $d\mid a_i$ для всех $i$;
    
- любой другой общий делитель делит $d$.
    

Обозначения:  
$$  
\gcd(a_1,\dots,a_k),\quad D(a_1,\dots,a_k).  
$$

Выполняется оценка:  
$$  
1\le D(a_1,\dots,a_k)\le \min{a_1,\dots,a_k}.  
$$

Числа называются **взаимно простыми**, если  
$$  
D(a_1,\dots,a_k)=1.  
$$

---

### Связь НОД и НОК

Для двух чисел $a,b\in\mathbb N$ справедливо фундаментальное равенство:  
$$  
ab=D(a,b)\cdot M(a,b),  
$$  
где $M(a,b)$ — наименьшее общее кратное.

---

## 2. Простые числа

### Определение

Натуральное число $p>1$ называется **простым**, если оно делится только на $1$ и на $p$ (с точностью до знака).

Число, большее 1 и не являющееся простым, называется **составным**.

---

### Основное свойство простых чисел

Если $p$ — простое и  
$$  
p\mid ab,  
$$  
то  
$$  
p\mid a \quad \text{или} \quad p\mid b.  
$$

Это свойство лежит в основе всей теории разложения чисел.

---

### Основная теорема арифметики

Любое целое число $a\neq \pm1,0$ единственным образом (с точностью до порядка множителей) раскладывается в произведение простых чисел:  
$$  
a=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_n^{\alpha_n},\quad \alpha_i\ge1.  
$$

Из этого разложения следуют формулы:

- для НОД:  
    $$  
    D(a,b)=\prod p_i^{\min(\alpha_i,\beta_i)};  
    $$
    
- для НОК:  
    $$  
    M(a,b)=\prod p_i^{\max(\alpha_i,\beta_i)}.  
    $$
    

---

### Бесквадратные числа

Число называется **свободным от квадратов**, если в его разложении на простые множители все показатели равны 1.

Эквивалентно: $n$ свободно от квадратов тогда и только тогда, когда для любого разложения $n=ab$ выполнено $D(a,b)=1$.

---

## 3. Решето Эратосфена

### Постановка задачи

Найти все простые числа, не превосходящие заданного $N$.

---

### Алгоритм Эратосфена

**Идея.**  
Систематически вычеркивать составные числа, кратные уже найденным простым.

**Алгоритм:**

1. Выписать все числа от $2$ до $N$.
    
2. Положить $p=2$.
    
3. Вычеркнуть все числа, кратные $p$ и большие $p$.
    
4. Перейти к следующему невычеркнутому числу и положить его равным $p$.
    
5. Повторять, пока $p^2\le N$.
    

Все невычеркнутые числа в конце работы алгоритма являются простыми.

---

### Обоснование корректности

Любое составное число $a$ имеет делитель $b\le\sqrt a$. Следовательно, если $a\le N$, то оно будет вычеркнуто на шаге, соответствующем простому делителю $b$.

---

### Улучшения алгоритма

- Рассматривать только нечётные числа.
    
- Начинать вычеркивание с $p^2$.
    
- Завершать алгоритм при $p^2\ge N$.
    

---

## 4. Бесконечность множества простых чисел

**Теорема (Евклид).**  
Множество простых чисел бесконечно.

**Доказательство (идея).**  
Пусть существует конечный набор простых ${p_1,\dots,p_k}$. Рассмотрим число  
$$  
p=p_1p_2\cdots p_k+1.  
$$  
Оно не делится ни на одно из $p_i$, что приводит к противоречию.

---

## 5. Асимптотика распределения простых

Обозначим через $\pi(n)$ количество простых чисел, меньших $n$. Тогда справедливо предельное соотношение:  
$$  
\lim_{n\to\infty}\frac{\pi(n)}{n/\ln n}=1.  
$$

Следовательно, вероятность того, что случайное число порядка $n$ является простым, приблизительно равна $1/\ln n$.

---

### **Билет № 2. Алгоритмы факторизации: метод пробных делителей и метод Ферма**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Постановка задачи факторизации

**Факторизацией** натурального числа $a>1$ называется разложение его в произведение простых множителей:  
$$  
a=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}.  
$$

Задача факторизации состоит в **нахождении всех простых делителей числа и их кратностей**.  
Она является одной из ключевых задач теории чисел и имеет фундаментальное значение для криптографии.

---

## 2. Метод пробных делителей

### Идея метода

Если число $a$ составное, то у него существует простой делитель  
$$  
p\le \sqrt a.  
$$  
Следовательно, достаточно последовательно проверять делимость числа $a$ на простые числа, не превосходящие $\sqrt a$.

---

### Алгоритм пробных делителей

**Вход:** натуральное число $a>1$.  
**Выход:** разложение $a$ на простые множители.

1. Построить список простых чисел $p_0=2<p_1<\dots<p_n\le\sqrt a$ (например, с помощью решета Эратосфена).
    
2. Положить $i=0$.
    
3. Пока $p_i^2\le a$:
    
    1. Если $p_i\mid a$, то:
        
        - записать $p_i$ как простой множитель;
            
        - заменить $a:=a/p_i$;
            
        - повторить проверку для того же $p_i$.
            
    2. Иначе увеличить $i$ на 1.
        
4. Если в конце $a>1$, то $a$ является простым и добавляется в разложение.
    

---

### Корректность алгоритма

Алгоритм корректен, поскольку:

- каждый шаг либо уменьшает число $a$, либо переходит к следующему простому делителю;
    
- если после перебора всех простых $p\le\sqrt a$ остаётся $a>1$, то оно не может быть составным и, следовательно, является простым.
    

---

### Вычислительная сложность

Метод пробных делителей является **экспоненциально медленным** при росте числа бит входного числа.

В худшем случае требуется:

- перебор всех простых $p\le\sqrt a$;
    
- что даёт сложность порядка $O(\sqrt a)$ арифметических операций.
    

Метод применим только для сравнительно малых чисел.

---

## 3. Метод Ферма

### Идея метода

Метод Ферма основан на представлении нечётного числа $a$ в виде разности квадратов:  
$$  
a=x^2-y^2=(x-y)(x+y).  
$$

Если удаётся найти такие $x,y\in\mathbb N$, $x>y$, то получаем нетривиальное разложение числа $a$.

---

### Теоретическое обоснование

Пусть  
$$  
a=uv,\quad u<v,  
$$  
тогда  
$$  
x=\frac{u+v}{2},\quad y=\frac{v-u}{2},  
$$  
и  
$$  
a=x^2-y^2.  
$$

Таким образом, задача факторизации сводится к поиску такого $x$, что  
$$  
x^2-a  
$$  
является точным квадратом.

---

### Алгоритм Ферма

**Предположение:** $a$ — нечётное составное число.

1. Положить  
    $$  
    x=\lceil\sqrt a\rceil.  
    $$
    
2. Вычислить  
    $$  
    y^2=x^2-a.  
    $$
    
3. Если $y^2$ — точный квадрат, то  
    $$  
    a=(x-y)(x+y),  
    $$  
    и факторизация найдена.
    
4. Если нет — увеличить $x$ на 1 и повторить шаги 2–3.
    

---

### Корректность алгоритма

Если число $a$ является произведением двух множителей, близких по величине, то соответствующее представление в виде разности квадратов обязательно будет найдено.

---

### Эффективность метода

Метод Ферма эффективен, если:

- множители числа $a$ близки друг к другу.
    

Он крайне неэффективен, если:

- число имеет малый простой делитель;
    
- или представимо как $a=pq$ с сильно различающимися по величине $p$ и $q$.
    

В худшем случае число шагов пропорционально $(q-p)/2$.

---

## 4. Сравнение методов

|Метод|Идея|Преимущества|Недостатки|
|---|---|---|---|
|Пробных делителей|Перебор простых делителей|Простота|Очень медленный|
|Ферма|Представление разностью квадратов|Быстр для близких множителей|Неэффективен в общем случае|

---

## 5. Роль в криптографии

Оба метода:

- являются **базовыми**;
    
- используются для иллюстрации сложности факторизации;
    
- демонстрируют, почему для криптосистем (например, RSA) выбираются числа с большими и «далёкими» простыми множителями.
    

---

### **Билет № 3. Алгоритм Евклида. Оценка вычислительной сложности**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Постановка задачи

Одной из центральных задач теории делимости является **вычисление наибольшего общего делителя** двух целых чисел:  
$$  
D(a,b)=\gcd(a,b),\quad a,b\in\mathbb Z,\ (a,b)\neq(0,0).  
$$

Эта задача эффективно решается **алгоритмом Евклида**, являющимся одним из древнейших и важнейших алгоритмов математики.

---

## 2. Деление с остатком как основа алгоритма

Алгоритм Евклида опирается на теорему о делении с остатком:  
$$  
a=bq+r,\quad 0\le r<|b|.  
$$

Ключевое свойство:  
$$  
D(a,b)=D(b,r).  
$$

**Обоснование.**  
Любой общий делитель $a$ и $b$ делит $r=a-bq$, и наоборот — любой общий делитель $b$ и $r$ делит $a=bq+r$.

---

## 3. Классический алгоритм Евклида

### Формулировка алгоритма

Пусть $a,b\in\mathbb N$, $a\ge b>0$.

1. Выполнить деление:  
    $$  
    a=bq+r.  
    $$
    
2. Если $r=0$, то  
    $$  
    D(a,b)=b,  
    $$  
    алгоритм завершён.
    
3. Если $r\neq 0$, заменить  
    $$  
    a:=b,\quad b:=r  
    $$  
    и повторить шаги 1–3.
    

Алгоритм всегда завершается, так как последовательность остатков строго убывает:  
$$  
b>r_1>r_2>\dots\ge0.  
$$

---

## 4. Корректность алгоритма Евклида

Корректность алгоритма основана на инварианте:  
$$  
D(a_k,b_k)=D(a_{k+1},b_{k+1}),  
$$  
где $(a_{k+1},b_{k+1})=(b_k,r_k)$.

В момент завершения алгоритма имеем $r=0$, следовательно,  
$$  
D(a,b)=b.  
$$

---

## 5. Линейное представление НОД

Алгоритм Евклида позволяет получить представление:  
$$  
D(a,b)=ax+by,  
$$  
где $x,y\in\mathbb Z$.

Это свойство лежит в основе решения:

- линейных диофантовых уравнений;
    
- линейных сравнений.
    

(Подробное обсуждение даётся в следующих билетах.)

---

## 6. Оценка вычислительной сложности алгоритма Евклида

### Количество шагов алгоритма

Обозначим через $r_0=b,\ r_1,\ r_2,\dots$ последовательность остатков.

Наихудший случай возникает, когда частные $q_i$ равны 1, то есть:  
$$  
r_{k-1}=r_k+r_{k+1}.  
$$

В этом случае последовательность остатков совпадает с **последовательностью чисел Фибоначчи**.

---

### Связь с числами Фибоначчи

Если  
$$  
a=F_{n+1},\quad b=F_n,  
$$  
то алгоритм Евклида выполнит ровно $n$ шагов.

Так как  
$$  
F_n\sim\frac{\varphi^n}{\sqrt5},\quad \varphi=\frac{1+\sqrt5}{2},  
$$  
число шагов пропорционально логарифму входных данных.

---

### Асимптотическая оценка

Количество шагов алгоритма Евклида не превосходит:  
$$  
O(\log \min(a,b)).  
$$

Следовательно, алгоритм Евклида является **полиномиальным по длине входа** и чрезвычайно эффективным.

---

## 7. Значение алгоритма Евклида

Алгоритм Евклида:

- лежит в основе вычисления НОД;
    
- используется в криптографии;
    
- применяется при работе с остатками и сравнениями;
    
- служит базой для обобщённых и бинарных вариантов алгоритма.
    

---

### **Билет № 4. Бинарный алгоритм Евклида**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Мотивация и постановка задачи

Классический алгоритм Евклида использует операцию деления с остатком, которая является сравнительно дорогой при реализации на вычислительных устройствах.  
**Бинарный алгоритм Евклида** (алгоритм Штейна) предназначен для вычисления НОД с использованием только:

- сравнений,
    
- вычитаний,
    
- делений на 2 (сдвигов).
    

Это делает его особенно эффективным при машинной реализации.

---

## 2. Свойства НОД, лежащие в основе алгоритма

Пусть $a,b\in\mathbb N$. Используются следующие свойства:

1. Если $a=b$, то  
    $$  
    D(a,b)=a.  
    $$
    
2. Если $a$ и $b$ — чётные, то  
    $$  
    D(a,b)=2\cdot D(a/2,b/2).  
    $$
    
3. Если $a$ — чётное, $b$ — нечётное, то  
    $$  
    D(a,b)=D(a/2,b).  
    $$
    
4. Если $a$ и $b$ — нечётные, $a>b$, то  
    $$  
    D(a,b)=D\bigl((a-b)/2,b\bigr).  
    $$
    

Все эти свойства непосредственно следуют из определения НОД и свойств делимости.

---

## 3. Формулировка бинарного алгоритма Евклида

**Вход:** натуральные числа $a,b$.  
**Выход:** $D(a,b)$.

1. Если $a=0$, вернуть $b$; если $b=0$, вернуть $a$.
    
2. Найти максимальное $k$, такое что $2^k$ делит и $a$, и $b$.
    
3. Положить:  
    $$  
    a:=a/2^k,\quad b:=b/2^k.  
    $$
    
4. Пока $a\neq b$:
    
    - если $a$ чётное, заменить $a:=a/2$;
        
    - если $b$ чётное, заменить $b:=b/2$;
        
    - если $a>b$, заменить  
        $$  
        a:=(a-b)/2;  
        $$
        
    - иначе заменить  
        $$  
        b:=(b-a)/2.  
        $$
        
5. Вернуть  
    $$  
    D(a,b)=a\cdot 2^k.  
    $$
    

---

## 4. Корректность алгоритма

Корректность алгоритма обеспечивается тем, что:

- на каждом шаге сохраняется инвариант значения НОД;
    
- величины аргументов строго уменьшаются;
    
- алгоритм обязательно завершается, так как положительные целые числа не могут убывать бесконечно.
    

---

## 5. Вычислительная сложность

По числу итераций бинарный алгоритм Евклида имеет ту же асимптотическую оценку, что и классический:  
$$  
O(\log \min(a,b)).  
$$

Однако каждая итерация использует более простые операции, что делает алгоритм предпочтительным в машинной арифметике.

---

## 6. Сравнение с классическим алгоритмом Евклида

|Характеристика|Классический|Бинарный|
|---|---|---|
|Деление|Используется|Не используется|
|Основные операции|Деление с остатком|Сдвиги, вычитания|
|Асимптотика|$O(\log n)$|$O(\log n)$|
|Машинная реализация|Менее эффективна|Более эффективна|

---

## 7. Значение бинарного алгоритма

Бинарный алгоритм Евклида:

- широко применяется в компьютерной арифметике;
    
- используется в криптографических алгоритмах;
    
- служит основой для оптимизированных библиотек длинной арифметики.
    

---

### **Билет № 5. Обобщённый алгоритм Евклида**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Постановка задачи

Классический алгоритм Евклида позволяет вычислять $D(a,b)$ для двух целых чисел.  
**Обобщённый алгоритм Евклида** расширяет эту процедуру и позволяет:

1. вычислять НОД нескольких целых чисел;
    
2. находить **линейное представление НОД** в виде целочисленной линейной комбинации аргументов.
    

---

## 2. Линейная комбинация и НОД

### Линейная комбинация

Для чисел $a_1,\dots,a_n\in\mathbb Z$ выражение  
$$  
x_1a_1+x_2a_2+\dots+x_na_n,\quad x_i\in\mathbb Z,  
$$  
называется **целочисленной линейной комбинацией**.

---

### Теорема (о линейном представлении НОД)

Для любых $a_1,\dots,a_n\in\mathbb Z$, не равных одновременно нулю, существует представление:  
$$  
D(a_1,\dots,a_n)=x_1a_1+x_2a_2+\dots+x_na_n,  
$$  
где $x_i\in\mathbb Z$.

---

## 3. Обобщение алгоритма Евклида на несколько чисел

НОД нескольких чисел вычисляется итеративно:  
$$  
D(a_1,a_2,\dots,a_n)=D(D(a_1,a_2),a_3,\dots,a_n).  
$$

На каждом шаге используется стандартный алгоритм Евклида для пары чисел.

---

## 4. Обобщённый алгоритм Евклида для двух чисел

### Расширенная форма алгоритма

Пусть $a,b\in\mathbb Z$, $a\ge b>0$. В процессе работы алгоритма Евклида фиксируются равенства:  
$$  
\begin{aligned}  
a &= bq_1+r_1,\  
b &= r_1q_2+r_2,\  
&\vdots\  
r_{k-2} &= r_{k-1}q_k+r_k,\  
r_{k-1} &= r_kq_{k+1}.  
\end{aligned}  
$$

Последний ненулевой остаток $r_k=D(a,b)$.

---

### Обратный ход алгоритма

Выражая последовательно остатки $r_i$ через предыдущие, получаем:  
$$  
D(a,b)=ax+by,  
$$  
где коэффициенты $x,y\in\mathbb Z$ вычисляются однозначно в ходе обратной подстановки.

---

## 5. Вычисление коэффициентов

Коэффициенты $x,y$:

- могут быть найдены одновременно с вычислением НОД;
    
- зависят от последовательности частных $q_i$;
    
- не являются единственными: если $(x,y)$ — решение, то  
    $$  
    x'=x+\frac{b}{D(a,b)}k,\quad y'=y-\frac{a}{D(a,b)}k,\quad k\in\mathbb Z  
    $$  
    также является решением.
    

---

## 6. Значение обобщённого алгоритма Евклида

Обобщённый алгоритм Евклида:

1. используется для решения **линейных диофантовых уравнений**;
    
2. лежит в основе решения **линейных сравнений**;
    
3. применяется в криптографии (нахождение обратных элементов по модулю).
    

---

### **Билет № 6. Свойства и вычисление подходящих дробей**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Цепные дроби и их роль

Понятие **подходящих дробей** возникает при изучении **конечных цепных дробей**, которые используются:

- для приближённого представления вещественных чисел рациональными;
    
- для анализа алгоритма Евклида;
    
- в задачах теории чисел и криптографии.
    

---

## 2. Конечная цепная дробь

**Определение.**  
Конечной цепной дробью называется выражение вида  
$$  
[a_0;a_1,a_2,\dots,a_n]  
= a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\dots+\cfrac{1}{a_n}}},  
$$  
где:

- $a_0\in\mathbb Z$,
    
- $a_i\in\mathbb N$ при $i\ge1$.
    

Каждая конечная цепная дробь задаёт **рациональное число**.

---

## 3. Подходящие дроби

### Определение

**Подходящими дробями** (или **конвергентами**) цепной дроби  
$$  
[a_0;a_1,a_2,\dots,a_n]  
$$  
называются дроби:  
$$  
\frac{p_k}{q_k}=[a_0;a_1,a_2,\dots,a_k],\quad k=0,1,\dots,n.  
$$

Они являются последовательными рациональными приближениями исходного числа.

---

## 4. Рекуррентные формулы

Числители $p_k$ и знаменатели $q_k$ подходящих дробей вычисляются по рекуррентным соотношениям:  
$$  
\begin{aligned}  
p_{-1}&=1,\quad p_0=a_0,\  
q_{-1}&=0,\quad q_0=1,\  
p_k&=a_k p_{k-1}+p_{k-2},\  
q_k&=a_k q_{k-1}+q_{k-2},  
\end{aligned}  
$$  
при $k\ge1$.

Эти формулы следуют непосредственно из структуры цепной дроби.

---

## 5. Основные свойства подходящих дробей

### 1. Несократимость

Каждая подходящая дробь $\dfrac{p_k}{q_k}$ является **несократимой**, то есть:  
$$  
D(p_k,q_k)=1.  
$$

---

### 2. Знак разности соседних дробей

Для любых $k\ge1$ выполняется:  
$$  
p_k q_{k-1}-p_{k-1} q_k=(-1)^{k-1}.  
$$

Это свойство играет ключевую роль в доказательствах оптимальности приближений.

---

### 3. Чередование приближений

Подходящие дроби поочерёдно:

- превосходят число,
    
- либо меньше его.
    

---

### 4. Монотонность знаменателей

Последовательность $q_k$ строго возрастает:  
$$  
1=q_0<q_1<q_2<\dots<q_n.  
$$

---

## 6. Оптимальность подходящих дробей

**Теорема.**  
Ни одна рациональная дробь с меньшим знаменателем не приближает число лучше, чем соответствующая подходящая дробь.

То есть если  
$$  
\left|x-\frac{p}{q}\right|<\left|x-\frac{p_k}{q_k}\right|,  
$$  
то обязательно $q\ge q_k$.

---

## 7. Связь с алгоритмом Евклида

Для рационального числа $x=\dfrac{a}{b}$:

- цепная дробь получается непосредственным применением алгоритма Евклида;
    
- частные $a_i$ совпадают с частными алгоритма Евклида;
    
- подходящие дроби отражают промежуточные приближения при вычислении НОД.
    

---

## 8. Практическое значение

Подходящие дроби применяются:

- при решении диофантовых уравнений;
    
- при приближении иррациональных чисел;
    
- в криптографических атаках (в частности, на RSA при малых показателях).
    

---

### **Билет № 7. Бесконечные цепные дроби. Некоторые применения цепных дробей**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Переход от конечных к бесконечным цепным дробям

Если конечная цепная дробь описывает рациональное число, то для **иррациональных чисел** естественным обобщением являются **бесконечные цепные дроби**.

Они дают наиболее точный и структурированный способ рациональных приближений иррациональных чисел.

---

## 2. Бесконечная цепная дробь

### Определение

**Бесконечной цепной дробью** называется выражение вида  
$$  
[a_0;a_1,a_2,a_3,\dots]  
= a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\cfrac{1}{\ddots}}},  
$$  
где:

- $a_0\in\mathbb Z$,
    
- $a_i\in\mathbb N$ при $i\ge1$.
    

---

### Свойство существования

Каждое иррациональное число допускает **единственное** представление в виде бесконечной цепной дроби.

Для рациональных чисел соответствующая цепная дробь является конечной.

---

## 3. Подходящие дроби бесконечной цепной дроби

Для бесконечной цепной дроби определяются подходящие дроби:  
$$  
\frac{p_k}{q_k}=[a_0;a_1,\dots,a_k],\quad k=0,1,2,\dots  
$$

Последовательность подходящих дробей:

- сходится к числу, заданному цепной дробью;
    
- даёт наилучшие рациональные приближения этого числа.
    

---

## 4. Оценка точности приближений

Для любой подходящей дроби выполняется неравенство:  
$$  
\left|x-\frac{p_k}{q_k}\right|<\frac{1}{q_k^2}.  
$$

Это означает, что точность приближения растёт квадратично с ростом знаменателя.

---

## 5. Квадратичные иррациональности

### Периодичность

**Теорема.**  
Бесконечная цепная дробь периодична тогда и только тогда, когда число является **квадратичной иррациональностью**, то есть корнем квадратного уравнения с целыми коэффициентами.

Пример:  
$$  
\sqrt n=[a_0;\overline{a_1,\dots,a_k}].  
$$

---

## 6. Применения цепных дробей

### 1. Решение диофантовых уравнений Пелля

Уравнение:  
$$  
x^2-ny^2=1  
$$  
решается с помощью периодической цепной дроби числа $\sqrt n$.

---

### 2. Приближение иррациональных чисел

Цепные дроби обеспечивают **оптимальные рациональные приближения**, недостижимые другими универсальными методами.

---

### 3. Криптографические применения

Цепные дроби используются:

- в анализе уязвимостей RSA;
    
- при атаках на RSA с малыми секретными показателями;
    
- для восстановления рациональных параметров по приближённым данным.
    

---

## 7. Связь с алгоритмом Евклида

Для рациональных чисел:

- цепная дробь полностью совпадает с работой алгоритма Евклида.
    

Для иррациональных чисел:

- процесс становится бесконечным, но сохраняет ту же структуру частных.
    

---

### **Билет № 8. Числа Фибоначчи. Теорема Цекендорфа. Система счисления Фибоначчи**

_(по учебнику С. В. Рыбина «Дискретная математика и информатика», 2022)_

---

## 1. Числа Фибоначчи

### Определение

Последовательность **чисел Фибоначчи** ${F_n}_{n\ge0}$ определяется рекуррентно:  
$$  
F_0=0,\quad F_1=1,\quad F_{n}=F_{n-1}+F_{n-2},\quad n\ge2.  
$$

Иногда используется сдвинутая нумерация:  
$$  
F_1=1,\quad F_2=1,\quad F_{n}=F_{n-1}+F_{n-2}.  
$$

---

## 2. Основные свойства чисел Фибоначчи

1. **Монотонность и рост**  
    $$  
    F_n<F_{n+1},\quad n\ge1.  
    $$
    
2. **Явная формула (формула Бине)**  
    $$  
    F_n=\frac{\varphi^n-\psi^n}{\sqrt5},  
    $$  
    где  
    $$  
    \varphi=\frac{1+\sqrt5}{2},\quad \psi=\frac{1-\sqrt5}{2}.  
    $$
    
3. **Асимптотика**  
    $$  
    F_n\sim\frac{\varphi^n}{\sqrt5}.  
    $$
    
4. **Связь с алгоритмом Евклида**  
    Наихудший случай работы алгоритма Евклида реализуется на последовательных числах Фибоначчи.
    

---

## 3. Теорема Цекендорфа

### Формулировка теоремы

**Теорема (Цекендорф).**  
Любое натуральное число $n$ можно **единственным образом** представить в виде суммы чисел Фибоначчи:  
$$  
n=F_{k_1}+F_{k_2}+\dots+F_{k_m},  
$$  
где:

- $k_1>k_2>\dots>k_m\ge2$;
    
- в представлении **не используются два соседних числа Фибоначчи**.
    

---

### Идея доказательства

1. Существование доказывается жадным алгоритмом:
    
    - на каждом шаге выбирается наибольшее $F_k\le n$;
        
    - затем вычитается и процесс повторяется.
        
2. Единственность следует из рекуррентных свойств последовательности Фибоначчи.
    

---

## 4. Жадный алгоритм Цекендорфа

**Алгоритм представления числа $n$:**

1. Найти максимальное $F_k\le n$.
    
2. Положить $n:=n-F_k$.
    
3. Повторять, пока $n>0$.
    

Алгоритм гарантированно завершится и даст корректное разложение без соседних индексов.

---

## 5. Система счисления Фибоначчи

### Определение

**Фибоначчиева система счисления** представляет число в виде бинарной последовательности:  
$$  
n=\sum_{k\ge2} a_k F_k,\quad a_k\in{0,1},  
$$  
где запрещено наличие двух подряд идущих единиц:  
$$  
a_k a_{k+1}\neq 11.  
$$

---

### Пример

Число  
$$  
n=100101_{(F)}  
$$  
означает сумму соответствующих чисел Фибоначчи.

---

## 6. Свойства системы счисления Фибоначчи

1. **Единственность представления** (по теореме Цекендорфа).
    
2. **Отсутствие переносов**, аналогичных двоичной системе.
    
3. **Связь с жадными алгоритмами**.
    

---

## 7. Применения

Числа Фибоначчи и система Цекендорфа используются:

- при анализе алгоритма Евклида;
    
- в теории кодирования;
    
- при построении нестандартных систем счисления;
    
- в криптографических алгоритмах и их анализе.
    

---

Вот билет №9, полностью переработанный в формат, пригодный для вставки в Obsidian. Все математические формулы заключены в символы `$`, структура соответствует требованиям:

---

### **Билет №9. Диофантовы уравнения**

#### **Введение и постановка темы**  
Диофантовы уравнения — это уравнения вида $ax + by = c$, где коэффициенты $a, b, c$ и неизвестные $x, y$ являются целыми числами. Такие уравнения названы в честь древнегреческого математика Диофанта Александрийского, автора труда «Арифметика». Основная задача теории диофантовых уравнений — определить условия разрешимости таких уравнений в целых числах и описать все их решения. Эти уравнения играют ключевую роль в теории чисел, криптографии и алгоритмической математике.

---

#### **Точные определения**  
**Определение 1.14** (учебник, с. 61).  
Пусть $a, b, c, x, y \in \mathbb{Z}$. Уравнение вида  
$$
ax + by = c,
$$  
где $x, y$ — неизвестные, называется **диофантовым уравнением**.

---

#### **Основные теоремы и утверждения**

##### **Теорема 1.21** (критерий разрешимости диофантового уравнения)  
Диофантово уравнение $ax + by = c$ имеет целочисленное решение тогда и только тогда, когда  
$$
d = \gcd(a, b) \mid c.
$$

##### **Теорема 1.22** (общее решение диофантового уравнения)  
Пусть $d = \gcd(a, b)$ и $d \mid c$. Пусть $(x_0, y_0)$ — некоторое частное решение уравнения $ax + by = c$. Тогда **все** целочисленные решения имеют вид:  
$$
x = x_0 - \frac{b}{d} t,\quad y = y_0 + \frac{a}{d} t,\quad t \in \mathbb{Z}.
$$

##### **Доказательства**  
**Теорема 1.21.**  
*Необходимость:* если $ax + by = c$ имеет решение, то левая часть делится на $d = \gcd(a, b)$, следовательно, и правая часть $c$ делится на $d$.  
*Достаточность:* из соотношения Безу существует пара $(u, v) \in \mathbb{Z}^2$, такая что $au + bv = d$. Умножая обе части на $c/d$, получаем решение $x_0 = u \cdot (c/d),\ y_0 = v \cdot (c/d)$.

**Теорема 1.22.**  
Пусть $(x, y)$ — произвольное решение. Вычитая из него частное решение, получаем однородное уравнение:  
$$
a(x - x_0) + b(y - y_0) = 0 \Rightarrow a(x - x_0) = -b(y - y_0).
$$  
Разделив обе части на $d$, получаем:  
$$
\frac{a}{d}(x - x_0) = -\frac{b}{d}(y - y_0).
$$  
Так как $\gcd(a/d, b/d) = 1$, то $(x - x_0)$ делится на $b/d$, а $(y - y_0)$ — на $a/d$. Отсюда следует общая форма решений.

---

#### **Алгоритмы**

##### **Алгоритм 1.16** (решение диофантового уравнения)  
**Словесное описание:**  
1. Найти $d = \gcd(a, b)$ с помощью расширенного алгоритма Евклида.  
2. Проверить делимость $c$ на $d$. Если нет — решений нет.  
3. Найти коэффициенты Безу $u, v$, такие что $au + bv = d$.  
4. Положить $x_0 = u \cdot (c/d),\ y_0 = v \cdot (c/d)$.  
5. Общее решение задаётся формулой из теоремы 1.22.

**Псевдокод (следует из описания в учебнике):**  
```text
function solve_diophantine(a, b, c):
    (d, u, v) = extended_gcd(a, b)
    if c % d != 0:
        return "No solutions"
    k = c // d
    x0 = u * k
    y0 = v * k
    return (x0, y0, d)
```

**Корректность:**  
Алгоритм корректен, поскольку основан на соотношении Безу и теоремах 1.21–1.22. Расширенный алгоритм Евклида гарантирует нахождение $u, v$ за конечное число шагов.

---

#### **Свойства, следствия, оценки сложности**

- **Число решений:** либо 0, либо бесконечно много (параметризованы целым параметром $t$).  
- **Сложность алгоритма:** совпадает со сложностью расширенного алгоритма Евклида — $O(\log \min(|a|, |b|))$.  
- **Связь с линейными сравнениями:** диофантово уравнение $ax + by = c$ эквивалентно сравнению $ax \equiv c \pmod{b}$ при $\gcd(a, b) \mid c$.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.39** (с. 86–87):  
Решить сравнение $378x \equiv 90 \pmod{120}$.  
Это эквивалентно диофантову уравнению  
$$
378x - 120y = 90.
$$  
1. $\gcd(378, 120) = 6$, и $6 \mid 90$ → решения существуют.  
2. С помощью расширенного алгоритма Евклида:  
   $$
   6 = 378 \cdot 7 + 120 \cdot (-22) \Rightarrow 90 = 378 \cdot 105 + 120 \cdot (-330).
   $$  
3. Частное решение: $x_0 = 105$.  
4. Общее решение:  
   $$
   x = 105 + 20t,\quad t \in \mathbb{Z}.
   $$  
5. По модулю 120 получаем 6 классов решений:  
   $$
   x \equiv 105, 5, 25, 45, 65, 85 \pmod{120}.
   $$

---

#### **Связи с другими темами курса**  
- Диофантовы уравнения тесно связаны с **линейными сравнениями** (раздел 1.3.4): каждое линейное сравнение сводится к диофантову уравнению.  
- Используются в **алгоритме RSA** при нахождении закрытого ключа $d$ из условия $de \equiv 1 \pmod{\varphi(m)}$, что является диофантовым уравнением $de - k\varphi(m) = 1$.  
- Обобщаются на системы линейных уравнений и применяются в **криптографии**, **теории кодирования** и **алгоритмах факторизации**.

--- 

### **Билет №10. Арифметика и свойства сравнений. Линейные сравнения**

#### **Введение и постановка темы**  
Сравнения по модулю — один из центральных инструментов теории чисел, введённый К. Гауссом в 1801 г. Они позволяют перенести идеи делимости и остатков в алгебраическую структуру, аналогичную арифметике целых чисел, но с конечным числом элементов. Сравнения находят широкое применение в криптографии, алгоритмах факторизации, решении диофантовых уравнений и других разделах дискретной математики. Особое значение имеют **линейные сравнения**, которые тесно связаны с диофантовыми уравнениями и лежат в основе многих алгоритмов, включая RSA.

---

#### **Точные определения**

**Определение 1.20** (с. 73).  
Пусть $a, b, m \in \mathbb{Z}$, $m > 0$. Говорят, что $a$ **сравнимо** с $b$ **по модулю** $m$ (обозначается $a \equiv b \pmod{m}$), если $(a - b) \vdots m$, то есть $m$ делит разность $a - b$.

**Определение 1.21** (с. 74).  
**Классом вычетов по модулю** $m$ называют множество всех целых чисел, дающих одинаковый остаток при делении на $m$.  

**Определение 1.22** (с. 74).  
Множество из $m$ чисел, содержащее по одному представителю из каждого класса вычетов по модулю $m$, называется **полной системой вычетов по модулю** $m$. Простейший пример: $\{0, 1, 2, \dots, m-1\}$.

**Определение 1.26** (с. 85).  
**Линейным сравнением** называют уравнение вида  
$$
ax \equiv b \pmod{m},
$$  
где $a, b, x, m \in \mathbb{Z}$, а $x$ — неизвестное.

---

#### **Основные теоремы и утверждения**

##### **Теорема 1.25** (свойства отношения сравнения, с. 74)  
Отношение сравнения по модулю $m$ является **отношением эквивалентности**, то есть обладает свойствами:
1. **Рефлексивности**: $a \equiv a \pmod{m}$;
2. **Симметричности**: если $a \equiv b \pmod{m}$, то $b \equiv a \pmod{m}$;
3. **Транзитивности**: если $a \equiv b \pmod{m}$ и $b \equiv c \pmod{m}$, то $a \equiv c \pmod{m}$.

##### **Теорема 1.26** (разбиение на классы, с. 76)  
Множество $\mathbb{Z}$ распадается на $m$ непересекающихся классов вычетов по модулю $m$, причём:
- все числа одного класса сравнимы между собой;
- числа из разных классов не сравнимы.

##### **Теорема 1.27** (арифметические свойства сравнений, с. 77)  
Если $a \equiv b \pmod{m}$ и $a_1 \equiv b_1 \pmod{m}$, то:
1. $a + a_1 \equiv b + b_1 \pmod{m}$,
2. $a - a_1 \equiv b - b_1 \pmod{m}$,
3. $aa_1 \equiv bb_1 \pmod{m}$,
4. $a^k \equiv b^k \pmod{m}$ для любого $k \in \mathbb{N}$.

##### **Теорема 1.28** (арифметика сравнений, с. 75)  
Сравнения по одному модулю можно почленно складывать, вычитать и перемножать.

##### **Теорема 1.31** (деление сравнений, с. 76)  
Пусть $ac \equiv bc \pmod{m}$ и $d = \gcd(c, m)$. Тогда  
$$
a \equiv b \pmod{\frac{m}{d}}.
$$

##### **Теорема 1.39** (критерий разрешимости линейного сравнения, с. 85–86)  
Рассмотрим сравнение $ax \equiv b \pmod{m}$. Пусть $d = \gcd(a, m)$. Тогда:
1. Сравнение имеет решение **тогда и только тогда**, когда $d \mid b$;
2. Если решение существует, то существует ровно $d$ различных классов решений по модулю $m$, имеющих вид:  
   $$
   x \equiv x_0 + t \cdot \frac{m}{d} \pmod{m}, \quad t = 0, 1, \dots, d-1,
   $$  
   где $x_0$ — некоторое частное решение.

##### **Следствие 1.17** (частный случай, с. 87)  
Если $p$ — простое число и $p \nmid a$, то сравнение $ax \equiv b \pmod{p}$ имеет **единственное** решение по модулю $p$.

---

#### **Алгоритмы**

##### **Алгоритм 1.17** (решение линейного сравнения, с. 87)  
**Словесное описание:**  
1. Вычислить $d = \gcd(a, m)$ с помощью расширенного алгоритма Евклида.  
2. Если $d \nmid b$, то решений нет.  
3. Иначе решить диофантово уравнение $ax - my = b$ (см. билет №9), найти частное решение $x_0$.  
4. Все решения задаются формулой:  
   $$
   x \equiv x_0 + t \cdot \frac{m}{d} \pmod{m}, \quad t = 0, 1, \dots, d-1.
   $$

**Псевдокод:**  
```text
function solve_linear_congruence(a, b, m):
    (d, u, v) = extended_gcd(a, m)
    if b % d != 0:
        return "No solutions"
    x0 = (u * (b // d)) % m
    solutions = []
    for t in 0 to d-1:
        solutions.append((x0 + t * (m // d)) % m)
    return solutions
```

**Корректность:**  
Алгоритм корректен, поскольку основан на эквивалентности линейного сравнения и диофантового уравнения $ax - my = b$, а также на теореме 1.39.

---

#### **Свойства, следствия, оценки сложности**

- **Число решений**: либо 0, либо $d = \gcd(a, m)$.  
- **Сложность**: совпадает со сложностью расширенного алгоритма Евклида — $O(\log \min(|a|, |m|))$.  
- **Обратимость**: элемент $a \in \mathbb{Z}_m$ обратим тогда и только тогда, когда $\gcd(a, m) = 1$. В этом случае сравнение $ax \equiv 1 \pmod{m}$ имеет единственное решение $x = a^{-1}$.  
- **Структура $\mathbb{Z}_m$**: согласно теореме 1.29 (с. 75), $\mathbb{Z}_m$ является **ассоциативным коммутативным кольцом с единицей**. Оно является **полем** тогда и только тогда, когда $m$ — простое число.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.39** (с. 86–87):  
Решить сравнение $378x \equiv 90 \pmod{120}$.  
1. $\gcd(378, 120) = 6$, и $6 \mid 90$ → решения существуют.  
2. Расширенный алгоритм Евклида даёт:  
   $$
   6 = 378 \cdot 7 + 120 \cdot (-22) \Rightarrow 90 = 378 \cdot 105 + 120 \cdot (-330).
   $$  
3. Частное решение: $x_0 = 105$.  
4. Общее решение:  
   $$
   x \equiv 105 + 20t \pmod{120}, \quad t = 0,1,\dots,5.
   $$  
5. По модулю 120 получаем шесть классов решений:  
   $$
   x \equiv 105, 5, 25, 45, 65, 85 \pmod{120}.
   $$

**Пример 1.41** (с. 88):  
Решить $11x \equiv 15 \pmod{24}$.  
$\gcd(11,24)=1$, $\varphi(24)=8$, тогда по теореме Эйлера:  
$$
x \equiv 11^{7} \cdot 15 \equiv 11 \cdot 15 \equiv -3 \equiv 21 \pmod{24}.
$$

---

#### **Связи с другими темами курса**  
- **Диофантовы уравнения**: линейное сравнение $ax \equiv b \pmod{m}$ эквивалентно уравнению $ax - my = b$.  
- **Функция Эйлера и теорема Эйлера–Ферма**: используются для нахождения обратных элементов и решения сравнений при $\gcd(a,m)=1$.  
- **Китайская теорема об остатках**: позволяет сводить систему сравнений к одному сравнению.  
- **RSA**: ключевой этап — решение сравнения $de \equiv 1 \pmod{\varphi(m)}$, то есть нахождение обратного элемента $d = e^{-1} \pmod{\varphi(m)}$.

--- 

### **Билет №11. Китайская теорема об остатках, алгоритмы Гаусса и Гарнера**

#### **Введение и постановка темы**  
Китайская теорема об остатках (КТО) — одно из фундаментальных утверждений в теории чисел, позволяющее восстанавливать целое число по его остаткам от деления на взаимно простые модули. Теорема имеет древнее происхождение (III век н. э., Сунь Цзы), но её значение сохраняется и в современных приложениях: криптографии (в частности, в RSA и системе остаточных классов RNS), параллельных вычислениях, алгоритмах быстрого преобразования Фурье и цифровой обработке сигналов. Важную роль играют также эффективные алгоритмы решения систем сравнений — алгоритм Гаусса и алгоритм Гарнера, отличающиеся подходом к вычислению решения.

---

#### **Точные определения**

**Определение 1.27** (с. 90).  
Пусть задана система сравнений  
$$
x \equiv c_1 \pmod{m_1},\quad x \equiv c_2 \pmod{m_2},\quad \dots,\quad x \equiv c_k \pmod{m_k},
$$  
где $m_1, m_2, \dots, m_k$ — попарно взаимно простые натуральные числа. Набор $(c_1, c_2, \dots, c_k)$ называется **китайским кодом** числа $x$.

---

#### **Основные теоремы и утверждения**

##### **Теорема 1.42** (Китайская теорема об остатках, с. 89–90)  
Система сравнений  
$$
x \equiv c_i \pmod{m_i},\quad i = 1, 2, \dots, k,
$$  
где $\gcd(m_i, m_j) = 1$ при $i \ne j$, имеет **единственное решение по модулю**  
$$
M = m_1 m_2 \cdots m_k.
$$

##### **Доказательство**  
Обозначим $M = \prod_{i=1}^k m_i$, $M_i = M / m_i$. Поскольку $\gcd(M_i, m_i) = 1$, существует обратный элемент $x_i$ такой, что  
$$
M_i x_i \equiv 1 \pmod{m_i}.
$$  
Тогда решение системы даётся формулой  
$$
x^* \equiv \sum_{i=1}^k M_i x_i c_i \pmod{M}.
$$  
Проверка: для любого $j$, все слагаемые, кроме $i = j$, делятся на $m_j$, а $M_j x_j c_j \equiv c_j \pmod{m_j}$, следовательно, $x^* \equiv c_j \pmod{m_j}$.  

Единственность: если $x'$ — другое решение, то $x^* - x' \equiv 0 \pmod{m_i}$ для всех $i$, откуда $x^* - x' \equiv 0 \pmod{M}$, так как модули попарно взаимно просты.

---

#### **Алгоритмы**

##### **Алгоритм Гаусса** (с. 90–93)  
**Словесное описание:**  
1. Вычислить $M = m_1 m_2 \cdots m_k$.  
2. Для каждого $i$:  
   - вычислить $M_i = M / m_i$;  
   - найти $x_i = M_i^{-1} \pmod{m_i}$ с помощью расширенного алгоритма Евклида;  
   - вычислить слагаемое $T_i = M_i x_i c_i$.  
3. Положить $x^* = \left( \sum_{i=1}^k T_i \right) \bmod M$.

**Псевдокод:**  
```text
function CRT_Gauss(c[1..k], m[1..k]):
    M = product(m[i] for i in 1..k)
    x = 0
    for i = 1 to k:
        Mi = M // m[i]
        xi = inverse(Mi mod m[i], m[i])  // via extended_gcd
        x = (x + Mi * xi * c[i]) mod M
    return x
```

**Корректность:** следует напрямую из доказательства теоремы 1.42.  
**Сложность:** доминируется вычислением $k$ обратных элементов и произведений; каждое обращение — $O(\log m_i)$, общая сложность — $O(k \log M)$.

##### **Алгоритм Гарнера** (с. 93–94)  
**Идея:** представить решение в виде смешанной позиционной системы:  
$$
x = v_1 + v_2 m_1 + v_3 m_1 m_2 + \dots + v_k m_1 \cdots m_{k-1},
$$  
где $0 \le v_i < m_i$. Коэффициенты $v_i$ вычисляются последовательно.

**Словесное описание:**  
1. Положить $v_1 = c_1$.  
2. Для $i = 2$ до $k$:  
   - вычислить текущее частичное решение $x_{i-1} = v_1 + v_2 m_1 + \dots + v_{i-1} m_1 \cdots m_{i-2}$;  
   - решить сравнение $x_{i-1} + v_i m_1 \cdots m_{i-1} \equiv c_i \pmod{m_i}$ относительно $v_i$;  
   - это эквивалентно $v_i \equiv (c_i - x_{i-1}) \cdot (m_1 \cdots m_{i-1})^{-1} \pmod{m_i}$.  
3. Вернуть $x = v_1 + v_2 m_1 + \dots + v_k m_1 \cdots m_{k-1}$.

**Преимущества:**  
- не требует работы с большим числом $M$ на промежуточных шагах;  
- удобен для реализации в системах с ограниченной разрядностью (например, в RNS).

**Корректность:** следует из единственности представления в смешанной системе счисления при попарно взаимно простых основаниях.

---

#### **Свойства, следствия, оценки сложности**

- **Единственность решения**: гарантируется только при попарной взаимной простоте модулей.  
- **Сложность алгоритма Гаусса**: $O(k \log^2 M)$ при использовании школьного умножения; может быть улучшена.  
- **Сложность алгоритма Гарнера**: $O(k^2)$ операций над числами, не превосходящими $\max m_i$, что выгодно при больших $k$.  
- **Предварительные вычисления**: в алгоритме Гаусса значения $M_i x_i$ можно вычислить один раз и использовать многократно для разных наборов $c_i$ (см. замечание 1.31, с. 93).

---

#### **Примеры и применения (по учебнику)**

**Пример 1.43** (с. 90–93):  
Найти наименьшее натуральное $x$, удовлетворяющее системе:  
$$
\begin{cases}
x \equiv 2 \pmod{29},\\
x \equiv 12 \pmod{20},\\
x \equiv 20 \pmod{23},\\
x \equiv 4 \pmod{13}.
\end{cases}
$$  
Решение по алгоритму Гаусса:  
- $M = 29 \cdot 20 \cdot 23 \cdot 13 = 173420$;  
- $M_1 = 5980$, $M_2 = 8671$, $M_3 = 7540$, $M_4 = 13340$;  
- Находим обратные:  
  - $x_1 = 5$ (так как $5980 \cdot 5 \equiv 1 \pmod{29}$),  
  - $x_2 = 11$ (так как $8671 \cdot (-9) \equiv 1 \pmod{20}$, $-9 \equiv 11$),  
  - $x_3 = 17$, $x_4 = 7$;  
- Вычисляем:  
  $$
  x^* = (5980 \cdot 5 \cdot 2 + 8671 \cdot 11 \cdot 12 + 7540 \cdot 17 \cdot 20 + 13340 \cdot 7 \cdot 4) \bmod 173420 = 152832.
  $$

---

#### **Связи с другими темами курса**  
- **Система остаточных классов (RNS)**: КТО лежит в основе RNS, где число представляется своим китайским кодом. Арифметические операции выполняются поразрядно, без переносов (см. раздел 1.3.6).  
- **RSA**: при использовании CRT для ускорения дешифрования (метод CRT-RSA) вычисления проводятся по модулям $p$ и $q$, а затем объединяются через КТО.  
- **Линейные сравнения**: решение системы сводится к последовательному решению линейных сравнений (алгоритм Гарнера).  
- **Функция Эйлера**: используется при проверке взаимной простоты модулей и в предварительных вычислениях обратных элементов.

--- 

### **Билет №12. Система остаточных классов (RNS)**

#### **Введение и постановка темы**  
Система остаточных классов (Residue Number System, RNS) — это непозиционная система счисления, основанная на китайской теореме об остатках. В отличие от позиционных систем (например, десятичной или двоичной), в RNS число представляется не как сумма степеней основания, а как набор своих остатков по модулю нескольких взаимно простых чисел. Такая система позволяет выполнять арифметические операции (сложение, вычитание, умножение) **поразрядно и параллельно**, без переносов между разрядами, что делает её особенно эффективной в задачах цифровой обработки сигналов, криптографии и высокопроизводительных вычислениях.

---

#### **Точные определения**

**Определение 1.27** (с. 90).  
Пусть задана система попарно взаимно простых модулей $m_1, m_2, \dots, m_k$. Набор остатков  
$$
(c_1, c_2, \dots, c_k), \quad \text{где } c_i \equiv x \pmod{m_i},
$$  
называется **китайским кодом** числа $x$.

**Определение (система остаточных классов, с. 93).**  
Система остаточных классов (RNS) — это представление целого числа $x$, где $0 \le x < M$, $M = m_1 m_2 \cdots m_k$, в виде кортежа  
$$
x = (x_1 \mid x_2 \mid \dots \mid x_k)_{(m_1 \mid m_2 \mid \dots \mid m_k)},
$$  
где $x_i = x \bmod m_i$.

---

#### **Основные теоремы и утверждения**

##### **Китайская теорема об остатках (Теорема 1.42, с. 89–90)**  
Если модули $m_1, \dots, m_k$ попарно взаимно просты, то для любого набора остатков $(c_1, \dots, c_k)$ существует **единственное** число $x \in [0, M)$, где $M = \prod_{i=1}^k m_i$, такое что  
$$
x \equiv c_i \pmod{m_i}, \quad i = 1, \dots, k.
$$

Эта теорема гарантирует **однозначность** представления числа в RNS и возможность его **восстановления** из остатков.

---

#### **Алгоритмы**

##### **Арифметические операции в RNS**  
Пусть даны два числа:  
$$
X = (x_1 \mid \dots \mid x_k)_{(m_1 \mid \dots \mid m_k)}, \quad Y = (y_1 \mid \dots \mid y_k)_{(m_1 \mid \dots \mid m_k)}.
$$  
Тогда:

- **Сложение**:  
  $$
  X + Y = \big((x_1 + y_1) \bmod m_1 \mid \dots \mid (x_k + y_k) \bmod m_k\big).
  $$

- **Вычитание**:  
  $$
  X - Y = \big((x_1 - y_1) \bmod m_1 \mid \dots \mid (x_k - y_k) \bmod m_k\big).
  $$

- **Умножение**:  
  $$
  X \cdot Y = \big((x_1 y_1) \bmod m_1 \mid \dots \mid (x_k y_k) \bmod m_k\big).
  $$

**Корректность:** следует из свойств сравнений (Теорема 1.27): если $a \equiv b \pmod{m}$ и $c \equiv d \pmod{m}$, то $a \pm c \equiv b \pm d \pmod{m}$ и $ac \equiv bd \pmod{m}$.

##### **Восстановление числа из RNS (алгоритм Гаусса)**  
Для восстановления $x$ из $(x_1, \dots, x_k)$ используется формула:  
$$
x \equiv \sum_{i=1}^k M_i \cdot M_i^{-1} \cdot x_i \pmod{M},
$$  
где $M = \prod m_i$, $M_i = M / m_i$, $M_i^{-1}$ — обратный элемент к $M_i$ по модулю $m_i$.

---

#### **Свойства, следствия, оценки сложности**

- **Параллелизм**: все операции выполняются независимо по каждому модулю — идеально для аппаратной реализации.
- **Отсутствие переносов**: устраняется «цепочка переноса», характерная для позиционных систем.
- **Ограничения**:
  - **Деление** и **сравнение** чисел в RNS нетривиальны.
  - **Обнаружение переполнения** требует дополнительных вычислений.
  - Диапазон представимых чисел ограничен: $0 \le x < M$.
- **Сложность операций**:  
  - Сложение/умножение: $O(k)$ модульных операций, каждая — $O(\log m_i)$.
  - Восстановление: $O(k \log M)$ (из-за обращения и умножения больших чисел).

---

#### **Примеры и применения (по учебнику)**

**Пример 1.44** (с. 94):  
Рассмотрим RNS с базисом $(3, 7, 8)$. Тогда $M = 3 \cdot 7 \cdot 8 = 168$.

- Число $13$:  
  $$
  13 \bmod 3 = 1,\quad 13 \bmod 7 = 6,\quad 13 \bmod 8 = 5 \Rightarrow 13 = (1 \mid 6 \mid 5)_{(3|7|8)}.
  $$

- Число $11$:  
  $$
  11 = (2 \mid 4 \mid 3)_{(3|7|8)}.
  $$

- Сложение:  
  $$
  13 + 11 = ((1+2) \bmod 3 \mid (6+4) \bmod 7 \mid (5+3) \bmod 8) = (0 \mid 3 \mid 0).
  $$

- Умножение:  
  $$
  13 \cdot 11 = ((1\cdot2) \bmod 3 \mid (6\cdot4) \bmod 7 \mid (5\cdot3) \bmod 8) = (2 \mid 3 \mid 7).
  $$

**Применения** (с. 94):  
- Цифровая обработка сигналов (DSP),  
- Криптография (ускорение модульных операций в RSA, эллиптической криптографии),  
- Обработка изображений,  
- Высокопроизводительные вычисления.

---

#### **Связи с другими темами курса**  
- **Китайская теорема об остатках** — теоретическая основа RNS.  
- **Линейные сравнения** — используются при вычислении обратных элементов $M_i^{-1}$.  
- **RSA и криптография** — RNS применяется для ускорения возведения в степень по модулю.  
- **Модульная арифметика** — вся система RNS строится на кольцах вычетов $\mathbb{Z}_{m_i}$.

--- 

### **Билет №13. Функция Эйлера и её свойства. Теорема Эйлера–Ферма. Формула Гаусса. Теорема Вильсона**

#### **Введение и постановка темы**  
Функция Эйлера $\varphi(m)$ — одна из центральных арифметических функций в теории чисел. Она определяет количество натуральных чисел, меньших $m$ и взаимно простых с ним. Эта функция играет ключевую роль в модульной арифметике, криптографии (в частности, в системе RSA), а также в доказательствах важных теорем, таких как теорема Эйлера–Ферма и формула Гаусса. Связанные с ней результаты — теорема Вильсона и формула обращения суммы делителей — демонстрируют глубокую взаимосвязь между структурой множества делителей числа и его арифметическими свойствами.

---

#### **Точные определения**

**Определение 1.23** (с. 78).  
Функция Эйлера $\varphi(m)$ ставит в соответствие каждому натуральному числу $m$ количество целых чисел из интервала $[1, m]$, взаимно простых с $m$. По определению полагают $\varphi(1) = 1$.

**Определение 1.24** (с. 82).  
Арифметическая функция $f \colon \mathbb{N} \to \mathbb{C}$ называется **мультипликативной**, если:
1. Существует $a \in \mathbb{N}$, такое что $f(a) \ne 0$;
2. Для любых взаимно простых $a_1, a_2 \in \mathbb{N}$ выполняется  
   $$
   f(a_1 a_2) = f(a_1) f(a_2).
   $$

---

#### **Основные теоремы и утверждения**

##### **Лемма 1.8** (с. 80)  
Пусть $p$ — простое число, $n \in \mathbb{N}$. Тогда  
$$
\varphi(p^n) = p^n - p^{n-1} = p^n \left(1 - \frac{1}{p}\right).
$$

##### **Следствие 1.13** (с. 80)  
Если $\gcd(a, b) = 1$, то  
$$
\varphi(ab) = \varphi(a)\varphi(b).
$$

##### **Следствие 1.14** (**формула для вычисления $\varphi(m)$**, с. 81)  
Пусть каноническое разложение числа $m$ имеет вид  
$$
m = p_1^{\alpha_1} p_2^{\alpha_2} \cdots p_k^{\alpha_k}.
$$  
Тогда  
$$
\varphi(m) = m \left(1 - \frac{1}{p_1}\right)\left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_k}\right).
$$

##### **Теорема 1.35** (**формула Гаусса**, с. 81)  
Для любого натурального $m$ справедливо равенство  
$$
\sum_{d \mid m} \varphi(d) = m,
$$  
где суммирование ведётся по всем положительным делителям $d$ числа $m$.

##### **Теорема 1.38** (**теорема Эйлера–Ферма**, с. 83–84)  
Пусть $a, m \in \mathbb{Z}$, $m > 0$, и $\gcd(a, m) = 1$. Тогда  
$$
a^{\varphi(m)} \equiv 1 \pmod{m}.
$$

##### **Следствие 1.15** (**малая теорема Ферма**, с. 84)  
Если $p$ — простое число, то для любого $a \in \mathbb{Z}$  
$$
a^p \equiv a \pmod{p}.
$$  
В частности, если $p \nmid a$, то  
$$
a^{p-1} \equiv 1 \pmod{p}.
$$

##### **Теорема 1.41** (**теорема Вильсона**, с. 89)  
Натуральное число $p > 1$ является простым тогда и только тогда, когда  
$$
(p - 1)! \equiv -1 \pmod{p}.
$$

---

#### **Доказательства (в объёме, приведённом в учебнике)**

**Формула для $\varphi(p^n)$**:  
Из чисел $1, 2, \dots, p^n$ на $p$ делятся ровно $p^{n-1}$ чисел: $p, 2p, \dots, p^{n-1}p$. Остальные $p^n - p^{n-1}$ чисел взаимно просты с $p^n$.

**Мультипликативность $\varphi$**:  
Следует из **Теоремы 1.34** (с. 80): если $\gcd(a,b)=1$, то отображение $(x,y) \mapsto ay + bx \bmod ab$ задаёт биекцию между парами $(x,y)$, где $\gcd(x,a)=1$, $\gcd(y,b)=1$, и числами $z \in [1,ab]$, взаимно простыми с $ab$.

**Формула Гаусса**:  
Рассмотрим все числа от $1$ до $m$. Каждое из них имеет $\gcd(k, m) = d$ для некоторого делителя $d \mid m$. Число таких $k$ равно $\varphi(m/d)$. Суммируя по всем $d$, получаем $\sum_{d \mid m} \varphi(d) = m$.

**Теорема Эйлера–Ферма**:  
Множество вычетов, взаимно простых с $m$, образует группу по умножению в $\mathbb{Z}_m$. Порядок группы равен $\varphi(m)$. По теореме Лагранжа, порядок любого элемента делит порядок группы, откуда $a^{\varphi(m)} \equiv 1 \pmod{m}$.

**Теорема Вильсона**:  
Если $p$ — простое, то каждый элемент $a \in \{2, \dots, p-2\}$ имеет единственный обратный $b \ne a$ такой, что $ab \equiv 1 \pmod{p}$. Произведение всех таких пар даёт $1$, а оставшиеся $1$ и $p-1 \equiv -1$ дают $(p-1)! \equiv -1 \pmod{p}$.  
Если $p$ составное и $p > 4$, то $(p-1)! \equiv 0 \pmod{p}$, так как $p$ имеет нетривиальный делитель $\le p-1$.

---

#### **Алгоритмы**

##### **Вычисление $\varphi(m)$**  
**Словесное описание:**  
1. Разложить $m$ на простые множители: $m = p_1^{\alpha_1} \cdots p_k^{\alpha_k}$.  
2. Применить формулу:  
   $$
   \varphi(m) = m \prod_{i=1}^k \left(1 - \frac{1}{p_i}\right).
   $$

**Пример** (с. 81):  
$\varphi(60) = 60 \left(1 - \frac{1}{2}\right)\left(1 - \frac{1}{3}\right)\left(1 - \frac{1}{5}\right) = 60 \cdot \frac{1}{2} \cdot \frac{2}{3} \cdot \frac{4}{5} = 16$.

##### **Применение теоремы Эйлера для решения сравнений**  
Для решения $ax \equiv b \pmod{m}$ при $\gcd(a,m)=1$:  
$$
x \equiv b \cdot a^{\varphi(m)-1} \pmod{m}.
$$  
(см. замечание 1.30, с. 87)

---

#### **Свойства, следствия, оценки сложности**

- $\varphi(m)$ — мультипликативная, но не вполне мультипликативная функция.  
- При $m > 2$ число $\varphi(m)$ чётно (**Теорема 1.36**, с. 82).  
- Сложность вычисления $\varphi(m)$ зависит от сложности факторизации $m$.  
- Теорема Эйлера обобщает малую теорему Ферма и лежит в основе корректности RSA.  
- Теорема Вильсона даёт **неэффективный**, но теоретически точный критерий простоты.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.34** (с. 81):  
- $\varphi(49) = \varphi(7^2) = 49 - 7 = 42$,  
- $\varphi(30) = \varphi(2)\varphi(3)\varphi(5) = 1 \cdot 2 \cdot 4 = 8$,  
- $\varphi(60) = 16$.

**Пример 1.38** (с. 85):  
Найти остаток от деления $25^{1135}$ на $34$.  
1. $\varphi(34) = \varphi(2 \cdot 17) = 1 \cdot 16 = 16$,  
2. $25^{16} \equiv 1 \pmod{34}$,  
3. $1135 \equiv 3 \pmod{16}$,  
4. $25^{1135} \equiv 25^3 = 15625 \equiv 19 \pmod{34}$.

**Пример применения теоремы Вильсона**:  
Для $p = 5$: $(5-1)! = 24 \equiv -1 \pmod{5}$ — верно.  
Для $p = 4$: $3! = 6 \not\equiv -1 \pmod{4}$ — составное.

---

#### **Связи с другими темами курса**  
- **RSA**: закрытый ключ $d$ находится из условия $ed \equiv 1 \pmod{\varphi(m)}$, где используется мультипликативность $\varphi$ и теорема Эйлера.  
- **Линейные сравнения**: теорема Эйлера даёт явную формулу для обратного элемента $a^{-1} \equiv a^{\varphi(m)-1} \pmod{m}$.  
- **Китайская теорема об остатках**: позволяет вычислять $\varphi(m)$ через $\varphi(p_i^{\alpha_i})$ при разложении $m$ на взаимно простые множители.  
- **Группы**: $\varphi(m)$ — порядок мультипликативной группы обратимых элементов кольца $\mathbb{Z}_m$.

--- 

### **Билет №14. Быстрое возведение числа в степень в кольце $\mathbb{Z}_m$**

#### **Введение и постановка темы**  
Быстрое (или бинарное) возведение в степень — один из фундаментальных алгоритмов модульной арифметики, широко применяемый в криптографии (в частности, в системе RSA), теории чисел и вычислительной алгебре. Его задача — эффективно вычислить значение $a^e \bmod m$ при больших показателях $e$, не выполняя $e-1$ умножений, а используя структуру двоичного представления показателя. Алгоритм позволяет сократить вычислительную сложность с линейной до логарифмической относительно длины показателя.

---

#### **Точные определения**

Хотя в учебнике С. В. Рыбина отсутствует формальное определение самого термина «быстрое возведение в степень», используется следующая постановка задачи (см. раздел 1.3.7, с. 95–96):

> Требуется вычислить значение $a^e \bmod m$, где $a, e, m \in \mathbb{Z}$, $m > 0$, причём все промежуточные результаты должны оставаться в кольце вычетов $\mathbb{Z}_m$.

Кольцо $\mathbb{Z}_m$ определяется как множество классов вычетов по модулю $m$ с операциями сложения и умножения по модулю $m$ (Определение 1.21, Теорема 1.29).

---

#### **Основные теоремы и утверждения**

В учебнике **не формулируется отдельная теорема** о корректности быстрого возведения в степень, однако его обоснование следует из свойств модульной арифметики:

##### **Свойство 1.27 (арифметика сравнений, с. 77)**  
Если $a \equiv b \pmod{m}$ и $c \equiv d \pmod{m}$, то:
- $ac \equiv bd \pmod{m}$,
- $a^k \equiv b^k \pmod{m}$ для любого $k \in \mathbb{N}$.

Это гарантирует, что можно выполнять умножение и возведение в степень **по модулю на каждом шаге**, не изменяя конечного результата.

---

#### **Алгоритмы**

##### **Алгоритм 1.11** (быстрое возведение в степень по модулю, с. 96)  

**Словесное описание:**  
Пусть требуется вычислить $a^e \bmod m$. Представим показатель $e$ в двоичной системе:  
$$
e = \sum_{i=0}^{k} \varepsilon_i 2^i,\quad \varepsilon_i \in \{0,1\}.
$$  
Тогда  
$$
a^e = \prod_{\varepsilon_i = 1} a^{2^i}.
$$  
Алгоритм последовательно вычисляет степени $a^{2^i} \bmod m$ и перемножает те из них, для которых $\varepsilon_i = 1$.

**Псевдокод (по тексту примера 1.46, с. 99):**  
```text
function mod_exp(a, e, m):
    result ← 1
    base ← a mod m
    while e > 0:
        if e is odd:
            result ← (result * base) mod m
        end if
        base ← (base * base) mod m
        e ← floor(e / 2)
    end while
    return result
```

**Пример работы (Пример 1.46, с. 99):**  
Для вычисления $5^7 \bmod 46$:  
- $7 = (111)_2$,  
- Шаги:  
  1. $c = 1$  
  2. $c = 1^2 \cdot 5 = 5$  
  3. $c = 5^2 \cdot 5 = 125 \equiv 33 \pmod{46}$  
  4. $c = 33^2 \cdot 5 = 5445 \equiv 17 \pmod{46}$  
- Результат: $17$.

**Корректность:**  
Алгоритм корректен, поскольку на каждом шаге инвариант  
$$
\text{result} \cdot \text{base}^e \equiv a^{\text{исходный } e} \pmod{m}
$$  
сохраняется. При завершении цикла $e = 0$, и $\text{result} \equiv a^e \pmod{m}$.

---

#### **Свойства, следствия, оценки сложности**

- **Число умножений**: не более $2 \lfloor \log_2 e \rfloor + 1$.  
- **Сложность**: $O(\log e)$ модульных умножений, каждое из которых выполняется за $O((\log m)^2)$ при школьном умножении. Общая сложность — $O((\log e)(\log m)^2)$.  
- **Память**: $O(1)$ дополнительных переменных.  
- **Применимость**: работает в любом кольце $\mathbb{Z}_m$, даже если $a$ необратим или $m$ составное.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.46** (с. 99):  
Расшифровка сообщения в RSA с ключом $d = 7$, $m = 46$:  
- Для шифртекста $C = 5$ вычисляется $M = C^d \bmod 46 = 5^7 \bmod 46 = 17$.  
- Аналогично для других символов: $12^7 \bmod 46 = 16$, $16^7 \bmod 46 = 18$, $26^7 \bmod 46 = 28$.  
- Получено исходное слово: ПОРА (17, 16, 18, 28).

**Пример 1.45** (с. 98):  
Расшифровка сообщения $(12, 15, 30, 14)$ с закрытым ключом $d = 3$, $m = 33$:  
- $12^3 \bmod 33 = 12$, $15^3 \bmod 33 = 9$, и т.д.  
- Все вычисления выполнены с использованием быстрого возведения.

**Применения:**  
- Криптосистема RSA (шифрование и дешифрование),  
- Электронная подпись,  
- Протоколы Диффи–Хеллмана,  
- Тестирование простоты (например, тест Ферма).

---

#### **Связи с другими темами курса**  
- **RSA**: безопасность и функционирование системы полностью зависят от эффективного вычисления $a^e \bmod m$.  
- **Теорема Эйлера–Ферма**: используется для уменьшения показателя степени по модулю $\varphi(m)$, но само возведение всё равно требует быстрого алгоритма.  
- **Линейные сравнения и диофантовы уравнения**: применяются при вычислении закрытого ключа $d$, но не при возведении в степень.  
- **Система остаточных классов (RNS)**: быстрое возведение может быть распараллелено по модулям RNS.

--- 

### **Билет №15. Система шифрования RSA**

#### **Введение и постановка темы**  
Система шифрования RSA (названная по первым буквам фамилий её создателей — Rivest, Shamir, Adleman) является первой и наиболее известной криптосистемой с открытым ключом. Она была предложена в 1977 году и основана на использовании односторонней функции с секретом — возведения в степень по модулю составного числа. Безопасность RSA опирается на вычислительную сложность задачи факторизации больших целых чисел. Система применяется повсеместно: в защищённых сетевых протоколах (TLS/SSL), цифровых подписях, электронной коммерции и системах аутентификации.

---

#### **Точные определения**

**Определение 1.28** (односторонняя функция с секретом, с. 94).  
Функция $f \colon X \to Y$ называется **односторонней функцией с секретом**, если:
- при известном $x$ значение $f(x)$ вычисляется эффективно;
- при известном $y = f(x)$ нахождение $x$ без дополнительной информации практически невозможно;
- существует «секрет» (ключ), знание которого позволяет эффективно инвертировать $f$.

**Определение (RSA-шифрование, с. 95–96).**  
Пусть:
- $p$, $q$ — различные простые числа,
- $m = pq$,
- $\varphi(m) = (p-1)(q-1)$,
- $e$ — натуральное число, такое что $\gcd(e, \varphi(m)) = 1$,
- $d$ — решение сравнения $de \equiv 1 \pmod{\varphi(m)}$.

Тогда пара $(e, m)$ называется **открытым ключом**, а $d$ — **закрытым ключом**. Шифрование сообщения $M \in \mathbb{Z}_m$ осуществляется по формуле:  
$$
C = M^e \bmod m,
$$  
дешифрование — по формуле:  
$$
M = C^d \bmod m.
$$

---

#### **Основные теоремы и утверждения**

##### **Теорема корректности RSA** (следствие из теоремы Эйлера–Ферма, с. 95)  
Пусть $M \in \mathbb{Z}_m$, где $m = pq$, $p$, $q$ — простые, и $\gcd(M, m) = 1$. Тогда  
$$
(M^e)^d \equiv M \pmod{m}.
$$

**Доказательство:**  
Из условия $de \equiv 1 \pmod{\varphi(m)}$ следует, что $de = 1 + k\varphi(m)$ для некоторого $k \in \mathbb{N}$. По теореме Эйлера–Ферма:  
$$
M^{\varphi(m)} \equiv 1 \pmod{m} \Rightarrow M^{k\varphi(m)} \equiv 1 \pmod{m}.
$$  
Тогда  
$$
M^{de} = M^{1 + k\varphi(m)} = M \cdot (M^{\varphi(m)})^k \equiv M \cdot 1^k = M \pmod{m}.
$$

Если $\gcd(M, m) \ne 1$ (например, $M$ делится на $p$ или $q$), то корректность также сохраняется — это следует из китайской теоремы об остатках и проверки отдельно по модулям $p$ и $q$ (в учебнике не приведено, но используется в примерах).

---

#### **Алгоритмы**

##### **Генерация ключей RSA** (с. 95–96)  
1. Выбрать два больших простых числа $p$ и $q$.  
2. Вычислить $m = pq$ и $\varphi(m) = (p-1)(q-1)$.  
3. Выбрать целое $e$, $1 < e < \varphi(m)$, такое что $\gcd(e, \varphi(m)) = 1$.  
4. Найти $d$ как решение линейного сравнения $de \equiv 1 \pmod{\varphi(m)}$ (с помощью расширенного алгоритма Евклида).  
5. Открытый ключ: $(e, m)$; закрытый ключ: $d$.

##### **Шифрование и дешифрование**  
- **Шифрование**: $C = M^e \bmod m$ (используется открытый ключ).  
- **Дешифрование**: $M = C^d \bmod m$ (используется закрытый ключ).

Оба этапа используют **быстрое возведение в степень по модулю** (алгоритм 1.11).

---

#### **Свойства, следствия, оценки сложности**

- **Корректность**: обеспечивается теоремой Эйлера и свойствами модульной арифметики.  
- **Безопасность**: основана на предположении, что факторизация $m = pq$ при больших $p, q$ вычислительно трудна.  
- **Сложность генерации ключа**: доминируется проверкой простоты и факторизацией (при атаке).  
- **Сложность шифрования/дешифрования**: $O(\log e \cdot (\log m)^2)$ операций (из-за быстрого возведения в степень).  
- **Размер ключа**: в современных системах $m$ имеет длину не менее 2048 бит.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.45** (с. 98):  
- Открытый ключ: $e = 3$, $m = 33 = 3 \cdot 11$.  
- $\varphi(33) = (3-1)(11-1) = 20$.  
- Найдём $d$: $3d \equiv 1 \pmod{20} \Rightarrow d = 7$.  
- Шифртекст: $(12, 15, 30, 14)$.  
- Дешифрование:  
  - $12^3 \bmod 33 = 12$,  
  - $15^3 \bmod 33 = 9$,  
  - $30^3 \bmod 33 = 6$,  
  - $14^3 \bmod 33 = 5$.  
- Получено сообщение: $12, 9, 6, 5$ → соответствует слову «МИР!» (по заданной кодировке).

**Пример 1.46** (с. 99):  
- Открытый ключ: $e = 19$, $m = 46 = 2 \cdot 23$.  
- $\varphi(46) = 1 \cdot 22 = 22$.  
- Решаем $19d \equiv 1 \pmod{22}$ → $d = 7$.  
- Шифртекст: $(5, 12, 16, 26)$.  
- Дешифрование:  
  - $5^7 \bmod 46 = 17$,  
  - $12^7 \bmod 46 = 16$,  
  - $16^7 \bmod 46 = 18$,  
  - $26^7 \bmod 46 = 28$.  
- Получено слово: ПОРА (по кодировке букв числами от 2 до 32).

---

#### **Связи с другими темами курса**  
- **Функция Эйлера**: необходима для вычисления $\varphi(m)$ и нахождения $d$.  
- **Линейные сравнения**: используются для решения $de \equiv 1 \pmod{\varphi(m)}$.  
- **Быстрое возведение в степень**: применяется как при шифровании, так и при дешифровании.  
- **Китайская теорема об остатках**: может использоваться для ускорения дешифрования (метод CRT-RSA).  
- **Диофантовы уравнения**: эквивалентны линейным сравнениям при нахождении $d$.

--- 

### **Билет №16. Электронная подпись. Электронные деньги**

#### **Введение и постановка темы**  
Электронная подпись и электронные деньги — ключевые криптографические примитивы, обеспечивающие аутентификацию, целостность данных и неотказуемость в цифровых системах. Эти механизмы лежат в основе современных финансовых транзакций, юридически значимого документооборота и защищённых коммуникаций. В учебнике С. В. Рыбина рассматриваются их теоретические основы на базе криптосистемы с открытым ключом, в первую очередь RSA, а также обсуждаются требования к безопасности и свойства, необходимые для практического применения.

---

#### **Точные определения**

**Определение (электронная подпись, с. 100–101).**  
Пусть отправитель (Алиса) хочет подписать сообщение $M$ и передать его получателю (Бобу). Для этого она:
- вычисляет **цифровую подпись** $S = M^d \bmod m$, используя свой **закрытый ключ** $d$,
- отправляет пару $(M, S)$.

Получатель проверяет подлинность, вычисляя $M' = S^e \bmod m$ с помощью **открытого ключа** $(e, m)$ Алисы и сравнивая $M'$ с $M$. Если $M' = M$, подпись считается действительной.

**Определение (электронные деньги, с. 101–102).**  
Электронные деньги — это криптографически защищённые цифровые токены, которые:
- создаются банком с использованием его закрытого ключа (подпись),
- могут быть переданы от пользователя к пользователю без раскрытия личности,
- допускают проверку подлинности у любого участника с помощью открытого ключа банка,
- обеспечивают **неотслеживаемость** (untraceability) и **защиту от подделки**.

---

#### **Основные теоремы и утверждения**

Хотя в учебнике отсутствуют формальные теоремы о корректности электронной подписи, её обоснование следует из **теоремы корректности RSA**:

> Если $de \equiv 1 \pmod{\varphi(m)}$, то для любого $M \in \mathbb{Z}_m$ выполняется  
> $$
> (M^d)^e \equiv M \pmod{m}.
> $$

Это гарантирует, что:
- только владелец закрытого ключа может создать подпись, которую можно проверить открытым ключом;
- подделка подписи эквивалентна решению задачи дискретного логарифма или факторизации $m$.

Для электронных денег формулируется **требование безопасности** (с. 101):
- невозможно подделать подпись банка для создания новой банкноты;
- невозможно, имея набор легитимных банкнот, создать подпись ещё для одной.

---

#### **Алгоритмы**

##### **Алгоритм формирования и проверки электронной подписи (RSA-based)**  
**Словесное описание:**  
1. Генерация ключей: как в RSA — выбираются $p, q$, вычисляются $m = pq$, $\varphi(m)$, $e$, $d$.  
2. Подписание: $S = M^d \bmod m$.  
3. Проверка: вычислить $M' = S^e \bmod m$; если $M' = M$, подпись верна.

**Корректность:** следует из обратимости возведения в степень в $\mathbb{Z}_m$ при условии $\gcd(M, m) = 1$ (а в случае $\gcd(M, m) \ne 1$ — из китайской теоремы об остатках).

##### **Схема электронных денег (упрощённая модель, с. 101–102)**  
1. Банк генерирует RSA-ключи $(e, m)$ (открытый) и $d$ (закрытый).  
2. Пользователь (Алиса) выбирает случайное число $N$ («номер банкноты»), шифрует его своим ключом и отправляет банку.  
3. Банк подписывает $N$: $S = N^d \bmod m$, и возвращает $(N, S)$.  
4. При оплате Алиса передаёт $(N, S)$ продавцу.  
5. Продавец проверяет подпись: $N' = S^e \bmod m$; если $N' = N$, деньги подлинны.

**Неотслеживаемость:** банк не может связать момент выдачи банкноты с её последующим использованием, если используется **слепая подпись** (в учебнике не детализирована, но упомянуто требование).

---

#### **Свойства, следствия, оценки сложности**

- **Аутентификация**: подпись подтверждает авторство.  
- **Целостность**: любое изменение $M$ делает подпись недействительной.  
- **Неотказуемость**: подписанту нельзя отрицать факт подписания (при условии защиты закрытого ключа).  
- **Сложность подделки**: эквивалентна факторизации $m$ или вычислению $d$ по $e$ и $m$.  
- **Эффективность**: подписание и проверка требуют одного возведения в степень по модулю — $O(\log^3 m)$ операций.

---

#### **Примеры и применения (по учебнику)**

**Пример 1.47** (с. 100):  
Подпись числа $27$ с параметрами $m = 17 \cdot 23 = 391$, $e = 125$.  
1. $\varphi(391) = 16 \cdot 22 = 352$.  
2. Найдём $d$ из условия $125d \equiv 1 \pmod{352}$.  
   Расширенный алгоритм Евклида даёт $d = 269$.  
3. Подпись: $S = 27^{269} \bmod 391$.  
   Используя быстрое возведение в степень, получаем $S = 164$ (см. таблицу 1.7, с. 34).  
4. Проверка: $164^{125} \bmod 391 = 27$ — подпись верна.

**Применения** (с. 101–102):  
- Электронный документооборот,  
- Цифровые сертификаты,  
- Криптовалюты и банковские системы,  
- Защита программного обеспечения от подделки.

---

#### **Связи с другими темами курса**  
- **RSA**: электронная подпись — прямое применение RSA с инверсией ролей ключей.  
- **Функция Эйлера и линейные сравнения**: используются при вычислении $d$.  
- **Быстрое возведение в степень**: применяется как при подписании, так и при проверке.  
- **Китайская теорема об остатках**: может ускорять вычисления в подписи (CRT-RSA).  
- **Односторонние функции с секретом**: подпись невозможна без знания закрытого ключа.

--- 

### **Билет №17. Простейшие атаки на систему RSA**

#### **Введение и постановка темы**  
Система шифрования RSA, несмотря на свою теоретическую надёжность, может быть уязвима при неправильной реализации или выборе параметров. В учебнике С. В. Рыбина рассматриваются так называемые «простейшие атаки» — криптоаналитические методы, эксплуатирующие слабости в генерации ключей, малый размер показателей или структурные особенности сообщений. Эти атаки подчёркивают важность соблюдения рекомендаций по выбору параметров: длины модуля, величины открытой экспоненты, использования случайных сессионных ключей и корректного форматирования сообщений.

---

#### **Точные определения**

Хотя в учебнике отсутствуют формальные определения самих атак, используются следующие понятия:

- **Открытый ключ**: пара $(e, m)$, где $m = pq$, $p, q$ — простые числа.
- **Закрытый ключ**: число $d$, удовлетворяющее условию $de \equiv 1 \pmod{\varphi(m)}$.
- **Атака** — попытка восстановить исходное сообщение $M$ или закрытый ключ $d$ по известному шифртексту $C = M^e \bmod m$ и открытому ключу $(e, m)$.

---

#### **Основные теоремы и утверждения**

В разделе 1.3.8 (с. 102–104) описываются три основные простейшие атаки. Формальных теорем нет, но приводятся обоснования и условия уязвимости.

##### **Утверждение 1 (атака при малом значении $M$)**  
Если сообщение $M$ таково, что $M^e < m$, то шифртекст $C = M^e \bmod m = M^e$. В этом случае злоумышленник может извлечь $e$-й корень из $C$ в целых числах и получить $M$ без знания закрытого ключа.

##### **Утверждение 2 (атака при малом значении $e$ и одинаковом $M$)**  
Пусть одно и то же сообщение $M$ зашифровано с помощью одного и того же малого показателя $e$ (например, $e = 3$) для трёх разных получателей с взаимно простыми модулями $m_1, m_2, m_3$. Тогда, зная три шифртекста:
$$
C_1 = M^e \bmod m_1,\quad C_2 = M^e \bmod m_2,\quad C_3 = M^e \bmod m_3,
$$
злоумышленник может восстановить $M^e$ по китайской теореме об остатках, а затем извлечь $e$-й корень, если $M^e < m_1 m_2 m_3$ (что почти всегда выполняется).

##### **Утверждение 3 (атака на близкие простые множители)**  
Если простые числа $p$ и $q$ выбраны слишком близкими, то модуль $m = pq$ можно факторизовать методом Ферма за короткое время.

---

#### **Алгоритмы**

##### **Алгоритм атаки при малом $M$**  
1. Получить $C = M^e \bmod m$.  
2. Вычислить целочисленный корень $M = \sqrt[e]{C}$.  
3. Если $M^e = C$, то атака успешна.

**Пример (с. 102):**  
$m = 391$, $e = 3$, $C = 125$.  
Так как $125 = 5^3 < 391$, то $M = 5$.

##### **Алгоритм атаки при малом $e$ и нескольких шифртекстах**  
1. Получить $C_i = M^e \bmod m_i$ для $i = 1, 2, 3$, где $\gcd(m_i, m_j) = 1$.  
2. Применить китайскую теорему об остатках для нахождения $X = M^e \bmod (m_1 m_2 m_3)$.  
3. Поскольку $M < m_i$, то $M^e < m_1 m_2 m_3$, следовательно, $X = M^e$.  
4. Извлечь $M = \sqrt[e]{X}$.

**Пример (с. 103):**  
$e = 3$,  
- $m_1 = 17 \cdot 19 = 323$, $C_1 = 10$,  
- $m_2 = 11 \cdot 23 = 253$, $C_2 = 100$,  
- $m_3 = 13 \cdot 29 = 377$, $C_3 = 200$.  

Решая систему сравнений, получаем $X = 68921 = 41^3$, откуда $M = 41$.

##### **Алгоритм факторизации методом Ферма (при близких $p$ и $q$)**  
Если $p$ и $q$ близки, то $m = pq \approx \left(\frac{p+q}{2}\right)^2$. Положим $x = \lceil \sqrt{m} \rceil$. Пока $x^2 - m$ не является полным квадратом, увеличиваем $x$ на 1. Как только найдено $y^2 = x^2 - m$, получаем $p = x - y$, $q = x + y$.

**Пример (с. 104):**  
$m = 29 \cdot 31 = 899$.  
$\sqrt{899} \approx 29.98$, берём $x = 30$.  
$x^2 - m = 900 - 899 = 1 = 1^2$, значит $y = 1$,  
$p = 30 - 1 = 29$, $q = 30 + 1 = 31$.

---

#### **Свойства, следствия, оценки сложности**

- **Атака при малом $M$**: работает мгновенно, если $M^e < m$.  
- **Атака при малом $e$**: требует как минимум $e$ шифртекстов при одном и том же $M$; эффективна при $e = 3$.  
- **Атака Ферма**: сложность $O(|p - q|)$; становится опасной, если $|p - q| < 2^{n/4}$ для $n$-битного $m$.  
- **Защита**:  
  - использовать **случайное дополнение (padding)** сообщения (например, OAEP), чтобы $M$ было большим и уникальным;  
  - выбирать $e \ge 65537$ или применять разные сессионные ключи;  
  - генерировать $p$ и $q$ так, чтобы они отличались порядком хотя бы на $2^{100}$.

---

#### **Примеры и применения (по учебнику)**

- **Пример 1.48** (с. 102): атака на $M = 5$, $e = 3$, $m = 391$ → $C = 125$, $M = \sqrt[3]{125} = 5$.  
- **Пример 1.49** (с. 103): восстановление $M = 41$ из трёх шифртекстов при $e = 3$.  
- **Пример 1.50** (с. 104): факторизация $m = 899$ методом Ферма за один шаг.

---

#### **Связи с другими темами курса**  
- **Китайская теорема об остатках**: используется в атаке при малом $e$.  
- **Метод Ферма**: рассматривается также в контексте факторизации (билет №2).  
- **RSA**: все атаки направлены на конкретные реализации RSA.  
- **Функция Эйлера и генерация ключей**: неправильный выбор $p, q$ делает систему уязвимой.  
- **Быстрое возведение в степень**: применяется как в шифровании, так и в анализе шифртекста.

--- 

*Ответ составлен строго по материалам учебника С. В. Рыбина «Дискретная математика и информатика» (2022).*