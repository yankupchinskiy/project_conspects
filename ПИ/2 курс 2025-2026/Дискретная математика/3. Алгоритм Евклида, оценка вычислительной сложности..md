## **1. КЛАССИЧЕСКИЙ АЛГОРИТМ ЕВКЛИДА**

### **Математическая основа**

**Основное свойство:** Для любых целых чисел aa и b≠0b=0 справедливо:

НОД(a,b)=НОД(b,a  b)НОД(a,b)=НОД(b,amodb)

где a  bamodb — остаток от деления aa на bb.

---

### **Формальное описание алгоритма**

**Вход:** Целые числа aa и bb, b≠0b=0.  
**Выход:** d=НОД(a,b)d=НОД(a,b).

**Шаги алгоритма:**

1. **Инициализация:**  
    Положить a0=aa0​=a, b0=bb0​=b.
2. **Итерационный процесс:**  
    Для i=0,1,2,…i=0,1,2,… выполнять:
    ai+1=bi,bi+1=ai  biai+1​=bi​,bi+1​=ai​modbi​
    до тех пор, пока bi+1≠0bi+1​=0.
3. **Результат:**  
    Когда bi+1=0bi+1​=0, тогда d=ai+1d=ai+1​.

---

### **Последовательность делений с остатком**

Алгоритм можно представить в виде цепочки равенств:

a=b⋅q0+r0,0<r0<∣b∣b=r0⋅q1+r1,0<r1<r0r0=r1⋅q2+r2,0<r2<r1⋮rk−2=rk−1⋅qk+rk,0<rk<rk−1rk−1=rk⋅qk+1+0abr0​rk−2​rk−1​​=b⋅q0​+r0​,=r0​⋅q1​+r1​,=r1​⋅q2​+r2​,⋮=rk−1​⋅qk​+rk​,=rk​⋅qk+1​+0​0000​<r0​<∣b∣<r1​<r0​<r2​<r1​<rk​<rk−1​​

**Результат:** d=НОД(a,b)=rkd=НОД(a,b)=rk​.

---

### **Пример 1.9:** Вычисление НОД(4704, 2808)

4704=2808⋅1+18962808=1896⋅1+9121896=912⋅2+72912=72⋅12+4872=48⋅1+2448=24⋅2+04704280818969127248​=2808⋅1+1896=1896⋅1+912=912⋅2+72=72⋅12+48=48⋅1+24=24⋅2+0​

**Результат:** НОД(4704,2808)=24НОД(4704,2808)=24.

---

## **2. РАСШИРЕННЫЙ АЛГОРИТМ ЕВКЛИДА**

### **Теоретическая основа**

**Теорема Безу:** Для любых целых чисел aa и bb существуют целые числа xx и yy такие, что:

a⋅x+b⋅y=НОД(a,b)a⋅x+b⋅y=НОД(a,b)

---

### **Алгоритм нахождения коэффициентов Безу**

**Вход:** Целые числа aa и bb.  
**Выход:** Тройка (d,x,y)(d,x,y), где d=НОД(a,b)d=НОД(a,b) и a⋅x+b⋅y=da⋅x+b⋅y=d.

**Шаги алгоритма:**

1. **Инициализация:**
    
    (xa,ya)←(1,0),(xb,yb)←(0,1)(xa​,ya​)←(1,0),(xb​,yb​)←(0,1)
    
    При этом:
    
    a=1⋅a+0⋅b,b=0⋅a+1⋅ba=1⋅a+0⋅b,b=0⋅a+1⋅b
2. **Итерационный процесс:** Пока b≠0b=0:
    
    - Вычислить q=⌊a/b⌋q=⌊a/b⌋ (целая часть деления)
        
    - Вычислить новые значения:
        
        (xa,ya)←(xb,yb)(xb,yb)←(xa−q⋅xb, ya−q⋅yb)a←bb←a  b(xa​,ya​)(xb​,yb​)ab​←(xb​,yb​)←(xa​−q⋅xb​, ya​−q⋅yb​)←b←amodb​
3. **Результат:**  
    Когда b=0b=0, имеем d=ad=a и коэффициенты (x,y)=(xa,ya)(x,y)=(xa​,ya​).
    

---

### **Пример:** Нахождение коэффициентов для a=4704a=4704, b=2808b=2808

Используя последовательность из примера 1.9:

|Шаг|aa|bb|qq|xaxa​|yaya​|xbxb​|ybyb​|
|---|---|---|---|---|---|---|---|
|0|4704|2808|1|1|0|0|1|
|1|2808|1896|1|0|1|1|-1|
|2|1896|912|2|1|-1|-1|2|
|3|912|72|12|-1|2|13|-25|
|4|72|48|1|13|-25|-14|27|
|5|48|24|2|-14|27|41|-79|
|6|24|0|—|41|-79|—|—|

**Результат:**

НОД(4704,2808)=24=4704⋅41+2808⋅(−79)НОД(4704,2808)=24=4704⋅41+2808⋅(−79)

---

## **3. ОЦЕНКА ВЫЧИСЛИТЕЛЬНОЙ СЛОЖНОСТИ**

### **Теорема 1.16 (Ламе)**

**Формулировка:** Пусть nn — произвольное натуральное число, и a>b>0a>b>0 — такие натуральные числа, что алгоритму Евклида для обработки aa и bb необходимо выполнить ровно nn шагов (делений с остатком), причём aa — наименьшее натуральное число с таким свойством. Тогда:

a=Fn+2,b=Fn+1a=Fn+2​,b=Fn+1​

где FkFk​ — kk-е число Фибоначчи.

**Числа Фибоначчи:** F1=1,F2=1,Fk+2=Fk+1+FkF1​=1,F2​=1,Fk+2​=Fk+1​+Fk​.

---

### **Доказательство (основные идеи):**

1. **Связь с цепными дробями:**  
    Если алгоритм Евклида для aa и bb выполняет nn шагов, то разложение a/ba/b в цепную дробь имеет nn звеньев:
    
    ab=[q0;q1,…,qn−1]ba​=[q0​;q1​,…,qn−1​]
    
    где qiqi​ — неполные частные.
    
2. **Минимальность чисел:**  
    Поскольку aa должно быть минимальным, все неполные частные, кроме последнего, равны 1, а последнее qn−1≥2qn−1​≥2. При минимальности qn−1=2qn−1​=2, а остальные q0=q1=⋯=qn−2=1q0​=q1​=⋯=qn−2​=1.
    
3. **Связь с числами Фибоначчи:**  
    Подходящие дроби цепной дроби [1;1,…,1,2][1;1,…,1,2] выражаются через числа Фибоначчи. В частности:
    
    ab=Fn+2Fn+1ba​=Fn+1​Fn+2​​
    
    при этом НОД(Fn+2,Fn+1)=1(Fn+2​,Fn+1​)=1.
    

---

### **Следствие 1.5 (Оценка числа шагов)**

Если натуральные числа aa и bb не превосходят NN, то число шагов kk алгоритма Евклида удовлетворяет неравенству:

k≤⌊log⁡φ(5N)⌋−2k≤⌊logφ​(5​N)⌋−2

где φ=1+52≈1.618φ=21+5​​≈1.618 — золотое сечение.

---

### **Доказательство следствия:**

1. Из теоремы Ламе следует, что при числе шагов kk наименьшая пара чисел — это (Fk+2,Fk+1)(Fk+2​,Fk+1​).
    
2. По определению чисел Фибоначчи:
    
    Fk=φk−(−φ)−k5≈φk5Fk​=5​φk−(−φ)−k​≈5​φk​
    
    для больших kk.
    
3. Если a≤Na≤N, то:
    
    Fk+2≈φk+25≤NFk+2​≈5​φk+2​≤N
4. Логарифмируя, получаем:
    
    k+2≤log⁡φ(5N)k+2≤logφ​(5​N)
    
    или
    
    k≤log⁡φ(5N)−2k≤logφ​(5​N)−2
5. Поскольку kk целое, можно взять целую часть.
    

---

### **Численная оценка**

Учитывая, что:

log⁡φ(5N)=ln⁡(5N)ln⁡φ≈ln⁡N+ln⁡5ln⁡φ≈4.785⋅lg⁡N+1.672logφ​(5​N)=lnφln(5​N)​≈lnφlnN+ln5​​≈4.785⋅lgN+1.672

где lg⁡NlgN — логарифм по основанию 10.

**Пример:** Для N=106N=106:

k≤4.785⋅6+1.672−2≈29k≤4.785⋅6+1.672−2≈29

Таким образом, для чисел, не превышающих миллион, алгоритму Евклида потребуется не более 29 шагов.

---

### **Битовая сложность**

Если рассматривать битовую сложность (число элементарных операций с битами), то:

1. Каждое деление с остатком чисел размером O(log⁡N)O(logN) бит можно выполнить за O(log⁡2N)O(log2N) битовых операций при использовании школьного алгоритма деления.
    
2. Число шагов — O(log⁡N)O(logN).
    
3. **Общая сложность:** O(log⁡3N)O(log3N) битовых операций.
    

**Примечание:** С использованием быстрых методов умножения и деления (алгоритмы Карацубы, Шёнхаге-Штрассена) сложность можно снизить до O(log⁡2N⋅log⁡log⁡N)O(log2N⋅loglogN) или лучше.

---

### **Сравнение с бинарным алгоритмом Евклида**

Бинарный алгоритм (основанный на операциях вычитания и деления на 2) имеет сложность O(log⁡2N)O(log2N), но константа может быть лучше за счёт использования сдвигов вместо делений.

---

### **Важные следствия**

1. **Эффективность:** Алгоритм Евклида является одним из самых эффективных алгоритмов в вычислительной теории чисел.
    
2. **Наихудший случай:** Наибольшее число шагов достигается на соседних числах Фибоначчи.
    
3. **Средний случай:** Среднее число шагов для случайных чисел оценивается как 12ln⁡2π2ln⁡N≈0.843ln⁡Nπ212ln2​lnN≈0.843lnN, что значительно лучше худшего случая.
    
4. **Практическая значимость:** Благодаря логарифмической сложности алгоритм применим для очень больших чисел (сотни цифр), что важно в криптографии.