## **1. МАТЕМАТИЧЕСКИЕ ОСНОВАНИЯ**

### **Лемма 1.3 (Свойства, используемые в бинарном алгоритме)**

Для любых натуральных чисел a и b справедливы:

1. **Свойство однородности:**  
    Если a и b чётны, то:
    НОД(a,b)=2⋅НОД(a2,b2)
2. **Свойство сокращения чётного аргумента:**  
    Если a чётно, а b нечётно, то:
    НОД(a,b)=НОД(a2,b)
3. **Свойство инвариантности при вычитании:**  
    Для любых натуральных a и b:
    НОД(a,b)=НОД(a−b,b)
4. **Свойство чётности разности:**  
    Если a и b нечётны, то a−b чётно.
5. **Свойство убывания:**  
    ∣a−b∣<max⁡(a,b)

---

## **2. ФОРМАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА**

### **Алгоритм 1.14 (Бинарный алгоритм Евклида)**

**Вход:** Натуральные числа a и b.  
**Выход:** d=НОД(a,b).

**Шаги алгоритма:**

1. **Выделение общей степени двойки:**
    
    - Положить k=0
        
    - Пока a и b чётны, выполнять:
        
        k←k+1
        a←a2
        b←b2
        k←k+1
        a←2a​
        b←2b​
    
    После этого хотя бы одно из чисел a или b становится нечётным.
    
2. **Основной итерационный процесс:**  
    Пока a≠ba=b выполнять:
    
    a) **Удаление степеней двойки из a:**  
    Пока a чётно, выполнять a←a2
    
    b) **Удаление степеней двойки из bb:**  
    Пока b чётно, выполнять b←b2
    
    c) **Вычитание и деление пополам:**
    
    - Если a<b, то поменять a и b местами
        
    - Вычислить a←a−b2a←2a−b​
        
3. **Формирование результата:**
    
    d=a⋅2kd=a⋅2k

---

## **3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ**

**Теорема:** Алгоритм 1.14 корректно вычисляет НОД входных чисел.

**Доказательство:** Рассмотрим инварианты:

1. **Инвариант 1:** На протяжении всего алгоритма выполняется:
    
    НОД(a,b)⋅2k=НОД(aисх,bисх)НОД(a,b)⋅2k=НОД(aисх​,bисх​)
    - На шаге 1 это следует из свойства 1 леммы 1.3
        
    - На шагах 2a и 2b это следует из свойства 2
        
    - На шаге 2c это следует из свойств 3 и 4
        
2. **Инвариант 2:** После каждого выполнения шага 2c максимальное из чисел уменьшается (свойство 5).
    
3. **Терминация:** Так как натуральные числа не могут убывать бесконечно, алгоритм завершается.
    

При завершении алгоритма a=ba=b, следовательно:

НОД(aисх,bисх)=НОД(a,a)⋅2k=a⋅2kНОД(aисх​,bисх​)=НОД(a,a)⋅2k=a⋅2k

---

## **4. ПРИМЕР ВЫПОЛНЕНИЯ**

### **Пример 1.10:** Вычисление НОД(4704,2808)
**Итерация 0:** a=4704, b=2808, k=0

**Шаг 1 (выделение степеней двойки):**

- a и b чётны: a=2352, b=1404, k=1
    
- a и b чётны: a=1176,b=702, k=2
    
- a и b чётны: a=588, b=351, k=3k=3  
    Теперь b нечётно, останавливаемся
    

**Шаг 2 (основной цикл):**

1. **Итерация 1:**
    
    - a=588 (чётное) → делим на 2: a=294
        
    - a=294 (чётное) → делим на 2: a=147
	    
    - b=351 (нечётное) → не меняем
        
    - Сравниваем: a=147, b=351
        
    - a<b → меняем местами: a=351, b=147
        
    - a←(351−147)/2=204/2=102
        
2. **Итерация 2:**
    
    - a=102 (чётное) → делим на 2: a=51
        
    - b=147 (нечётное) → не меняем
        
    - Сравниваем: a=51, b=147
        
    - a<b → меняем местами: a=147, b=51
        
    - a←(147−51)/2=96/2=48
        
3. **Итерация 3:**
    
    - a=48 (чётное) → делим на 2: a=24
        
    - a=24(чётное) → делим на 2: a=12
        
    - a=12 (чётное) → делим на 2: a=6
        
    - a=6 (чётное) → делим на 2: a=3
        
    - b=51 (нечётное) → не меняем
        
    - Сравниваем: a=3, b=51
        
    - a<b → меняем местами: a=51, b=3
        
    - a←(51−3)/2=48/2=24
        
4. **Итерация 4:**
    
    - a=24 (чётное) → делим на 2: a=12
        
    - a=12 (чётное) → делим на 2: a=6
        
    - a=6 (чётное) → делим на 2: a=3
        
    - b=3 (нечётное) → не меняем
        
    - Сравниваем: a=3, b=3
        
    - a=b → завершаем цикл
        

**Результат:**

d=a⋅2k=3⋅23=24

---

## **5. ОЦЕНКА ВЫЧИСЛИТЕЛЬНОЙ СЛОЖНОСТИ**

### **Теорема о сложности бинарного алгоритма**

Для входных чисел a,b≤N бинарный алгоритм Евклида выполняет:

1. **Число итераций:** O(log⁡N)
    
2. **Общее число операций:** O(log⁡2N) битовых операций
    

**Обоснование:**

1. **Удаление двоек:**  
    На каждом шаге алгоритм делит числа на 2 до получения нечётных значений.  
    Количество таких делений не превосходит O(log⁡N), так как каждое деление уменьшает битовую длину числа.
    
2. **Вычитания:**  
    Каждое вычитание уменьшает максимальное из чисел.  
    После каждого вычитания с последующим делением на 2, максимальное из чисел уменьшается по крайней мере вдвое.  
    Следовательно, число итераций с вычитанием также O(logN).
    
3. **Битовая сложность:**  
    Каждая операция деления на 2 (сдвиг) требует O(1) времени.  
    Каждая операция вычитания требует O(logN) времени.  
    Общая сложность: O(log⁡N)⋅O(log⁡N)=O(log⁡2N)
    

---

### **Сравнение с классическим алгоритмом Евклида**

| Параметр               | Классический алгоритм                | Бинарный алгоритм         |
| ---------------------- | ------------------------------------ | ------------------------- |
| **Основные операции**  | Деление с остатком                   | Вычитание, сдвиг          |
| **Число шагов**        | O(log⁡N)                             | O(log⁡N)                  |
| **Сложность операции** | O(log⁡2N)                            | O(log⁡N)                  |
| **Общая сложность**    | O(log⁡3N)                            | O(log⁡2N)                 |
| **Эффективность**      | Лучше для чисел в десятичной системе | Лучше для двоичных систем |

---

## **6. ЗАМЕЧАНИЯ И ИСТОРИЧЕСКИЕ СВЕДЕНИЯ**

### **Замечание 1.10**

Бинарный алгоритм был известен в Древнем Китае, но в современную компьютерную науку был введён Джозефом Стайном в 1967 году. Иногда называется **алгоритмом Стейна**.

### **Замечание 1.11**

Свойство 3 леммы 1.3 (НОД(a,b)=НОД(a−b,b)НОД(a,b)=НОД(a−b,b)) является основой классического алгоритма Евклида и используется в его схемах.

### **Замечание 1.12**

Для примера 1.9 (вычисление НОД(4704, 2808)):

- Классическому алгоритму потребовалось 6 делений с остатком
    
- Бинарному алгоритму потребовалось 3 вычитания и 16 делений на 2 (сдвигов)
    

Поскольку сдвиги в двоичных системах выполняются значительно быстрее делений, бинарный алгоритм часто более эффективен на практике.

---

## **7. ОБОБЩЕНИЯ И МОДИФИКАЦИИ**

### **Расширенный бинарный алгоритм**

Существует модификация бинарного алгоритма, которая находит также коэффициенты Безу xx и yy такие, что:

a⋅x+b⋅y=НОД(a,b)a⋅x+b⋅y=НОД(a,b)

### **Алгоритм для нескольких чисел**

Бинарный алгоритм легко обобщается на случай нескольких чисел:

НОД(a1,a2,…,an)=НОД(НОД(a1,a2),a3,…,an)НОД(a1​,a2​,…,an​)=НОД(НОД(a1​,a2​),a3​,…,an​)

---

## **8. ПРАКТИЧЕСКОЕ ЗНАЧЕНИЕ**

1. **Криптография:** Используется в алгоритмах RSA, Diffie-Hellman для быстрого вычисления НОД больших чисел.
    
2. **Компьютерная алгебра:** Применяется в системах компьютерной алгебры для работы с большими целыми числами.
    
3. **Аппаратная реализация:** Благодаря использованию только сдвигов и вычитаний, легко реализуется на аппаратном уровне.