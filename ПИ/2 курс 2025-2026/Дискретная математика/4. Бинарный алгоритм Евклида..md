# **4. БИНАРНЫЙ АЛГОРИТМ ЕВКЛИДА**

## **1. МАТЕМАТИЧЕСКИЕ ОСНОВАНИЯ**

### **Лемма 1.3 (Свойства, используемые в бинарном алгоритме)**

Для любых натуральных чисел aa и bb справедливы:

1. **Свойство однородности:**  
    Если aa и bb чётны, то:
    
    НОД(a,b)=2⋅НОД(a2,b2)НОД(a,b)=2⋅НОД(2a​,2b​)
2. **Свойство сокращения чётного аргумента:**  
    Если aa чётно, а bb нечётно, то:
    
    НОД(a,b)=НОД(a2,b)НОД(a,b)=НОД(2a​,b)
3. **Свойство инвариантности при вычитании:**  
    Для любых натуральных aa и bb:
    
    НОД(a,b)=НОД(a−b,b)НОД(a,b)=НОД(a−b,b)
4. **Свойство чётности разности:**  
    Если aa и bb нечётны, то a−ba−b чётно.
    
5. **Свойство убывания:**  
    ∣a−b∣<max⁡(a,b)∣a−b∣<max(a,b)
    

---

## **2. ФОРМАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА**

### **Алгоритм 1.14 (Бинарный алгоритм Евклида)**

**Вход:** Натуральные числа aa и bb.  
**Выход:** d=НОД(a,b)d=НОД(a,b).

**Шаги алгоритма:**

1. **Выделение общей степени двойки:**
    
    - Положить k=0k=0
        
    - Пока aa и bb чётны, выполнять:
        
        k←k+1,a←a2,b←b2k←k+1,a←2a​,b←2b​
    
    После этого хотя бы одно из чисел aa или bb становится нечётным.
    
2. **Основной итерационный процесс:**  
    Пока a≠ba=b выполнять:
    
    a) **Удаление степеней двойки из aa:**  
    Пока aa чётно, выполнять a←a2a←2a​
    
    b) **Удаление степеней двойки из bb:**  
    Пока bb чётно, выполнять b←b2b←2b​
    
    c) **Вычитание и деление пополам:**
    
    - Если a<ba<b, то поменять aa и bb местами
        
    - Вычислить a←a−b2a←2a−b​
        
3. **Формирование результата:**
    
    d=a⋅2kd=a⋅2k

---

## **3. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ**

**Теорема:** Алгоритм 1.14 корректно вычисляет НОД входных чисел.

**Доказательство:** Рассмотрим инварианты:

1. **Инвариант 1:** На протяжении всего алгоритма выполняется:
    
    НОД(a,b)⋅2k=НОД(aисх,bисх)НОД(a,b)⋅2k=НОД(aисх​,bисх​)
    - На шаге 1 это следует из свойства 1 леммы 1.3
        
    - На шагах 2a и 2b это следует из свойства 2
        
    - На шаге 2c это следует из свойств 3 и 4
        
2. **Инвариант 2:** После каждого выполнения шага 2c максимальное из чисел уменьшается (свойство 5).
    
3. **Терминация:** Так как натуральные числа не могут убывать бесконечно, алгоритм завершается.
    

При завершении алгоритма a=ba=b, следовательно:

НОД(aисх,bисх)=НОД(a,a)⋅2k=a⋅2kНОД(aисх​,bисх​)=НОД(a,a)⋅2k=a⋅2k

---

## **4. ПРИМЕР ВЫПОЛНЕНИЯ**

### **Пример 1.10:** Вычисление НОД(4704,2808)НОД(4704,2808)

**Итерация 0:** a=4704a=4704, b=2808b=2808, k=0k=0

**Шаг 1 (выделение степеней двойки):**

- aa и bb чётны: a=2352a=2352, b=1404b=1404, k=1k=1
    
- aa и bb чётны: a=1176a=1176, b=702b=702, k=2k=2
    
- aa и bb чётны: a=588a=588, b=351b=351, k=3k=3  
    Теперь bb нечётно, останавливаемся
    

**Шаг 2 (основной цикл):**

1. **Итерация 1:**
    
    - a=588a=588 (чётное) → делим на 2: a=294a=294
        
    - a=294a=294 (чётное) → делим на 2: a=147a=147
        
    - b=351b=351 (нечётное) → не меняем
        
    - Сравниваем: a=147a=147, b=351b=351
        
    - a<ba<b → меняем местами: a=351a=351, b=147b=147
        
    - a←(351−147)/2=204/2=102a←(351−147)/2=204/2=102
        
2. **Итерация 2:**
    
    - a=102a=102 (чётное) → делим на 2: a=51a=51
        
    - b=147b=147 (нечётное) → не меняем
        
    - Сравниваем: a=51a=51, b=147b=147
        
    - a<ba<b → меняем местами: a=147a=147, b=51b=51
        
    - a←(147−51)/2=96/2=48a←(147−51)/2=96/2=48
        
3. **Итерация 3:**
    
    - a=48a=48 (чётное) → делим на 2: a=24a=24
        
    - a=24a=24 (чётное) → делим на 2: a=12a=12
        
    - a=12a=12 (чётное) → делим на 2: a=6a=6
        
    - a=6a=6 (чётное) → делим на 2: a=3a=3
        
    - b=51b=51 (нечётное) → не меняем
        
    - Сравниваем: a=3a=3, b=51b=51
        
    - a<ba<b → меняем местами: a=51a=51, b=3b=3
        
    - a←(51−3)/2=48/2=24a←(51−3)/2=48/2=24
        
4. **Итерация 4:**
    
    - a=24a=24 (чётное) → делим на 2: a=12a=12
        
    - a=12a=12 (чётное) → делим на 2: a=6a=6
        
    - a=6a=6 (чётное) → делим на 2: a=3a=3
        
    - b=3b=3 (нечётное) → не меняем
        
    - Сравниваем: a=3a=3, b=3b=3
        
    - a=ba=b → завершаем цикл
        

**Результат:**

d=a⋅2k=3⋅23=24d=a⋅2k=3⋅23=24

---

## **5. ОЦЕНКА ВЫЧИСЛИТЕЛЬНОЙ СЛОЖНОСТИ**

### **Теорема о сложности бинарного алгоритма**

Для входных чисел a,b≤Na,b≤N бинарный алгоритм Евклида выполняет:

1. **Число итераций:** O(log⁡N)O(logN)
    
2. **Общее число операций:** O(log⁡2N)O(log2N) битовых операций
    

**Обоснование:**

1. **Удаление двоек:**  
    На каждом шаге алгоритм делит числа на 2 до получения нечётных значений.  
    Количество таких делений не превосходит O(log⁡N)O(logN), так как каждое деление уменьшает битовую длину числа.
    
2. **Вычитания:**  
    Каждое вычитание уменьшает максимальное из чисел.  
    После каждого вычитания с последующим делением на 2, максимальное из чисел уменьшается по крайней мере вдвое.  
    Следовательно, число итераций с вычитанием также O(log⁡N)O(logN).
    
3. **Битовая сложность:**  
    Каждая операция деления на 2 (сдвиг) требует O(1)O(1) времени.  
    Каждая операция вычитания требует O(log⁡N)O(logN) времени.  
    Общая сложность: O(log⁡N)⋅O(log⁡N)=O(log⁡2N)O(logN)⋅O(logN)=O(log2N).
    

---

### **Сравнение с классическим алгоритмом Евклида**

|Параметр|Классический алгоритм|Бинарный алгоритм|
|---|---|---|
|**Основные операции**|Деление с остатком|Вычитание, сдвиг|
|**Число шагов**|O(log⁡N)O(logN)|O(log⁡N)O(logN)|
|**Сложность операции**|O(log⁡2N)O(log2N)|O(log⁡N)O(logN)|
|**Общая сложность**|O(log⁡3N)O(log3N)|O(log⁡2N)O(log2N)|
|**Эффективность**|Лучше для чисел в десятичной системе|Лучше для двоичных систем|

---

## **6. ЗАМЕЧАНИЯ И ИСТОРИЧЕСКИЕ СВЕДЕНИЯ**

### **Замечание 1.10**

Бинарный алгоритм был известен в Древнем Китае, но в современную компьютерную науку был введён Джозефом Стайном в 1967 году. Иногда называется **алгоритмом Стейна**.

### **Замечание 1.11**

Свойство 3 леммы 1.3 (НОД(a,b)=НОД(a−b,b)НОД(a,b)=НОД(a−b,b)) является основой классического алгоритма Евклида и используется в его схемах.

### **Замечание 1.12**

Для примера 1.9 (вычисление НОД(4704, 2808)):

- Классическому алгоритму потребовалось 6 делений с остатком
    
- Бинарному алгоритму потребовалось 3 вычитания и 16 делений на 2 (сдвигов)
    

Поскольку сдвиги в двоичных системах выполняются значительно быстрее делений, бинарный алгоритм часто более эффективен на практике.

---

## **7. ОБОБЩЕНИЯ И МОДИФИКАЦИИ**

### **Расширенный бинарный алгоритм**

Существует модификация бинарного алгоритма, которая находит также коэффициенты Безу xx и yy такие, что:

a⋅x+b⋅y=НОД(a,b)a⋅x+b⋅y=НОД(a,b)

### **Алгоритм для нескольких чисел**

Бинарный алгоритм легко обобщается на случай нескольких чисел:

НОД(a1,a2,…,an)=НОД(НОД(a1,a2),a3,…,an)НОД(a1​,a2​,…,an​)=НОД(НОД(a1​,a2​),a3​,…,an​)

---

## **8. ПРАКТИЧЕСКОЕ ЗНАЧЕНИЕ**

1. **Криптография:** Используется в алгоритмах RSA, Diffie-Hellman для быстрого вычисления НОД больших чисел.
    
2. **Компьютерная алгебра:** Применяется в системах компьютерной алгебры для работы с большими целыми числами.
    
3. **Аппаратная реализация:** Благодаря использованию только сдвигов и вычитаний, легко реализуется на аппаратном уровне.