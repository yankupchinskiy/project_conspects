### **Конспект по теме: Быстрое возведение в степень в кольцах**
#### **1. Идея алгоритма**

Алгоритм основан на представлении показателя степени $m$ в двоичной системе счисления и последовательном возведении в квадрат. Это позволяет заменить $m$ операций умножения на порядка $\log_2 m$ операций.

Пусть показатель степени $m$ имеет двоичное представление:
$$
m = (b_n b_{n-1} \dots b_1 b_0)_2 = b_n \cdot 2^n + b_{n-1} \cdot 2^{n-1} + \dots + b_1 \cdot 2 + b_0,
$$
где $b_i \in \{0, 1\}, b_n = 1$.

Тогда степень можно выразить рекуррентно, используя схему Горнера:
$$
a^m = a^{((\ldots(b_n \cdot 2 + b_{n-1}) \cdot 2 + \dots) \cdot 2 + b_1) \cdot 2 + b_0}.
$$

Это приводит к основному рекурсивному соотношению:
$$
a^m = (a^{m_1})^2 \cdot a^{b_0}, \quad \text{где } m_1 = \lfloor m/2 \rfloor = (b_n \dots b_1)_2.
$$

#### **2. Алгоритм быстрого возведения в степень (основная версия)**

Предполагается, что двоичное представление степени $m = (b_n \dots b_0)_2$ известно.

**Алгоритм 1.11. Возведение числа в натуральную степень**
1.  Инициализация: $c \leftarrow 1$.
2.  **Для** $i$ от $n$ **до** $0$ (от старшего бита к младшему):
    *   $c \leftarrow c \cdot c$ (операция возведения в квадрат).
    *   **Если** $b_i = 1$, **то** $c \leftarrow c \cdot a$.
3.  **Результат:** $c = a^m$.

#### **3. Модификация алгоритма (без предварительного знания двоичного представления)**

**Алгоритм 1.12. Модификация алгоритма 1.11**
1.  Инициализация: $c \leftarrow 1$, $x \leftarrow a$, $y \leftarrow m$.
2.  **Пока** $y > 0$:
    *   **Пока** $y$ четное ($y \mod 2 = 0$):
        *   $x \leftarrow x \cdot x$
        *   $y \leftarrow y / 2$
    *   $c \leftarrow c \cdot x$
    *   $y \leftarrow y - 1$
3.  **Результат:** $c = a^m$.

#### **4. Возведение в степень в кольце вычетов**

**Замечание 1.9.** Алгоритм 1.11 легко модифицируется для возведения в степень в кольце $\mathbb{Z}_k$ (вычисление $a^m \mod k$). Для этого достаточно все операции умножения выполнять по модулю $k$.

**Пример 1.8 из учебника:** Вычислить $27^{125} \pmod{391}$.

*   Показатель степени: $125 = (1111101)_2$ ($n=6$).
*   Применяем Алгоритм 1.11, выполняя умножения по модулю 391.

**Протокол вычислений (Таблица 1.7):**

| $i$ | $b_i$ | Действие                                   | Вычисление (mod 391)               | Значение $c$ |
|------|---------|--------------------------------------------|------------------------------------|----------------|
| 6    | 1       | $c \leftarrow c^2 \cdot a$               | $1^2 \cdot 27$                   | 27             |
| 5    | 1       | $c \leftarrow c^2 \cdot a$               | $27^2 \cdot 27 = 19683$          | 133            |
| 4    | 1       | $c \leftarrow c^2 \cdot a$               | $133^2 \cdot 27 = 477603$        | 192            |
| 3    | 1       | $c \leftarrow c^2 \cdot a$               | $192^2 \cdot 27 = 995328$        | 233            |
| 2    | 1       | $c \leftarrow c^2 \cdot a$               | $233^2 \cdot 27 = 1465803$       | 335            |
| 1    | 0       | $c \leftarrow c^2$ (т.к. $b_1=0$)      | $335^2 = 112225$                 | 80             |
| 0    | 1       | $c \leftarrow c^2 \cdot a$               | $80^2 \cdot 27 = 172800$         | **164**        |

**Ответ:** $27^{125} \equiv 164 \pmod{391}$.

#### **5. Оценка сложности алгоритма**

*   **Теоретическая оценка:** Количество операций умножения не превосходит $2 \cdot \lfloor \log_2 m \rfloor$.
*   **Упражнение 1.2 (из учебника):** Докажите, что количество умножений $K(m)$ в Алгоритме 1.11 удовлетворяет неравенству: $K(m) \le 2 \lfloor \log_2 m \rfloor$.
*   **Более точная формула (Задача 12):** Если в двоичной записи числа $m$ содержится $l$ единиц и $h$ нулей ($l+h = \lfloor \log_2 m \rfloor + 1$), то количество умножений равно: $K(m) = l + h - 1 = \lfloor \log_2 m \rfloor + l - 1$. Это следует из того, что для каждого бита выполняется возведение в квадрат, а для каждой единицы — дополнительное умножение на $a$.

**Вывод:** Алгоритм быстрого возведения в степень является полиномиальным (имеет логарифмическую сложность от показателя степени) и лежит в основе многих криптографических протоколов (например, RSA).