## **1. ТЕОРЕТИЧЕСКИЕ ОСНОВЫ**

### **Теорема Безу**
Для любых целых чисел $a$ и $b$ существуют целые числа $x$ и $y$ такие, что:
$$
a \cdot x + b \cdot y = \text{НОД}(a, b)
$$

**Историческая справка:** Впервые этот факт опубликовал в 1624 году французский математик Клод Гаспар Баше де Мезириак для случая взаимно простых чисел. Этьен Безу в конце XVIII века обобщил результат, распространив его и на кольцо многочленов.

---

## **2. ОСНОВНАЯ ИДЕЯ АЛГОРИТМА**

### **Векторное представление чисел**
Каждое целое число $z$ можно представить как вектор $(x, y)$ такой, что:
$$
z = x \cdot a + y \cdot b
$$
где $a$ и $b$ — исходные числа.

**Начальные векторы:**
- Для числа $a$: $(1, 0)$, так как $a = 1 \cdot a + 0 \cdot b$
- Для числа $b$: $(0, 1)$, так как $b = 0 \cdot a + 1 \cdot b$

### **Принцип работы**
Алгоритм параллельно выполняет два процесса:
1. Вычисляет НОД по схеме классического алгоритма Евклида
2. Обновляет векторы представления чисел через те же линейные комбинации

---

## **3. ФОРМАЛЬНОЕ ОПИСАНИЕ АЛГОРИТМА**

### **Алгоритм 1.15 (Обобщенный алгоритм Евклида)**

**Вход:** Целые числа $a$ и $b$.  
**Выход:** Тройка $(d, x, y)$, где $d = \text{НОД}(a, b)$ и $a \cdot x + b \cdot y = d$.

**Шаги алгоритма:**

1. **Инициализация:**
   $$
   (x_a, y_a) \leftarrow (1, 0), \quad (x_b, y_b) \leftarrow (0, 1)
   $$
   $$
   \text{При этом: } a = x_a \cdot a + y_a \cdot b, \quad b = x_b \cdot a + y_b \cdot b
   $$

2. **Итерационный процесс:** Пока $b \neq 0$ выполнять:
   
   a) **Сохранение текущих значений:**
      $$
      t \leftarrow a, \quad T \leftarrow (x_a, y_a)
      $$
   
   b) **Обновление основного числа и его вектора:**
      $$
      a \leftarrow b, \quad (x_a, y_a) \leftarrow (x_b, y_b)
      $$
   
   c) **Вычисление частного и остатка:**
      $$
      q \leftarrow \lfloor t / b \rfloor
      $$
   
   d) **Обновление второго числа и его вектора:**
      $$
      b \leftarrow t - q \cdot b, \quad (x_b, y_b) \leftarrow T - q \cdot (x_b, y_b)
      $$
      где операция $-$ применяется покомпонентно.

3. **Результат:**
   $$
   d = a, \quad x = x_a, \quad y = y_a
   $$

---

## **4. ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ**

### **Инвариант цикла**
В начале каждой итерации выполняются равенства:
$$
a = x_a \cdot A + y_a \cdot B, \quad b = x_b \cdot A + y_b \cdot B
$$
где $A$ и $B$ — исходные значения чисел.

**Доказательство инварианта:**

1. **Базис:**  
   Перед первой итерацией:
   $$
   a = A = 1 \cdot A + 0 \cdot B, \quad b = B = 0 \cdot A + 1 \cdot B
   $$
   Инвариант выполняется.

2. **Шаг индукции:**  
   Предположим, в начале итерации:
   $$
   a = x_a A + y_a B, \quad b = x_b A + y_b B
   $$
   
   Пусть $q = \lfloor a/b \rfloor$, $r = a - q \cdot b$.
   
   После выполнения итерации:
   - Новое значение $a' = b$, его вектор: $(x_a', y_a') = (x_b, y_b)$
     $$
     a' = b = x_b A + y_b B = x_a' A + y_a' B
     $$
   
   - Новое значение $b' = r = a - q \cdot b$, его вектор:
     $$
     (x_b', y_b') = (x_a, y_a) - q \cdot (x_b, y_b)
     $$
     $$
     b' = (x_a - q x_b)A + (y_a - q y_b)B = x_b' A + y_b' B
     $$
   
   Инвариант сохраняется.

### **Терминация**
Алгоритм завершается, когда $b = 0$. В этот момент:
- По инварианту: $a = x_a A + y_a B$
- По построению алгоритма Евклида: $a = \text{НОД}(A, B)$

Следовательно, $x_a$ и $y_a$ — искомые коэффициенты Безу.

---

## **5. ТАБЛИЧНЫЙ МЕТОД РЕАЛИЗАЦИИ**

### **Альтернативное представление алгоритма**
Алгоритм можно реализовать в виде таблицы с четырьмя строками:

1. **Строка остатков:** $r_0, r_1, r_2, \dots$
2. **Строка частных:** $q_1, q_2, \dots$
3. **Строка коэффициентов $x$:** $x_0, x_1, x_2, \dots$
4. **Строка коэффициентов $y$:** $y_0, y_1, y_2, \dots$

### **Правила заполнения таблицы:**

**Инициализация:**
$$
r_0 = a, \quad r_1 = b
$$
$$
x_0 = 1, \quad x_1 = 0
$$
$$
y_0 = 0, \quad y_1 = 1
$$

**Рекуррентные формулы** для $i \geq 2$:
$$
q_i = \lfloor r_{i-2} / r_{i-1} \rfloor
$$
$$
r_i = r_{i-2} - q_i \cdot r_{i-1}
$$
$$
x_i = x_{i-2} - q_i \cdot x_{i-1}
$$
$$
y_i = y_{i-2} - q_i \cdot y_{i-1}
$$

**Завершение:** Когда $r_k = 0$, результат:
$$
d = r_{k-1}, \quad x = x_{k-1}, \quad y = y_{k-1}
$$

---

## **6. ПРИМЕРЫ ВЫПОЛНЕНИЯ**

### **Пример 1.12:** Нахождение представления для $\text{НОД}(64, 81)$

**Таблица 1.12:**

| Шаг | $r_i$ (остатки) | $q_i$ (частные) | $x_i$ | $y_i$ |
|-----|-------------------|-------------------|---------|---------|
| 0   | 64                | —                 | 1       | 0       |
| 1   | 81                | 0                 | 0       | 1       |
| 2   | 64                | 1                 | 1       | -1      |
| 3   | 17                | 1                 | -1      | 2       |
| 4   | 13                | 3                 | 4       | -3      |
| 5   | 4                 | 1                 | -5      | 4       |
| 6   | 1                 | 3                 | 19      | -15     |
| 7   | 0                 | 4                 | -81     | 64      |

**Результат:**
$$
\text{НОД}(64, 81) = 1 = 64 \cdot 19 + 81 \cdot (-15)
$$

---

### **Пример 1.14:** Нахождение представления для $\text{НОД}(4704, 2808)$

**Таблица 1.13:**

| Шаг | $r_i$ | $q_i$ | $x_i$ | $y_i$ |
|-----|---------|---------|---------|---------|
| 0   | 4704    | —       | 1       | 0       |
| 1   | 2808    | 1       | 0       | 1       |
| 2   | 1896    | 1       | 1       | -1      |
| 3   | 912     | 2       | -1      | 2       |
| 4   | 72      | 12      | 3       | -5      |
| 5   | 48      | 1       | -37     | 62      |
| 6   | 24      | 2       | 40      | -67     |
| 7   | 0       | —       | -117    | 196     |

**Результат:**
$$
\text{НОД}(4704, 2808) = 24 = 4704 \cdot 40 + 2808 \cdot (-67)
$$

---

## **7. ВЫЧИСЛИТЕЛЬНАЯ СЛОЖНОСТЬ**

### **Теорема о сложности**
Обобщенный алгоритм Евклида имеет ту же асимптотическую сложность, что и классический алгоритм Евклида:

1. **Число итераций:** $O(\log \min(a, b))$
2. **Битовая сложность:** $O(\log^2 \min(a, b))$

**Обоснование:**
- Каждая итерация требует:
  - Одно деление с остатком: $O(\log^2 n)$ битовых операций
  - Два умножения и два вычитания для обновления векторов: $O(\log n)$ операций
- Число итераций: $O(\log n)$
- **Итого:** $O(\log^3 n)$ битовых операций

**Примечание:** На практике умножения чисел размера $O(\log n)$ можно выполнять за $O(\log^2 n)$, поэтому общая сложность остаётся $O(\log^3 n)$.

---

## **8. ПРИМЕНЕНИЯ**

### **1. Решение линейных диофантовых уравнений**
Уравнение $a \cdot x + b \cdot y = c$ разрешимо тогда и только тогда, когда $\text{НОД}(a, b) \mid c$.

**Алгоритм решения:**
1. С помощью обобщенного алгоритма Евклида найти $d, x_0, y_0$ такие, что:
   $$
   a \cdot x_0 + b \cdot y_0 = d
   $$
2. Если $d \nmid c$, решений нет
3. Если $d \mid c$, то частное решение:
   $$
   x = x_0 \cdot \frac{c}{d}, \quad y = y_0 \cdot \frac{c}{d}
   $$
4. Общее решение:
   $$
   x = x_0 \cdot \frac{c}{d} + \frac{b}{d} \cdot t, \quad y = y_0 \cdot \frac{c}{d} - \frac{a}{d} \cdot t, \quad t \in \mathbb{Z}
   $$

### **2. Нахождение обратных элементов в кольцах**
В кольце $\mathbb{Z}_m$ элемент $a$ имеет обратный тогда и только тогда, когда $\text{НОД}(a, m) = 1$.

**Алгоритм:**  
Найти с помощью обобщенного алгоритма Евклида $x, y$ такие, что:
$$
a \cdot x + m \cdot y = 1
$$
Тогда в $\mathbb{Z}_m$: $a^{-1} \equiv x \pmod{m}$.

### **3. Криптографические приложения**
- **RSA:** Вычисление обратного элемента по модулю $\varphi(n)$
- **Системы с открытым ключом:** Генерация ключей

---

## **9. ОСОБЕННОСТИ РЕАЛИЗАЦИИ**

### **Замечание 1.13**
1. Если $a < b$, то после первой итерации числа поменяются местами
2. Если оба числа равны нулю, алгоритм неприменим
3. Переменные $t$ и $T$ используются для временного хранения $a$ и вектора $(x_a, y_a)$

### **Оптимизации**
1. **Работа с неотрицательными числами:**  
   Все вычисления можно проводить с неотрицательными числами, корректируя знаки в конце.

2. **Симметричные формулы:**  
   Можно использовать симметричные формулы для обновления векторов:
   $$
   \begin{aligned}
   x_i &= x_{i-2} - q_i \cdot x_{i-1} \\
   y_i &= y_{i-2} - q_i \cdot y_{i-1}
   \end{aligned}
   $$

3. **Бинарная модификация:**  
   Существует бинарная версия обобщенного алгоритма Евклида, основанная на бинарном алгоритме Евклида.

---

## **10. СВЯЗЬ С ЦЕПНЫМИ ДРОБЯМИ**

### **Теорема 1.15**
Если $\frac{a}{b} = [q_0; q_1, \dots, q_k]$ — разложение в цепную дробь, то коэффициенты Безу можно получить из подходящих дробей.

**Связь:** Если $\frac{P_{k-1}}{Q_{k-1}}$ — предпоследняя подходящая дробь, то:
$$
a \cdot Q_{k-1} - b \cdot P_{k-1} = (-1)^{k-1} \cdot \text{НОД}(a, b)
$$
где $P_i, Q_i$ — числители и знаменатели подходящих дробей.

**Пример:** Для $\frac{4704}{2808} = [1; 1, 2, 12, 1, 2]$  
Предпоследняя подходящая дробь: $\frac{67}{40}$  
Проверка: $4704 \cdot 40 - 2808 \cdot 67 = 188160 - 188136 = 24 = \text{НОД}(4704, 2808)$

---

## **11. ИСТОРИЧЕСКАЯ СПРАВКА**

### **Развитие алгоритма**
1. **Евклид** (III в. до н.э.) — классический алгоритм
2. **Ариабхата** (476–550) — алгоритм для решения линейных диофантовых уравнений
3. **Бхаскара I** (VII в.) — расширение метода
4. **Этьен Безу** (1730–1783) — систематическое изложение теории
5. **Дж. У. Р. Дедекинд** (XIX в.) — современная формулировка

### **Названия алгоритма**
- Расширенный алгоритм Евклида
- Обобщенный алгоритм Евклида
- Алгоритм нахождения коэффициентов Безу

---

## **12. ВЫВОДЫ**

1. Обобщенный алгоритм Евклида решает две задачи одновременно:
   - Находит НОД двух чисел
   - Находит коэффициенты линейного представления НОД

2. Алгоритм основан на инварианте:
   $$
   r_i = x_i \cdot a + y_i \cdot b
   $$
   который сохраняется на всех итерациях

3. Вычислительная сложность сравнима со сложностью классического алгоритма Евклида

4. Алгоритм имеет многочисленные приложения:
   - Решение диофантовых уравнений
   - Нахождение обратных элементов в кольцах
   - Криптографические алгоритмы

5. Табличная форма представления алгоритма удобна для ручных вычислений и анализа