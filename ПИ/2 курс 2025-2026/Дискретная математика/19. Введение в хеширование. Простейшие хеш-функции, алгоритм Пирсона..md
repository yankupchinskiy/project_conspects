**Важное замечание:** В предоставленном фрагменте учебника С.В. Рыбина (стр. 1-93) данная тема отсутствует. Ниже представлен общепринятый теоретический конспект, соответствующий стандартному содержанию курсов дискретной математики и информатики.

---

#### **1. Основные понятия хеширования**

**Хеширование** — это процесс преобразования входного массива данных произвольной длины в битовую строку фиксированной длины (хеш-код или хеш-сумму) с помощью детерминированного алгоритма (хеш-функции).

*   **Хеш-функция (hash function):** $h: K \rightarrow A$, где:
    *   $K$ — множество всех возможных ключей (входных данных).
    *   $A$ — множество адресов (хеш-кодов) $\{0, 1, ..., m-1\}$.
*   **Цель:** Обеспечить быстрый доступ к данным (поиск, вставка, удаление) за время, близкое к $O(1)$, в идеальном случае.
*   **Коллизия:** Ситуация, когда двум разным входным ключам $k_1$ и $k_2$ соответствует один и тот же хеш-адрес: $h(k_1) = h(k_2)$ при $k_1 \neq k_2$.

**Требования к «хорошей» хеш-функции:**
1.  **Детерминированность:** Один и тот же ключ всегда даёт одинаковый хеш.
2.  **Вычислительная эффективность:** Функция должна вычисляться быстро.
3.  **Равномерное распределение:** Вероятность попадания в любую из $m$ ячеек хеш-таблицы должна быть близка к $1/m$. Это минимизирует коллизии.
4.  **Устойчивость к коллизиям:** Функция должна минимизировать вероятность возникновения коллизий для типичных входных данных.

---

#### **2. Простейшие хеш-функции**

**2.1. Метод деления (Division Method)**
Наиболее простой метод. Хеш-код — остаток от деления ключа на размер таблицы $m$.
$$
h(k) = k \mod m
$$
*   **Выбор $m$:** Критически важен. Для уменьшения коллизий выбирают $m$ — **простое число**, не близкое к степеням двойки. Это помогает избежать закономерностей, если ключи имеют определённую структуру.
*   **Пример:** $k = 123456, m = 97$. Тогда $h(k) = 123456 \mod 97 = 77$.

**2.2. Метод умножения (Multiplication Method)**
1.  Ключ $k$ умножается на константу $A$ ($0 < A < 1$).
2.  Берётся дробная часть результата.
3.  Результат умножается на $m$ и округляется вниз.
$$
h(k) = \lfloor m \cdot (k \cdot A \mod 1) \rfloor
$$
где $(k \cdot A \mod 1)$ означает дробную часть числа $k \cdot A$.
*   **Преимущество:** Менее чувствителен к выбору $m$. Часто в качестве $m$ выбирают степень двойки ($2^p$), что упрощает реализацию на битовом уровне.
*   **Пример (упрощённо):** $k = 123456, A \approx 0.618033 ((\sqrt{5}-1)/2), m=128$. Вычисляем $123456 \cdot 0.618033... \approx 76300.004$. Дробная часть $\approx 0.004$. Тогда $h(k) = \lfloor 128 \cdot 0.004 \rfloor = 0$.

**2.3. Метод середины квадрата (Mid-Square Method)**
1.  Ключ $k$ возводится в квадрат.
2.  Из середины полученного квадрата извлекается несколько цифр (битов), которые становятся хеш-значением.
*   **Проблема:** Может давать много коллизий и требует тщательного выбора разрядов.

**Основной недостаток** простых арифметических функций — их чувствительность к закономерностям во входных данных, что приводит к частым коллизиям.

---

#### **3. Алгоритм Пирсона (Pearson Hashing)**

Это простая, но эффективная **байт-ориентированная** хеш-функция, разработанная Питером Пирсоном. Она идеально подходит для небольших хеш-таблиц (например, размером 256 байт) и обладает свойством **идеального распределения** для последовательных входных данных.

**3.1. Принцип работы**
1.  Используется **заранее определённая случайная перестановка** $T$ всех 256 возможных байтовых значений (0..255). Таблица $T$ должна быть определена один раз.
2.  Алгоритм обрабатывает ключ побайтово.
3.  Начальное значение хеша $h$ обычно равно 0.
4.  Для каждого байта $c$ входного сообвания (ключа) выполняется:
    $$
    h = T[h \oplus c]
    $$
    где $\oplus$ — операция побитового исключающего ИЛИ (XOR).
5.  После обработки всех байт финальное значение $h$ и есть хеш-код (в диапазоне 0..255).

**3.2. Псевдокод алгоритма (математическое описание)**
```
Вход: Ключ key как массив байт [k0, k1, ..., kn-1]
Выход: 8-битный хеш-код h (0 ≤ h ≤ 255)

Определена таблица перестановок T[0..255]
h := 0
для каждого i от 0 до n-1:
    h := T[ h XOR ki ]
вернуть h
```

**3.3. Пример вычисления**
Пусть есть маленькая таблица $T$ размера 8 (для наглядности): `T = [2, 7, 1, 4, 3, 0, 5, 6]`.
Ключ: "HASH" (байты в ASCII: H=72, A=65, S=83, H=72). Начальный хеш $h=0$.

1.  $h = T[0 \oplus 72] = T[72]$. Но наша таблица размером 8, поэтому берём байт по модулю 8: $72 \mod 8 = 0$. $T[0] = 2$. Итог: $h = 2$.
2.  $h = T[2 \oplus 65]$. $65 \mod 8 = 1$. $2 \oplus 1 = 3$. $T[3] = 4$. Итог: $h = 4$.
3.  $h = T[4 \oplus 83]$. $83 \mod 8 = 3$. $4 \oplus 3 = 7$. $T[7] = 6$. Итог: $h = 6$.
4.  $h = T[6 \oplus 72]$. $72 \mod 8 = 0$. $6 \oplus 0 = 6$. $T[6] = 5$. **Финальный хеш: $h = 5$.**

**3.4. Свойства алгоритма Пирсона**
*   **Простота:** Легко реализуется на любом языке.
*   **Идеальное распределение:** При изменении хотя бы одного бита входной строки хеш меняется непредсказуемо благодаря таблице перестановок.
*   **Невосстановимость:** Не является криптографическим, но даёт хорошее лавинное рассеивание для задач общего хеширования.
*   **Ограничение:** Выдаёт хеш фиксированной малой длины (обычно 8 бит). Для получения более длинного хеша (например, 16 бит) можно выполнить алгоритм дважды: второй раз с другим начальным значением (например, 1) и объединить результаты.

**Основное применение:** Быстрое хеширование строк для размещения в небольших хеш-таблицах, аппаратные реализации, контрольные суммы.