## **1. МЕТОД ПРОБНЫХ ДЕЛИТЕЛЕЙ**

### **Формальное описание алгоритма**

**Вход:** Натуральное число n>1n>1.  
**Выход:** Каноническое разложение nn на простые множители.

**Обозначения:**

- Пусть p0,p1,p2,…p0​,p1​,p2​,… — последовательность простых чисел: 2, 3, 5, 7, 11, ...
- Пусть d0,d1,…,dsd0​,d1​,…,ds​ — последовательность найденных делителей.

**Шаги алгоритма:**

1. **Инициализация:**
    
    - k←0k←0 (индекс текущего пробного делителя)
    - i←0i←0 (индекс найденного делителя)
    - a←na←n (текущее значение числа для разложения)
2. **Основной цикл:** Пока a>1a>1 выполнять:
    
    a. **Деление с остатком:**
    
    q=⌊apk⌋,r=a−pk⋅qq=⌊pk​a​⌋,r=a−pk​⋅q
    
    b. **Проверка делимости:**
    
    - Если r=0r=0, то:
        - di←pkdi​←pk​ (запоминаем делитель)
        - i←i+1i←i+1
        - a←qa←q (продолжаем деление на тот же делитель)
    - Иначе если q>pkq>pk​, то:
        - k←k+1k←k+1 (переходим к следующему простому числу)
    - Иначе:
        
        - di←adi​←a (оставшееся число простое)
        - Завершить алгоритм
3. **Результат:** Последовательность d0,d1,…,did0​,d1​,…,di​, где возможно повторение одинаковых делителей.
    

---

### **Теоретическое обоснование**

**Теорема 1.9** утверждает, что если число nn составное, то оно имеет простой делитель p≤np≤n​.

**Следствие:** Если при проверке всех простых делителей до nn​ ни один не делит nn, то nn — простое число.

**В алгоритме:**

- Условие q>pkq>pk​ эквивалентно pk2≤apk2​≤a (так как q=⌊a/pk⌋q=⌊a/pk​⌋)
    
- Когда q≤pkq≤pk​, это означает pk2≥apk2​≥a, следовательно, если aa составное, то его наименьший простой делитель должен быть ≤a≤pk≤a​≤pk​
    
- Но все простые числа до pkpk​ уже проверены, значит aa — простое
    

---

### **Пример применения**

**Разложение числа 6930:**

|Шаг|aa|pkpk​|qq|rr|Действие|Найденный делитель|
|---|---|---|---|---|---|---|
|1|6930|2|3465|0|a←3465a←3465|d0=2d0​=2|
|2|3465|2|1732|1|k←1k←1|—|
|3|3465|3|1155|0|a←1155a←1155|d1=3d1​=3|
|4|1155|3|385|0|a←385a←385|d2=3d2​=3|
|5|385|3|128|1|k←2k←2|—|
|6|385|5|77|0|a←77a←77|d3=5d3​=5|
|7|77|5|15|2|k←3k←3|—|
|8|77|7|11|0|a←11a←11|d4=7d4​=7|
|9|11|7|1|4|q≤pkq≤pk​|d5=11d5​=11|

**Результат:** 6930=2⋅3⋅3⋅5⋅7⋅11=2⋅32⋅5⋅7⋅116930=2⋅3⋅3⋅5⋅7⋅11=2⋅32⋅5⋅7⋅11

---

## **2. МЕТОД ФЕРМА**

### **Математическая основа**

**Идея:** Любое нечётное число nn можно представить как разность квадратов:

n=x2−y2=(x−y)(x+y)n=x2−y2=(x−y)(x+y)

Если n=a⋅bn=a⋅b (a≤ba≤b), то:

x=a+b2,y=b−a2x=2a+b​,y=2b−a​

**Замечание:** Для нечётных aa и bb числа xx и yy целые.

---

### **Формальное описание алгоритма**

**Вход:** Нечётное составное число nn.  
**Выход:** Два множителя aa и bb такие, что n=a⋅bn=a⋅b.

**Предварительный шаг:** Если nn чётное, вынести степень двойки.

**Обозначения:**

- h=⌊n⌋h=⌊n​⌋ — начальное приближение для xx
    
- Rx=2x+1Rx​=2x+1, Ry=2y+1Ry​=2y+1
    
- R(x,y)=x2−y2−nR(x,y)=x2−y2−n — функция невязки
    

**Шаги алгоритма:**

1. **Инициализация:**
    
    x←h,y←0x←h,y←0Rx←2h+1,Ry←1Rx​←2h+1,Ry​←1R(x,y)←h2−nR(x,y)←h2−n
2. **Итерационный процесс:** Пока R(x,y)≠0R(x,y)=0:
    
    - Если R(x,y)>0R(x,y)>0, то:
        
        R(x,y)←R(x,y)−RyR(x,y)←R(x,y)−Ry​Ry←Ry+2Ry​←Ry​+2y←y+1y←y+1
    - Иначе (R(x,y)<0R(x,y)<0):
        
        R(x,y)←R(x,y)+RxR(x,y)←R(x,y)+Rx​Rx←Rx+2Rx​←Rx​+2x←x+1x←x+1
3. **Вычисление результата:**
    
    a=x−y,b=x+ya=x−y,b=x+yn=a⋅bn=a⋅b

---

### **Теоретическое обоснование**

**Теорема 1.12:** Алгоритм Ферма всегда завершает работу для составного нечётного nn.

**Доказательство:**

1. Пусть n=a⋅bn=a⋅b, где a≤ba≤b — нечётные числа
    
2. Тогда существуют целые:
    
    x=a+b2,y=b−a2x=2a+b​,y=2b−a​
3. Докажем, что n<x<n+12n​<x<2n+1​:
    
    - Левое неравенство: x2=(a+b2)2=a2+2ab+b24>4ab4=ab=nx2=(2a+b​)2=4a2+2ab+b2​>44ab​=ab=n
        
    - Правое неравенство: 2x=a+b<1+ab=1+n2x=a+b<1+ab=1+n
        
4. Алгоритм начинает с x=⌊n⌋x=⌊n​⌋ и увеличивает xx, пока не достигнет значения a+b22a+b​
    

**Сложность алгоритма:** Зависит от разности между множителями. Худший случай — когда множители близки к nn​ (тогда алгоритм эффективен), лучший случай — когда один множитель мал.

---

### **Пример применения**

**Разложение числа 2520:**

1. Предварительно выносим степень двойки: 2520=8⋅3152520=8⋅315
    
2. Применяем алгоритм Ферма к n=315n=315
    

**Итерационный процесс:**

|Итерация|R(x,y)R(x,y)|RxRx​|RyRy​|xx|yy|
|---|---|---|---|---|---|
|0|-54|37|1|17|0|
|1|-53|37|3|17|1|
|2|-50|37|5|17|2|
|...|...|...|...|...|...|
|10|0|55|19|27|9|

3. **Результат:**
    
    a=27−9=18,b=27+9=36a=27−9=18,b=27+9=36315=18⋅36=(2⋅9)⋅(4⋅9)=(2⋅32)⋅(22⋅32)315=18⋅36=(2⋅9)⋅(4⋅9)=(2⋅32)⋅(22⋅32)

---

### **Сравнение методов**

|Критерий|Метод пробных делителей|Метод Ферма|
|---|---|---|
|**Принцип**|Последовательная проверка деления на простые числа|Представление числа как разности квадратов|
|**Эффективность**|Эффективен при наличии малых простых делителей|Эффективен, когда множители близки к √n|
|**Сложность**|В худшем случае O(√n) операций|Зависит от разности множителей|
|**Преимущества**|Простота реализации, находит все простые делители|Не требует операции деления, только сложение и умножение|
|**Недостатки**|Много "холостых" делений для больших чисел|Неэффективен, когда множители сильно различаются|

---

### **Практические рекомендации**

1. **Комбинированный подход:**
    
    - Использовать метод пробных делителей для поиска малых простых делителей (до некоторой границы)
        
    - Для оставшейся части применять метод Ферма или другие алгоритмы
        
2. **Оптимизация метода Ферма:**
    
    - Начинать с x=⌈n⌉x=⌈n​⌉
        
    - Использовать формулу xk+12=xk2+2xk+1xk+12​=xk2​+2xk​+1 для быстрого вычисления квадратов
        
3. **Применение в криптографии:**
    
    - Оба метода неэффективны для факторизации больших чисел (сотни цифр)
        
    - Современные методы (квадратичное решето, общий метод решета числового поля) основаны на развитии идей Ферма