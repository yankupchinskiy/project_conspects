#### **1. Электронная подпись на основе RSA**

Идея электронной (цифровой) подписи (ЭП) заключается в том, чтобы **удостоверить авторство и целостность** электронного документа с помощью криптографических методов. В асимметричной схеме подпись создаётся с использованием **закрытого ключа** отправителя, а проверяется — с помощью соответствующего **открытого ключа**.

**1.1. Базовая схема RSA-PSS (Probabilistic Signature Scheme):**
В учебнике описана следующая вероятностная схема подписи, являющаяся упрощённой моделью современных стандартов.

*   **Участники:** Отправитель (Алиса) обладает парой RSA-ключей: открытый $(e, n)$, закрытый $(d, n)$. Получатель (Боб) знает открытый ключ Алисы.
*   **Генерация подписи для сообщения $M$ (действия Алисы):**
    1.  Вычисляется **хэш-образ** сообщения: $h = H(M)$, где $H$ — криптографическая хэш-функция (например, SHA-256).
    2.  Генерируется **случайная последовательность** (соль, salt): $r$.
    3.  Формируется **расширенный хэш**: $h' = h + r$.
    4.  **Подписывается** расширенный хэш с помощью закрытого ключа: $s = (h')^d \mod n$.
    5.  **Подписанное сообщение** отправляется Бобу в виде пары $(M, s, r)$.

*   **Проверка подписи (действия Боба):**
    1.  Получив $(M, s, r)$, Боб вычисляет хэш полученного сообщения: $h = H(M)$.
    2.  Восстанавливает расширенный хэш, используя открытый ключ Алисы: $h'' = s^e \mod n$.
    3.  Вычисляет ожидаемый расширенный хэш: $h' = h + r$.
    4.  **Подпись верна**, если выполняется равенство: $h'' \equiv h' \pmod{n}$.

**Корректность** следует из свойств RSA: поскольку $s \equiv (h+r)^d \pmod{n}$, то $s^e \equiv (h+r)^{d \cdot e} \equiv h+r \pmod{n}$ (при условии взаимной простоты $h+r$ и $n$).

**1.2. Назначение компонентов:**
*   **Хэш-функция $H$:** Обеспечивает целостность сообщения. Любое изменение $M$ приведёт к изменению $h$ и срыву проверки. Также позволяет работать с сообщениями любой длины.
*   **Соль $r$:** Делает подпись **вероятностной**. Даже для одного и того же сообщения $M$ при каждом подписании будет генерироваться разная подпись $(s, r)$, что повышает криптостойкость и предотвращает некоторые атаки.

---

#### **2. Электронные деньги (схема на основе слепой подписи)**

В учебнике описана базовая криптографическая схема электронных денег, обеспечивающая **анонимность** плательщика и **защиту от двойного расходования**.

**2.1. Участники схемы:**
1.  **Банк (B):** Эмитент электронных денег. Имеет пару RSA-ключей: открытый $(e_B, n_B)$, закрытый $(d_B, n_B)$.
2.  **Пользователь (П):** Клиент банка, желающий получить электронные деньги.
3.  **Магазин (М):** Принимает электронные деньги в оплату.

**2.2. Основные этапы работы:**

**a) Получение электронных денег (П ↔ Б):**
1.  Пользователь создаёт платёжный **жетон (token)** $T$, содержащий его уникальный идентификатор и, возможно, номинал.
2.  Пользователь **«ослепляет»** жетон: выбирает случайный **«ослепляющий» множитель** $k$, взаимно простой с $n_B$, и вычисляет слепую версию:
    $$
    \widetilde{T} = T \cdot k^e \mod n_B.
    $$
    Число $\widetilde{T}$ отправляется банку.
3.  Банк **подписывает** слепой жетон своим закрытым ключом:
    $$
    \widetilde{S} = (\widetilde{T})^{d_B} \mod n_B.
    $$
    Банк списывает со счёта пользователя соответствующую сумму и отправляет $\widetilde{S}$ пользователю.
4.  Пользователь **«снимает ослепление»**, удаляя множитель $k$. Для этого он вычисляет обратный элемент $k^{-1} \mod n_B$ (существует, т.к. $D(k, n_B)=1$) и получает подписанный банком исходный жетон:
    $$
    S = \widetilde{S} \cdot k^{-1} \mod n_B.
    $$
    Корректность: $S \equiv (T \cdot k^e)^{d_B} \cdot k^{-1} \equiv T^{d_B} \cdot k^{e \cdot d_B} \cdot k^{-1} \equiv T^{d_B} \cdot k \cdot k^{-1} \equiv T^{d_B} \pmod{n_B}$.
    Пара $(T, S)$ является **электронной наличностью**.

**b) Оплата в магазине (П → М):**
1.  Пользователь предъявляет магазину электронные деньги $(T, S)$.
2.  Магазин проверяет подпись банка с помощью открытого ключа банка, убеждаясь, что:
    $$
    S^{e_B} \equiv T \pmod{n_B}.
    $$
3.  **Важный этап:** Магазин связывается с банком и отправляет ему жетон $T$ (или его хэш), чтобы удостовериться, что эти деньги **ещё не были потрачены**. Банк проверяет $T$ по базе данных использованных жетонов.

**c) Депозит в банке (М → Б):**
1.  Магазин отправляет банку полученные деньги $(T, S)$ для зачисления на свой счёт.
2.  Банк снова проверяет подпись $S$.
3.  Банк проверяет, не числится ли жетон $T$ в своём «списке потраченных». Если нет — банк зачисляет деньги магазину и **вносит $T$ в базу использованных жетонов**. Если жетон уже есть в базе — это факт **двойного расходования**.

**2.3. Ключевые свойства схемы:**
*   **Анонимность (слепота):** Банк, подписывая $\widetilde{T}$, не знает, какой конкретно жетон $T$ он подписал, так как тот был скрыт множителем $k$. Поэтому банк не может связать операцию выдачи денег с конкретной операцией оплаты в магазине.
*   **Защита от двойного расходования:** Если пользователь попытается дважды потратить один и тот же жетон $(T, S)$, банк обнаружит это при второй попытке внесения жетона магазином, так как $T$ уже будет в базе. При этом **раскрывается личность мошенника**, так как жетон $T$ содержит его идентификатор, известный банку на этапе выпуска.

**Заключение:** Описанные схемы представляют собой фундаментальные криптографические приложения теоретико-числовых алгоритмов (RSA, хэш-функций, модульной арифметики). Современные реализаций электронной подписи (ECDSA, EdDSA) и цифровых валют используют более сложные протоколы и математический аппарат, но базовые принципы — асимметричное шифрование для подписи и механизмы обеспечения анонимности и контроля уникальности — остаются схожими.