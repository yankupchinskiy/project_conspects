### **1. Постановка задачи**

Пусть даны **две строки**:
*   `A = a₁a₂...aₙ` длины `n`
*   `B = b₁b₂...bₘ` длины `m`

Требуется найти **редакционное расстояние (расстояние Левенштейна)** `D(A, B)` между этими строками, которое определяется как **минимальное количество элементарных операций редактирования**, необходимых для преобразования строки `A` в строку `B`.

**Допустимые элементарные операции:**
1.  **Удаление (D)** — удалить один символ из строки `A`. Стоимость операции: 1.
2.  **Вставка (I)** — вставить один символ в строку `A`. Стоимость операции: 1.
3.  **Замена (R)** — заменить один символ в строке `A` на другой. Стоимость операции: 1.
4.  **Совпадение (M)** — символы в позициях совпадают. Стоимость операции: 0.

*Примечание:* Иногда рассматривают только первые три операции (редакционное расстояние). Совпадение — это частный случай замены со стоимостью 0.

**Редакционное предписание** — это последовательность операций, которая приводит к минимальному общему расстоянию и описывает, как именно преобразовать `A` в `B`.

---

### **2. Метод динамического программирования для вычисления расстояния**

**Основная идея:** Расстояние между префиксами строк можно выразить через расстояния между их более короткими префиксами.

#### **2.1. Определение состояния**
Пусть `dp[i][j]` — **редакционное расстояние** между префиксами строк `A[1..i]` и `B[1..j]` (где `i` от `0` до `n`, `j` от `0` до `m`).
*   `A[1..i]` — первые `i` символов строки `A`.
*   `B[1..j]` — первые `j` символов строки `B`.
*   `dp[0][0]` — расстояние между двумя пустыми строками.

#### **2.2. Базовые случаи**
1.  `dp[0][0] = 0`. Чтобы превратить пустую строку в пустую, не нужно операций.
2.  `dp[i][0] = i` для всех `i = 1..n`. Чтобы превратить строку длины `i` в пустую, нужно выполнить `i` операций удаления.
3.  `dp[0][j] = j` для всех `j = 1..m`. Чтобы превратить пустую строку в строку длины `j`, нужно выполнить `j` операций вставки.

#### **2.3. Рекуррентное соотношение (переход)**
Для `i > 0` и `j > 0` значение `dp[i][j]` вычисляется как **минимум из трех возможных вариантов**, соответствующих последней примененной операции:

1.  **Если последняя операция — удаление символа `aᵢ` из `A`.** Тогда мы преобразовали `A[1..i-1]` в `B[1..j]`, и удалили `aᵢ`. Стоимость: `dp[i-1][j] + 1`.
2.  **Если последняя операция — вставка символа `bⱼ` в `A`.** Тогда мы преобразовали `A[1..i]` в `B[1..j-1]`, и вставили `bⱼ`. Стоимость: `dp[i][j-1] + 1`.
3.  **Если последняя операция — замена символа `aᵢ` на `bⱼ` (или совпадение).** Тогда мы преобразовали `A[1..i-1]` в `B[1..j-1]`.
    *   Если `aᵢ == bⱼ` (символы совпадают), замена не требуется. Стоимость: `dp[i-1][j-1] + 0`.
    *   Если `aᵢ != bⱼ`, требуется замена. Стоимость: `dp[i-1][j-1] + 1`.

**Итоговая формула:**
`dp[i][j] = min( dp[i-1][j] + 1,              // Удаление
                 dp[i][j-1] + 1,              // Вставка
                 dp[i-1][j-1] + diff(aᵢ, bⱼ) // Замена/Совпадение
               )`
где `diff(a, b) = 0`, если `a == b`, и `1` в противном случае.

#### **2.4. Порядок вычислений и результат**
Заполняем таблицу `dp` размером `(n+1) × (m+1)` построчно (по возрастанию `i` от 0 до `n`) и для каждой строки по столбцам (по возрастанию `j` от 0 до `m`).
**Ответ:** `dp[n][m]`.

---

### **3. Алгоритм построения редакционного предписания**

Редакционное предписание восстанавливается **обратным проходом** из ячейки `dp[n][m]` в `dp[0][0]`, выбирая на каждом шаге тот переход, который привел к минимальному значению.

#### **3.1. Алгоритм обратного хода**
1.  Инициализация: `i = n`, `j = m`.
2.  Пока `i > 0` или `j > 0`:
    *   Если `i > 0` и `dp[i][j] == dp[i-1][j] + 1`, то **последней была операция удаления** символа `aᵢ` из строки `A`. Записываем операцию `D(aᵢ)`. `i = i - 1`.
    *   Иначе, если `j > 0` и `dp[i][j] == dp[i][j-1] + 1`, то **последней была операция вставки** символа `bⱼ` в строку `A`. Записываем операцию `I(bⱼ)`. `j = j - 1`.
    *   Иначе (оставшийся случай — `i > 0` и `j > 0`), то **последней была операция замены/совпадения**:
        *   Если `aᵢ == bⱼ`, то это **совпадение**. Записываем операцию `M(aᵢ)` (или пропускаем). `i = i - 1`, `j = j - 1`.
        *   Если `aᵢ != bⱼ`, то это **замена**. Записываем операцию `R(aᵢ → bⱼ)`. `i = i - 1`, `j = j - 1`.
3.  Последовательность операций, полученная при обратном проходе, является обратной к требуемому редакционному предписанию. Её необходимо развернуть.

#### **3.2. Пример построения предписания**
Пусть `A = "КОТ"`, `B = "СКАТ"`.

**Таблица `dp`:**

| i\j | ∅ | С | К | А | Т |
|:---:|:-:|:-:|:-:|:-:|:-:|
| **∅** | 0 | 1 | 2 | 3 | 4 |
| **К** | 1 | 1 | 1 | 2 | 3 |
| **О** | 2 | 2 | 2 | 2 | 3 |
| **Т** | 3 | 3 | 3 | 3 | **2** |

**Восстановление из `dp[3][4] = 2`:**
1.  `(i=3, j=4)`. `dp[3][4] = 2`. `a₃='Т'`, `b₄='Т'`. `a₃ == b₄` и `dp[3][4] == dp[2][3] + 0`. → **Совпадение (M)**. Переход в `(2, 3)`.
2.  `(i=2, j=3)`. `dp[2][3] = 2`. `a₂='О'`, `b₃='А'`. `dp[2][3] == dp[1][2] + 1` (проверяем: `1 + 1 = 2`). → **Замена (R(О→А))**. Переход в `(1, 2)`.
3.  `(i=1, j=2)`. `dp[1][2] = 1`. `a₁='К'`, `b₂='К'`. `a₁ == b₂` и `dp[1][2] == dp[0][1] + 0`. → **Совпадение (M)**. Переход в `(0, 1)`.
4.  `(i=0, j=1)`. `dp[0][1] = 1`. `dp[0][1] == dp[0][0] + 1`. → **Вставка (I(С))**. Переход в `(0, 0)`.
5.  `(i=0, j=0)`. Стоп.

**Полученная обратная последовательность:** M(Т), R(О→А), M(К), I(С).
**Прямое редакционное предписание (после разворота):** `I(С)`, `M(К)`, `R(О→А)`, `M(Т)`.

**Проверка:** Применяем предписание к `"КОТ"`:
1.  `I(С)` → `"СКОТ"`
2.  `M(К)` → `"СКОТ"` (символ 'К' остается)
3.  `R(О→А)` → `"СКАТ"`
4.  `M(Т)` → `"СКАТ"` (символ 'Т' остается). Получили `"СКАТ"`.

---

### **4. Вычислительная сложность**
*   **Время:** `O(n * m)`, так как требуется заполнить таблицу из `(n+1)*(m+1)` ячеек, и вычисление каждой — `O(1)`.
*   **Память:** `O(n * m)` для хранения всей таблицы. Можно оптимизировать до `O(min(n, m))`, если хранить только две последние строки (или столбцы), но тогда восстановление предписания усложняется.

**Ключевой вывод:** Динамическое программирование позволяет эффективно решить задачу выравнивания строк, находя не только минимальное расстояние, но и оптимальную последовательность операций для его достижения.